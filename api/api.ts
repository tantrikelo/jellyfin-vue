/* tslint:disable */
/* eslint-disable */
/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An entity representing a user\'s access schedule.
 * @export
 * @interface AccessSchedule
 */
export interface AccessSchedule {
    /**
     * Gets or sets the id of this instance.
     * @type {number}
     * @memberof AccessSchedule
     */
    Id: number;
    /**
     * Gets or sets the id of the associated user.
     * @type {string}
     * @memberof AccessSchedule
     */
    UserId: string;
    /**
     * 
     * @type {DynamicDayOfWeek}
     * @memberof AccessSchedule
     */
    DayOfWeek: DynamicDayOfWeek;
    /**
     * Gets or sets the start hour.
     * @type {number}
     * @memberof AccessSchedule
     */
    StartHour: number;
    /**
     * Gets or sets the end hour.
     * @type {number}
     * @memberof AccessSchedule
     */
    EndHour: number;
}
/**
 * 
 * @export
 * @interface ActivityLogEntry
 */
export interface ActivityLogEntry {
    /**
     * Gets or sets the identifier.
     * @type {number}
     * @memberof ActivityLogEntry
     */
    Id?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Name?: string | null;
    /**
     * Gets or sets the overview.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Overview?: string | null;
    /**
     * Gets or sets the short overview.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ShortOverview?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Type?: string | null;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ItemId?: string | null;
    /**
     * Gets or sets the date.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Date?: string;
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof ActivityLogEntry
     */
    UserId?: string;
    /**
     * Gets or sets the user primary image tag.
     * @type {string}
     * @memberof ActivityLogEntry
     * @deprecated
     */
    UserPrimaryImageTag?: string | null;
    /**
     * 
     * @type {LogLevel}
     * @memberof ActivityLogEntry
     */
    Severity?: LogLevel;
}
/**
 * 
 * @export
 * @interface ActivityLogEntryQueryResult
 */
export interface ActivityLogEntryQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<ActivityLogEntry>}
     * @memberof ActivityLogEntryQueryResult
     */
    Items?: Array<ActivityLogEntry> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    StartIndex?: number;
}
/**
 * Add virtual folder dto.
 * @export
 * @interface AddVirtualFolderDto
 */
export interface AddVirtualFolderDto {
    /**
     * 
     * @type {LibraryOptions}
     * @memberof AddVirtualFolderDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * 
 * @export
 * @interface AlbumInfo
 */
export interface AlbumInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof AlbumInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof AlbumInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof AlbumInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumInfo
     */
    IsAutomated?: boolean;
    /**
     * Gets or sets the album artist.
     * @type {Array<string>}
     * @memberof AlbumInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * Gets or sets the artist provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ArtistProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof AlbumInfo
     */
    SongInfos?: Array<SongInfo> | null;
}
/**
 * 
 * @export
 * @interface AlbumInfoRemoteSearchQuery
 */
export interface AlbumInfoRemoteSearchQuery {
    /**
     * 
     * @type {AlbumInfo}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchInfo?: AlbumInfo;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface AllThemeMediaResult
 */
export interface AllThemeMediaResult {
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeVideosResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeSongsResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    SoundtrackSongsResult?: ThemeMediaResult;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Architecture {
    X86 = 'X86',
    X64 = 'X64',
    Arm = 'Arm',
    Arm64 = 'Arm64'
}

/**
 * 
 * @export
 * @interface ArtistInfo
 */
export interface ArtistInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ArtistInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ArtistInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof ArtistInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof ArtistInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ArtistInfo
     */
    IsAutomated?: boolean;
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof ArtistInfo
     */
    SongInfos?: Array<SongInfo> | null;
}
/**
 * 
 * @export
 * @interface ArtistInfoRemoteSearchQuery
 */
export interface ArtistInfoRemoteSearchQuery {
    /**
     * 
     * @type {ArtistInfo}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchInfo?: ArtistInfo;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * The authenticate user by name request body.
 * @export
 * @interface AuthenticateUserByName
 */
export interface AuthenticateUserByName {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Username?: string | null;
    /**
     * Gets or sets the plain text password.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Pw?: string | null;
    /**
     * Gets or sets the sha1-hashed password.
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfo
 */
export interface AuthenticationInfo {
    /**
     * Gets or sets the identifier.
     * @type {number}
     * @memberof AuthenticationInfo
     */
    Id?: number;
    /**
     * Gets or sets the access token.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AccessToken?: string | null;
    /**
     * Gets or sets the device identifier.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the name of the application.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the name of the device.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserId?: string;
    /**
     * Gets or sets a value indicating whether this instance is active.
     * @type {boolean}
     * @memberof AuthenticationInfo
     */
    IsActive?: boolean;
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateCreated?: string;
    /**
     * Gets or sets the date revoked.
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateRevoked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfoQueryResult
 */
export interface AuthenticationInfoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<AuthenticationInfo>}
     * @memberof AuthenticationInfoQueryResult
     */
    Items?: Array<AuthenticationInfo> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface AuthenticationResult
 */
export interface AuthenticationResult {
    /**
     * 
     * @type {UserDto}
     * @memberof AuthenticationResult
     */
    User?: UserDto;
    /**
     * 
     * @type {SessionInfo}
     * @memberof AuthenticationResult
     */
    SessionInfo?: SessionInfo;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    AccessToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    ServerId?: string | null;
}
/**
 * Class BaseItem.
 * @export
 * @interface BaseItem
 */
export interface BaseItem {
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    DateLastSaved?: string;
    /**
     * Gets or sets the remote trailers.
     * @type {Array<MediaUrl>}
     * @memberof BaseItem
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsHD?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsShortcut?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    ShortcutPath?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Width?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Height?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItem
     */
    ExtraIds?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    SupportsExternalTransfer?: boolean;
}
/**
 * This is strictly used as a data transfer object from the api layer.  This holds information about a BaseItem in a format that is convenient for the client.
 * @export
 * @interface BaseItemDto
 */
export interface BaseItemDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BaseItemDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    OriginalTitle?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof BaseItemDto
     */
    Id?: string;
    /**
     * Gets or sets the etag.
     * @type {string}
     * @memberof BaseItemDto
     */
    Etag?: string | null;
    /**
     * Gets or sets the type of the source.
     * @type {string}
     * @memberof BaseItemDto
     */
    SourceType?: string | null;
    /**
     * Gets or sets the playlist item identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    PlaylistItemId?: string | null;
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof BaseItemDto
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DateLastMediaAdded?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ExtraType?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsAfterSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeEpisodeNumber?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDelete?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDownload?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    HasSubtitles?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataCountryCode?: string | null;
    /**
     * Gets or sets a value indicating whether [supports synchronize].
     * @type {boolean}
     * @memberof BaseItemDto
     */
    SupportsSync?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Container?: string | null;
    /**
     * Gets or sets the name of the sort.
     * @type {string}
     * @memberof BaseItemDto
     */
    SortName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ForcedSortName?: string | null;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof BaseItemDto
     */
    Video3DFormat?: Video3DFormat;
    /**
     * Gets or sets the premiere date.
     * @type {string}
     * @memberof BaseItemDto
     */
    PremiereDate?: string | null;
    /**
     * Gets or sets the external urls.
     * @type {Array<ExternalUrl>}
     * @memberof BaseItemDto
     */
    ExternalUrls?: Array<ExternalUrl> | null;
    /**
     * Gets or sets the media versions.
     * @type {Array<MediaSourceInfo>}
     * @memberof BaseItemDto
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * Gets or sets the critic rating.
     * @type {number}
     * @memberof BaseItemDto
     */
    CriticRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ProductionLocations?: Array<string> | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BaseItemDto
     */
    Path?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    EnableMediaSourceDisplay?: boolean | null;
    /**
     * Gets or sets the official rating.
     * @type {string}
     * @memberof BaseItemDto
     */
    OfficialRating?: string | null;
    /**
     * Gets or sets the custom rating.
     * @type {string}
     * @memberof BaseItemDto
     */
    CustomRating?: string | null;
    /**
     * Gets or sets the channel identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelName?: string | null;
    /**
     * Gets or sets the overview.
     * @type {string}
     * @memberof BaseItemDto
     */
    Overview?: string | null;
    /**
     * Gets or sets the taglines.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Taglines?: Array<string> | null;
    /**
     * Gets or sets the genres.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Genres?: Array<string> | null;
    /**
     * Gets or sets the community rating.
     * @type {number}
     * @memberof BaseItemDto
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the cumulative run time ticks.
     * @type {number}
     * @memberof BaseItemDto
     */
    CumulativeRunTimeTicks?: number | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof BaseItemDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {PlayAccess}
     * @memberof BaseItemDto
     */
    PlayAccess?: PlayAccess;
    /**
     * Gets or sets the aspect ratio.
     * @type {string}
     * @memberof BaseItemDto
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the production year.
     * @type {number}
     * @memberof BaseItemDto
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is place holder.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPlaceHolder?: boolean | null;
    /**
     * Gets or sets the number.
     * @type {string}
     * @memberof BaseItemDto
     */
    Number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelNumber?: string | null;
    /**
     * Gets or sets the index number.
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the index number end.
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumberEnd?: number | null;
    /**
     * Gets or sets the parent index number.
     * @type {number}
     * @memberof BaseItemDto
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the trailer urls.
     * @type {Array<MediaUrl>}
     * @memberof BaseItemDto
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BaseItemDto
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets a value indicating whether this instance is HD.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsHD?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is folder.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the parent id.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentId?: string;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof BaseItemDto
     */
    Type?: string | null;
    /**
     * Gets or sets the people.
     * @type {Array<BaseItemPerson>}
     * @memberof BaseItemDto
     */
    People?: Array<BaseItemPerson> | null;
    /**
     * Gets or sets the studios.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    Studios?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    GenreItems?: Array<NameGuidPair> | null;
    /**
     * If the item does not have a logo, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoItemId?: string | null;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the local trailer count.
     * @type {number}
     * @memberof BaseItemDto
     */
    LocalTrailerCount?: number | null;
    /**
     * 
     * @type {UserItemDataDto}
     * @memberof BaseItemDto
     */
    UserData?: UserItemDataDto;
    /**
     * Gets or sets the recursive item count.
     * @type {number}
     * @memberof BaseItemDto
     */
    RecursiveItemCount?: number | null;
    /**
     * Gets or sets the child count.
     * @type {number}
     * @memberof BaseItemDto
     */
    ChildCount?: number | null;
    /**
     * Gets or sets the name of the series.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesName?: string | null;
    /**
     * Gets or sets the series id.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesId?: string;
    /**
     * Gets or sets the season identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonId?: string;
    /**
     * Gets or sets the special feature count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SpecialFeatureCount?: number | null;
    /**
     * Gets or sets the display preferences id.
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayPreferencesId?: string | null;
    /**
     * Gets or sets the status.
     * @type {string}
     * @memberof BaseItemDto
     */
    Status?: string | null;
    /**
     * Gets or sets the air time.
     * @type {string}
     * @memberof BaseItemDto
     */
    AirTime?: string | null;
    /**
     * Gets or sets the air days.
     * @type {Array<DayOfWeek>}
     * @memberof BaseItemDto
     */
    AirDays?: Array<DayOfWeek> | null;
    /**
     * Gets or sets the tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Tags?: Array<string> | null;
    /**
     * Gets or sets the primary image aspect ratio, after image enhancements.
     * @type {number}
     * @memberof BaseItemDto
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * Gets or sets the artists.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the artist items.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    ArtistItems?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the album.
     * @type {string}
     * @memberof BaseItemDto
     */
    Album?: string | null;
    /**
     * Gets or sets the type of the collection.
     * @type {string}
     * @memberof BaseItemDto
     */
    CollectionType?: string | null;
    /**
     * Gets or sets the display order.
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayOrder?: string | null;
    /**
     * Gets or sets the album id.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumId?: string;
    /**
     * Gets or sets the album image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumPrimaryImageTag?: string | null;
    /**
     * Gets or sets the series primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesPrimaryImageTag?: string | null;
    /**
     * Gets or sets the album artist.
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the album artists.
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    AlbumArtists?: Array<NameGuidPair> | null;
    /**
     * Gets or sets the name of the season.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonName?: string | null;
    /**
     * Gets or sets the media streams.
     * @type {Array<MediaStream>}
     * @memberof BaseItemDto
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {VideoType}
     * @memberof BaseItemDto
     */
    VideoType?: VideoType;
    /**
     * Gets or sets the part count.
     * @type {number}
     * @memberof BaseItemDto
     */
    PartCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    MediaSourceCount?: number | null;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof BaseItemDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * Gets or sets the backdrop image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    BackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets the screenshot image tags.
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ScreenshotImageTags?: Array<string> | null;
    /**
     * Gets or sets the parent logo image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoImageTag?: string | null;
    /**
     * If the item does not have a art, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtItemId?: string | null;
    /**
     * Gets or sets the parent art image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtImageTag?: string | null;
    /**
     * Gets or sets the series thumb image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesThumbImageTag?: string | null;
    /**
     * 
     * @type {BaseItemDtoImageBlurHashes}
     * @memberof BaseItemDto
     */
    ImageBlurHashes?: BaseItemDtoImageBlurHashes | null;
    /**
     * Gets or sets the series studio.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesStudio?: string | null;
    /**
     * Gets or sets the parent thumb item id.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * Gets or sets the chapters.
     * @type {Array<ChapterInfo>}
     * @memberof BaseItemDto
     */
    Chapters?: Array<ChapterInfo> | null;
    /**
     * 
     * @type {LocationType}
     * @memberof BaseItemDto
     */
    LocationType?: LocationType;
    /**
     * 
     * @type {IsoType}
     * @memberof BaseItemDto
     */
    IsoType?: IsoType;
    /**
     * Gets or sets the type of the media.
     * @type {string}
     * @memberof BaseItemDto
     */
    MediaType?: string | null;
    /**
     * Gets or sets the end date.
     * @type {string}
     * @memberof BaseItemDto
     */
    EndDate?: string | null;
    /**
     * Gets or sets the locked fields.
     * @type {Array<MetadataField>}
     * @memberof BaseItemDto
     */
    LockedFields?: Array<MetadataField> | null;
    /**
     * Gets or sets the trailer count.
     * @type {number}
     * @memberof BaseItemDto
     */
    TrailerCount?: number | null;
    /**
     * Gets or sets the movie count.
     * @type {number}
     * @memberof BaseItemDto
     */
    MovieCount?: number | null;
    /**
     * Gets or sets the series count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SeriesCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ProgramCount?: number | null;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof BaseItemDto
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof BaseItemDto
     */
    SongCount?: number | null;
    /**
     * Gets or sets the album count.
     * @type {number}
     * @memberof BaseItemDto
     */
    AlbumCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ArtistCount?: number | null;
    /**
     * Gets or sets the music video count.
     * @type {number}
     * @memberof BaseItemDto
     */
    MusicVideoCount?: number | null;
    /**
     * Gets or sets a value indicating whether [enable internet providers].
     * @type {boolean}
     * @memberof BaseItemDto
     */
    LockData?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraMake?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraModel?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Software?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ExposureTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    FocalLength?: number | null;
    /**
     * 
     * @type {ImageOrientation}
     * @memberof BaseItemDto
     */
    ImageOrientation?: ImageOrientation;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Aperture?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ShutterSpeed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Latitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Longitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Altitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    IsoSpeedRating?: number | null;
    /**
     * Gets or sets the series timer identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the channel primary image tag.
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof BaseItemDto
     */
    StartDate?: string | null;
    /**
     * Gets or sets the completion percentage.
     * @type {number}
     * @memberof BaseItemDto
     */
    CompletionPercentage?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is repeat.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsRepeat?: boolean | null;
    /**
     * Gets or sets the episode title.
     * @type {string}
     * @memberof BaseItemDto
     */
    EpisodeTitle?: string | null;
    /**
     * 
     * @type {ChannelType}
     * @memberof BaseItemDto
     */
    ChannelType?: ChannelType;
    /**
     * 
     * @type {ProgramAudio}
     * @memberof BaseItemDto
     */
    Audio?: ProgramAudio;
    /**
     * Gets or sets a value indicating whether this instance is movie.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is sports.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is series.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is live.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsLive?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is news.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is kids.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets a value indicating whether this instance is premiere.
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPremiere?: boolean | null;
    /**
     * Gets or sets the timer identifier.
     * @type {string}
     * @memberof BaseItemDto
     */
    TimerId?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof BaseItemDto
     */
    CurrentProgram?: BaseItemDto;
}
/**
 * Gets or sets the blurhashes for the image tags.  Maps image type to dictionary mapping image tag to blurhash value.
 * @export
 * @interface BaseItemDtoImageBlurHashes
 */
export interface BaseItemDtoImageBlurHashes {
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Primary?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Art?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Backdrop?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Banner?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Logo?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Thumb?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Disc?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Box?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Screenshot?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Menu?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Chapter?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    BoxRear?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemDtoImageBlurHashes
     */
    Profile?: BaseItemPersonImageBlurHashesPrimary;
}
/**
 * Gets or sets the image tags.
 * @export
 * @interface BaseItemDtoImageTags
 */
export interface BaseItemDtoImageTags {
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Primary?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Art?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Backdrop?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Banner?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Logo?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Thumb?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Disc?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Box?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Screenshot?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Menu?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Chapter?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    BoxRear?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Profile?: string;
}
/**
 * 
 * @export
 * @interface BaseItemDtoQueryResult
 */
export interface BaseItemDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<BaseItemDto>}
     * @memberof BaseItemDtoQueryResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * This is used by the api to get information about a Person within a BaseItem.
 * @export
 * @interface BaseItemPerson
 */
export interface BaseItemPerson {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Id?: string | null;
    /**
     * Gets or sets the role.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Role?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof BaseItemPerson
     */
    Type?: string | null;
    /**
     * Gets or sets the primary image tag.
     * @type {string}
     * @memberof BaseItemPerson
     */
    PrimaryImageTag?: string | null;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashes}
     * @memberof BaseItemPerson
     */
    ImageBlurHashes?: BaseItemPersonImageBlurHashes | null;
}
/**
 * Gets or sets the primary image blurhash.
 * @export
 * @interface BaseItemPersonImageBlurHashes
 */
export interface BaseItemPersonImageBlurHashes {
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Primary?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Art?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Backdrop?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Banner?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Logo?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Thumb?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Disc?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Box?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Screenshot?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Menu?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Chapter?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    BoxRear?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Profile?: BaseItemPersonImageBlurHashesPrimary;
}
/**
 * 
 * @export
 * @interface BaseItemPersonImageBlurHashesPrimary
 */
export interface BaseItemPersonImageBlurHashesPrimary {
    /**
     * 
     * @type {string}
     * @memberof BaseItemPersonImageBlurHashesPrimary
     */
    string?: string;
}
/**
 * 
 * @export
 * @interface BookInfo
 */
export interface BookInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BookInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BookInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof BookInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof BookInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BookInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof BookInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookInfo
     */
    IsAutomated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    SeriesName?: string | null;
}
/**
 * 
 * @export
 * @interface BookInfoRemoteSearchQuery
 */
export interface BookInfoRemoteSearchQuery {
    /**
     * 
     * @type {BookInfo}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchInfo?: BookInfo;
    /**
     * 
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof BookInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfo
 */
export interface BoxSetInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof BoxSetInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof BoxSetInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof BoxSetInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof BoxSetInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BoxSetInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfoRemoteSearchQuery
 */
export interface BoxSetInfoRemoteSearchQuery {
    /**
     * 
     * @type {BoxSetInfo}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchInfo?: BoxSetInfo;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BrandingOptions
 */
export interface BrandingOptions {
    /**
     * Gets or sets the login disclaimer.
     * @type {string}
     * @memberof BrandingOptions
     */
    LoginDisclaimer?: string | null;
    /**
     * Gets or sets the custom CSS.
     * @type {string}
     * @memberof BrandingOptions
     */
    CustomCss?: string | null;
}
/**
 * 
 * @export
 * @interface ChannelFeatures
 */
export interface ChannelFeatures {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ChannelFeatures
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof ChannelFeatures
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether this instance can search.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanSearch?: boolean;
    /**
     * Gets or sets the media types.
     * @type {Array<ChannelMediaType>}
     * @memberof ChannelFeatures
     */
    MediaTypes?: Array<ChannelMediaType> | null;
    /**
     * Gets or sets the content types.
     * @type {Array<ChannelMediaContentType>}
     * @memberof ChannelFeatures
     */
    ContentTypes?: Array<ChannelMediaContentType> | null;
    /**
     * Represents the maximum number of records the channel allows retrieving at a time.
     * @type {number}
     * @memberof ChannelFeatures
     */
    MaxPageSize?: number | null;
    /**
     * Gets or sets the automatic refresh levels.
     * @type {number}
     * @memberof ChannelFeatures
     */
    AutoRefreshLevels?: number | null;
    /**
     * Gets or sets the default sort orders.
     * @type {Array<ChannelItemSortField>}
     * @memberof ChannelFeatures
     */
    DefaultSortFields?: Array<ChannelItemSortField> | null;
    /**
     * Indicates if a sort ascending/descending toggle is supported or not.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsSortOrderToggle?: boolean;
    /**
     * Gets or sets a value indicating whether [supports latest media].
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsLatestMedia?: boolean;
    /**
     * Gets or sets a value indicating whether this instance can filter.
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanFilter?: boolean;
    /**
     * Gets or sets a value indicating whether [supports content downloading].
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsContentDownloading?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelItemSortField {
    Name = 'Name',
    CommunityRating = 'CommunityRating',
    PremiereDate = 'PremiereDate',
    DateCreated = 'DateCreated',
    Runtime = 'Runtime',
    PlayCount = 'PlayCount',
    CommunityPlayCount = 'CommunityPlayCount'
}

/**
 * Channel mapping options dto.
 * @export
 * @interface ChannelMappingOptionsDto
 */
export interface ChannelMappingOptionsDto {
    /**
     * Gets or sets list of tuner channels.
     * @type {Array<TunerChannelMapping>}
     * @memberof ChannelMappingOptionsDto
     */
    TunerChannels?: Array<TunerChannelMapping> | null;
    /**
     * Gets or sets list of provider channels.
     * @type {Array<NameIdPair>}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderChannels?: Array<NameIdPair> | null;
    /**
     * Gets or sets list of mappings.
     * @type {Array<NameValuePair>}
     * @memberof ChannelMappingOptionsDto
     */
    Mappings?: Array<NameValuePair> | null;
    /**
     * Gets or sets provider name.
     * @type {string}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderName?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaContentType {
    Clip = 'Clip',
    Podcast = 'Podcast',
    Trailer = 'Trailer',
    Movie = 'Movie',
    Episode = 'Episode',
    Song = 'Song',
    MovieExtra = 'MovieExtra',
    TvExtra = 'TvExtra'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * Enum ChannelType.
 * @export
 * @enum {string}
 */
export enum ChannelType {
    TV = 'TV',
    Radio = 'Radio'
}

/**
 * Class ChapterInfo.
 * @export
 * @interface ChapterInfo
 */
export interface ChapterInfo {
    /**
     * Gets or sets the start position ticks.
     * @type {number}
     * @memberof ChapterInfo
     */
    StartPositionTicks?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ChapterInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the image path.
     * @type {string}
     * @memberof ChapterInfo
     */
    ImagePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageDateModified?: string;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageTag?: string | null;
}
/**
 * 
 * @export
 * @interface ClientCapabilities
 */
export interface ClientCapabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCapabilities
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * 
     * @type {Array<GeneralCommandType>}
     * @memberof ClientCapabilities
     */
    SupportedCommands?: Array<GeneralCommandType> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsContentUploading?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    MessageCallbackUrl?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsPersistentIdentifier?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsSync?: boolean;
    /**
     * 
     * @type {DeviceProfile}
     * @memberof ClientCapabilities
     */
    DeviceProfile?: DeviceProfile;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    AppStoreUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface CodecProfile
 */
export interface CodecProfile {
    /**
     * 
     * @type {CodecType}
     * @memberof CodecProfile
     */
    Type?: CodecType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    ApplyConditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Codec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CodecType {
    Video = 'Video',
    VideoAudio = 'VideoAudio',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface CollectionCreationResult
 */
export interface CollectionCreationResult {
    /**
     * 
     * @type {string}
     * @memberof CollectionCreationResult
     */
    Id?: string;
}
/**
 * The configuration page info.
 * @export
 * @interface ConfigurationPageInfo
 */
export interface ConfigurationPageInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether the configurations page is enabled in the main menu.
     * @type {boolean}
     * @memberof ConfigurationPageInfo
     */
    EnableInMainMenu?: boolean;
    /**
     * Gets or sets the menu section.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuSection?: string | null;
    /**
     * Gets or sets the menu icon.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuIcon?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    DisplayName?: string | null;
    /**
     * 
     * @type {ConfigurationPageType}
     * @memberof ConfigurationPageInfo
     */
    ConfigurationPageType?: ConfigurationPageType;
    /**
     * Gets or sets the plugin id.
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    PluginId?: string | null;
}
/**
 * Enum ConfigurationPageType.
 * @export
 * @enum {string}
 */
export enum ConfigurationPageType {
    PluginConfiguration = 'PluginConfiguration',
    None = 'None'
}

/**
 * 
 * @export
 * @interface ContainerProfile
 */
export interface ContainerProfile {
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ContainerProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ContainerProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @interface ControlResponse
 */
export interface ControlResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ControlResponse
     */
    Headers?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof ControlResponse
     */
    Xml?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ControlResponse
     */
    IsSuccessful?: boolean;
}
/**
 * Class CountryInfo.
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof CountryInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof CountryInfo
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the name of the two letter ISO region.
     * @type {string}
     * @memberof CountryInfo
     */
    TwoLetterISORegionName?: string | null;
    /**
     * Gets or sets the name of the three letter ISO region.
     * @type {string}
     * @memberof CountryInfo
     */
    ThreeLetterISORegionName?: string | null;
}
/**
 * Create new playlist dto.
 * @export
 * @interface CreatePlaylistDto
 */
export interface CreatePlaylistDto {
    /**
     * Gets or sets the name of the new playlist.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Name?: string | null;
    /**
     * Gets or sets item ids to add to the playlist.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Ids?: string | null;
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    UserId?: string;
    /**
     * Gets or sets the media type.
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    MediaType?: string | null;
}
/**
 * The create user by name request body.
 * @export
 * @interface CreateUserByName
 */
export interface CreateUserByName {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof CreateUserByName
     */
    Name?: string | null;
    /**
     * Gets or sets the password.
     * @type {string}
     * @memberof CreateUserByName
     */
    Password?: string | null;
}
/**
 * Class CultureDto.
 * @export
 * @interface CultureDto
 */
export interface CultureDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof CultureDto
     */
    Name?: string | null;
    /**
     * Gets or sets the display name.
     * @type {string}
     * @memberof CultureDto
     */
    DisplayName?: string | null;
    /**
     * Gets or sets the name of the two letter ISO language.
     * @type {string}
     * @memberof CultureDto
     */
    TwoLetterISOLanguageName?: string | null;
    /**
     * Gets or sets the name of the three letter ISO language.
     * @type {string}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageNames?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DayPattern {
    Daily = 'Daily',
    Weekdays = 'Weekdays',
    Weekends = 'Weekends'
}

/**
 * Default directory browser info.
 * @export
 * @interface DefaultDirectoryBrowserInfoDto
 */
export interface DefaultDirectoryBrowserInfoDto {
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof DefaultDirectoryBrowserInfoDto
     */
    Path?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceIdentification
 */
export interface DeviceIdentification {
    /**
     * Gets or sets the name of the friendly.
     * @type {string}
     * @memberof DeviceIdentification
     */
    FriendlyName?: string | null;
    /**
     * Gets or sets the model number.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelNumber?: string | null;
    /**
     * Gets or sets the serial number.
     * @type {string}
     * @memberof DeviceIdentification
     */
    SerialNumber?: string | null;
    /**
     * Gets or sets the name of the model.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelName?: string | null;
    /**
     * Gets or sets the model description.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelDescription?: string | null;
    /**
     * Gets or sets the model URL.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelUrl?: string | null;
    /**
     * Gets or sets the manufacturer.
     * @type {string}
     * @memberof DeviceIdentification
     */
    Manufacturer?: string | null;
    /**
     * Gets or sets the manufacturer URL.
     * @type {string}
     * @memberof DeviceIdentification
     */
    ManufacturerUrl?: string | null;
    /**
     * Gets or sets the headers.
     * @type {Array<HttpHeaderInfo>}
     * @memberof DeviceIdentification
     */
    Headers?: Array<HttpHeaderInfo> | null;
}
/**
 * 
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof DeviceInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the last name of the user.
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserName?: string | null;
    /**
     * Gets or sets the name of the application.
     * @type {string}
     * @memberof DeviceInfo
     */
    AppName?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof DeviceInfo
     */
    AppVersion?: string | null;
    /**
     * Gets or sets the last user identifier.
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserId?: string;
    /**
     * Gets or sets the date last modified.
     * @type {string}
     * @memberof DeviceInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof DeviceInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceInfoQueryResult
 */
export interface DeviceInfoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<DeviceInfo>}
     * @memberof DeviceInfoQueryResult
     */
    Items?: Array<DeviceInfo> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface DeviceOptions
 */
export interface DeviceOptions {
    /**
     * 
     * @type {string}
     * @memberof DeviceOptions
     */
    CustomName?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceProfile
 */
export interface DeviceProfile {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof DeviceProfile
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Id?: string | null;
    /**
     * 
     * @type {DeviceIdentification}
     * @memberof DeviceProfile
     */
    Identification?: DeviceIdentification;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Manufacturer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ManufacturerUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SerialNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableAlbumArtInDidl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleAlbumArtLimit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleSubtitleLimit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SupportedMediaTypes?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    UserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    AlbumArtPn?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconWidth?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconHeight?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStreamingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MusicStreamingTranscodingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticMusicBitrate?: number | null;
    /**
     * Controls the content of the aggregationFlags element in the urn:schemas-sonycom:av namespace.
     * @type {string}
     * @memberof DeviceProfile
     */
    SonyAggregationFlags?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ProtocolInfo?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    TimelineOffsetSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainVideoItems?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainFolders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableMSMediaReceiverRegistrar?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    IgnoreTranscodeByteRangeRequests?: boolean;
    /**
     * 
     * @type {Array<XmlAttribute>}
     * @memberof DeviceProfile
     */
    XmlRootAttributes?: Array<XmlAttribute> | null;
    /**
     * Gets or sets the direct play profiles.
     * @type {Array<DirectPlayProfile>}
     * @memberof DeviceProfile
     */
    DirectPlayProfiles?: Array<DirectPlayProfile> | null;
    /**
     * Gets or sets the transcoding profiles.
     * @type {Array<TranscodingProfile>}
     * @memberof DeviceProfile
     */
    TranscodingProfiles?: Array<TranscodingProfile> | null;
    /**
     * 
     * @type {Array<ContainerProfile>}
     * @memberof DeviceProfile
     */
    ContainerProfiles?: Array<ContainerProfile> | null;
    /**
     * 
     * @type {Array<CodecProfile>}
     * @memberof DeviceProfile
     */
    CodecProfiles?: Array<CodecProfile> | null;
    /**
     * 
     * @type {Array<ResponseProfile>}
     * @memberof DeviceProfile
     */
    ResponseProfiles?: Array<ResponseProfile> | null;
    /**
     * 
     * @type {Array<SubtitleProfile>}
     * @memberof DeviceProfile
     */
    SubtitleProfiles?: Array<SubtitleProfile> | null;
}
/**
 * Device profile dto.
 * @export
 * @interface DeviceProfileDto
 */
export interface DeviceProfileDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof DeviceProfileDto
     */
    DeviceProfile?: DeviceProfile;
}
/**
 * 
 * @export
 * @interface DeviceProfileInfo
 */
export interface DeviceProfileInfo {
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {DeviceProfileType}
     * @memberof DeviceProfileInfo
     */
    Type?: DeviceProfileType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DeviceProfileType {
    System = 'System',
    User = 'User'
}

/**
 * 
 * @export
 * @interface DirectPlayProfile
 */
export interface DirectPlayProfile {
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof DirectPlayProfile
     */
    Type?: DlnaProfileType;
}
/**
 * Defines the display preferences for any item that supports them (usually Folders).
 * @export
 * @interface DisplayPreferencesDto
 */
export interface DisplayPreferencesDto {
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Id?: string | null;
    /**
     * Gets or sets the type of the view.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    ViewType?: string | null;
    /**
     * Gets or sets the sort by.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    SortBy?: string | null;
    /**
     * Gets or sets the index by.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    IndexBy?: string | null;
    /**
     * Gets or sets a value indicating whether [remember indexing].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberIndexing?: boolean;
    /**
     * Gets or sets the height of the primary image.
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageHeight?: number;
    /**
     * Gets or sets the width of the primary image.
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageWidth?: number;
    /**
     * Gets or sets the custom prefs.
     * @type {{ [key: string]: string; }}
     * @memberof DisplayPreferencesDto
     */
    CustomPrefs?: { [key: string]: string; } | null;
    /**
     * 
     * @type {ScrollDirection}
     * @memberof DisplayPreferencesDto
     */
    ScrollDirection?: ScrollDirection;
    /**
     * Gets or sets a value indicating whether to show backdrops on this item.
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowBackdrop?: boolean;
    /**
     * Gets or sets a value indicating whether [remember sorting].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberSorting?: boolean;
    /**
     * 
     * @type {SortOrder}
     * @memberof DisplayPreferencesDto
     */
    SortOrder?: SortOrder;
    /**
     * Gets or sets a value indicating whether [show sidebar].
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowSidebar?: boolean;
    /**
     * Gets or sets the client.
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Client?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DlnaProfileType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * An enum that represents a day of the week, weekdays, weekends, or all days.
 * @export
 * @enum {string}
 */
export enum DynamicDayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday',
    Everyday = 'Everyday',
    Weekday = 'Weekday',
    Weekend = 'Weekend'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EncodingContext {
    Streaming = 'Streaming',
    Static = 'Static'
}

/**
 * 
 * @export
 * @interface EndPointInfo
 */
export interface EndPointInfo {
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsLocal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsInNetwork?: boolean;
}
/**
 * Represents the external id information for serialization to the client.
 * @export
 * @interface ExternalIdInfo
 */
export interface ExternalIdInfo {
    /**
     * Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc).
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the unique key for this id. This key should be unique across all providers.
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Key?: string | null;
    /**
     * 
     * @type {ExternalIdMediaType}
     * @memberof ExternalIdInfo
     */
    Type?: ExternalIdMediaType;
    /**
     * Gets or sets the URL format string.
     * @type {string}
     * @memberof ExternalIdInfo
     */
    UrlFormatString?: string | null;
}
/**
 * The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
 * @export
 * @enum {string}
 */
export enum ExternalIdMediaType {
    Album = 'Album',
    AlbumArtist = 'AlbumArtist',
    Artist = 'Artist',
    BoxSet = 'BoxSet',
    Episode = 'Episode',
    Movie = 'Movie',
    OtherArtist = 'OtherArtist',
    Person = 'Person',
    ReleaseGroup = 'ReleaseGroup',
    Season = 'Season',
    Series = 'Series',
    Track = 'Track'
}

/**
 * 
 * @export
 * @interface ExternalUrl
 */
export interface ExternalUrl {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ExternalUrl
     */
    Name?: string | null;
    /**
     * Gets or sets the type of the item.
     * @type {string}
     * @memberof ExternalUrl
     */
    Url?: string | null;
}
/**
 * Enum describing the location of the FFmpeg tool.
 * @export
 * @enum {string}
 */
export enum FFmpegLocation {
    NotFound = 'NotFound',
    SetByArgument = 'SetByArgument',
    Custom = 'Custom',
    System = 'System'
}

/**
 * Class FileSystemEntryInfo.
 * @export
 * @interface FileSystemEntryInfo
 */
export interface FileSystemEntryInfo {
    /**
     * Gets the name.
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Name?: string | null;
    /**
     * Gets the path.
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {FileSystemEntryType}
     * @memberof FileSystemEntryInfo
     */
    Type?: FileSystemEntryType;
}
/**
 * Enum FileSystemEntryType.
 * @export
 * @enum {string}
 */
export enum FileSystemEntryType {
    File = 'File',
    Directory = 'Directory',
    NetworkComputer = 'NetworkComputer',
    NetworkShare = 'NetworkShare'
}

/**
 * Class FontFile.
 * @export
 * @interface FontFile
 */
export interface FontFile {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof FontFile
     */
    Name?: string | null;
    /**
     * Gets or sets the size.
     * @type {number}
     * @memberof FontFile
     */
    Size?: number;
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof FontFile
     */
    DateCreated?: string;
    /**
     * Gets or sets the date modified.
     * @type {string}
     * @memberof FontFile
     */
    DateModified?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ForgotPasswordAction {
    ContactAdmin = 'ContactAdmin',
    PinCode = 'PinCode',
    InNetworkRequired = 'InNetworkRequired'
}

/**
 * Forgot Password request body DTO.
 * @export
 * @interface ForgotPasswordDto
 */
export interface ForgotPasswordDto {
    /**
     * Gets or sets the entered username to have its password reset.
     * @type {string}
     * @memberof ForgotPasswordDto
     */
    EnteredUsername: string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordResult
 */
export interface ForgotPasswordResult {
    /**
     * 
     * @type {ForgotPasswordAction}
     * @memberof ForgotPasswordResult
     */
    Action?: ForgotPasswordAction;
    /**
     * Gets or sets the pin file.
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinFile?: string | null;
    /**
     * Gets or sets the pin expiration date.
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinExpirationDate?: string | null;
}
/**
 * 
 * @export
 * @interface GeneralCommand
 */
export interface GeneralCommand {
    /**
     * 
     * @type {GeneralCommandType}
     * @memberof GeneralCommand
     */
    Name?: GeneralCommandType;
    /**
     * 
     * @type {string}
     * @memberof GeneralCommand
     */
    ControllingUserId?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GeneralCommand
     */
    Arguments?: { [key: string]: string; } | null;
}
/**
 * This exists simply to identify a set of known commands.
 * @export
 * @enum {string}
 */
export enum GeneralCommandType {
    MoveUp = 'MoveUp',
    MoveDown = 'MoveDown',
    MoveLeft = 'MoveLeft',
    MoveRight = 'MoveRight',
    PageUp = 'PageUp',
    PageDown = 'PageDown',
    PreviousLetter = 'PreviousLetter',
    NextLetter = 'NextLetter',
    ToggleOsd = 'ToggleOsd',
    ToggleContextMenu = 'ToggleContextMenu',
    Select = 'Select',
    Back = 'Back',
    TakeScreenshot = 'TakeScreenshot',
    SendKey = 'SendKey',
    SendString = 'SendString',
    GoHome = 'GoHome',
    GoToSettings = 'GoToSettings',
    VolumeUp = 'VolumeUp',
    VolumeDown = 'VolumeDown',
    Mute = 'Mute',
    Unmute = 'Unmute',
    ToggleMute = 'ToggleMute',
    SetVolume = 'SetVolume',
    SetAudioStreamIndex = 'SetAudioStreamIndex',
    SetSubtitleStreamIndex = 'SetSubtitleStreamIndex',
    ToggleFullscreen = 'ToggleFullscreen',
    DisplayContent = 'DisplayContent',
    GoToSearch = 'GoToSearch',
    DisplayMessage = 'DisplayMessage',
    SetRepeatMode = 'SetRepeatMode',
    ChannelUp = 'ChannelUp',
    ChannelDown = 'ChannelDown',
    Guide = 'Guide',
    ToggleStats = 'ToggleStats',
    PlayMediaSource = 'PlayMediaSource',
    PlayTrailers = 'PlayTrailers',
    SetShuffleQueue = 'SetShuffleQueue',
    PlayState = 'PlayState',
    PlayNext = 'PlayNext',
    ToggleOsdMenu = 'ToggleOsdMenu',
    Play = 'Play'
}

/**
 * Get programs dto.
 * @export
 * @interface GetProgramsDto
 */
export interface GetProgramsDto {
    /**
     * Gets or sets the channels to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    ChannelIds?: string | null;
    /**
     * Gets or sets optional. Filter by user id.
     * @type {string}
     * @memberof GetProgramsDto
     */
    UserId?: string;
    /**
     * Gets or sets the minimum premiere start date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinStartDate?: string | null;
    /**
     * Gets or sets filter by programs that have completed airing, or not.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    HasAired?: boolean | null;
    /**
     * Gets or sets filter by programs that are currently airing, or not.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsAiring?: boolean | null;
    /**
     * Gets or sets the maximum premiere start date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxStartDate?: string | null;
    /**
     * Gets or sets the minimum premiere end date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinEndDate?: string | null;
    /**
     * Gets or sets the maximum premiere end date.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxEndDate?: string | null;
    /**
     * Gets or sets filter for movies.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsMovie?: boolean | null;
    /**
     * Gets or sets filter for series.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSeries?: boolean | null;
    /**
     * Gets or sets filter for news.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsNews?: boolean | null;
    /**
     * Gets or sets filter for kids.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsKids?: boolean | null;
    /**
     * Gets or sets filter for sports.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSports?: boolean | null;
    /**
     * Gets or sets the record index to start at. All items with a lower index will be dropped from the results.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    StartIndex?: number | null;
    /**
     * Gets or sets the maximum number of records to return.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    Limit?: number | null;
    /**
     * Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortBy?: string | null;
    /**
     * Gets or sets sort Order - Ascending,Descending.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortOrder?: string | null;
    /**
     * Gets or sets the genres to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    Genres?: string | null;
    /**
     * Gets or sets the genre ids to return guide information for.
     * @type {string}
     * @memberof GetProgramsDto
     */
    GenreIds?: string | null;
    /**
     * Gets or sets include image information in output.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableImages?: boolean | null;
    /**
     * Gets or sets a value indicating whether retrieve total record count.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableTotalRecordCount?: boolean;
    /**
     * Gets or sets the max number of images to return, per image type.  Optional.
     * @type {number}
     * @memberof GetProgramsDto
     */
    ImageTypeLimit?: number | null;
    /**
     * Gets or sets the image types to include in the output.  Optional.
     * @type {Array<ImageType>}
     * @memberof GetProgramsDto
     */
    EnableImageTypes?: Array<ImageType> | null;
    /**
     * Gets or sets include user data.  Optional.
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableUserData?: boolean | null;
    /**
     * Gets or sets filter by series timer id.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets filter by library series id.  Optional.
     * @type {string}
     * @memberof GetProgramsDto
     */
    LibrarySeriesId?: string;
    /**
     * Gets or sets specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.  Optional.
     * @type {Array<ItemFields>}
     * @memberof GetProgramsDto
     */
    Fields?: Array<ItemFields> | null;
}
/**
 * Class GroupInfoView.
 * @export
 * @interface GroupInfoView
 */
export interface GroupInfoView {
    /**
     * Gets or sets the group identifier.
     * @type {string}
     * @memberof GroupInfoView
     */
    GroupId?: string | null;
    /**
     * Gets or sets the playing item id.
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemId?: string | null;
    /**
     * Gets or sets the playing item name.
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemName?: string | null;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof GroupInfoView
     */
    PositionTicks?: number;
    /**
     * Gets or sets the participants.
     * @type {Array<string>}
     * @memberof GroupInfoView
     */
    Participants?: Array<string> | null;
}
/**
 * Enum GroupUpdateType.
 * @export
 * @enum {string}
 */
export enum GroupUpdateType {
    UserJoined = 'UserJoined',
    UserLeft = 'UserLeft',
    GroupJoined = 'GroupJoined',
    GroupLeft = 'GroupLeft',
    GroupWait = 'GroupWait',
    PrepareSession = 'PrepareSession',
    NotInGroup = 'NotInGroup',
    GroupDoesNotExist = 'GroupDoesNotExist',
    CreateGroupDenied = 'CreateGroupDenied',
    JoinGroupDenied = 'JoinGroupDenied',
    LibraryAccessDenied = 'LibraryAccessDenied'
}

/**
 * 
 * @export
 * @interface GuideInfo
 */
export interface GuideInfo {
    /**
     * Gets or sets the start date.
     * @type {string}
     * @memberof GuideInfo
     */
    StartDate?: string;
    /**
     * Gets or sets the end date.
     * @type {string}
     * @memberof GuideInfo
     */
    EndDate?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HeaderMatchType {
    Equals = 'Equals',
    Regex = 'Regex',
    Substring = 'Substring'
}

/**
 * 
 * @export
 * @interface HttpHeaderInfo
 */
export interface HttpHeaderInfo {
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Value?: string | null;
    /**
     * 
     * @type {HeaderMatchType}
     * @memberof HttpHeaderInfo
     */
    Match?: HeaderMatchType;
}
/**
 * Interface IPlugin.
 * @export
 * @interface IPlugin
 */
export interface IPlugin {
    /**
     * Gets the name of the plugin.
     * @type {string}
     * @memberof IPlugin
     */
    Name?: string | null;
    /**
     * Gets the description.
     * @type {string}
     * @memberof IPlugin
     */
    Description?: string | null;
    /**
     * Gets the unique id.
     * @type {string}
     * @memberof IPlugin
     */
    Id?: string;
    /**
     * 
     * @type {Version}
     * @memberof IPlugin
     */
    Version?: Version;
    /**
     * Gets the path to the assembly file.
     * @type {string}
     * @memberof IPlugin
     */
    AssemblyFilePath?: string | null;
    /**
     * Gets a value indicating whether the plugin can be uninstalled.
     * @type {boolean}
     * @memberof IPlugin
     */
    CanUninstall?: boolean;
    /**
     * Gets the full path to the data folder, where the plugin can store any miscellaneous files needed.
     * @type {string}
     * @memberof IPlugin
     */
    DataFolderPath?: string | null;
}
/**
 * 
 * @export
 * @interface ImageByNameInfo
 */
export interface ImageByNameInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the theme.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Theme?: string | null;
    /**
     * Gets or sets the context.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Context?: string | null;
    /**
     * Gets or sets the length of the file.
     * @type {number}
     * @memberof ImageByNameInfo
     */
    FileLength?: number;
    /**
     * Gets or sets the format.
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Format?: string | null;
}
/**
 * Enum ImageOutputFormat.
 * @export
 * @enum {string}
 */
export enum ImageFormat {
    Bmp = 'Bmp',
    Gif = 'Gif',
    Jpg = 'Jpg',
    Png = 'Png',
    Webp = 'Webp'
}

/**
 * Class ImageInfo.
 * @export
 * @interface ImageInfo
 */
export interface ImageInfo {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageInfo
     */
    ImageType?: ImageType;
    /**
     * Gets or sets the index of the image.
     * @type {number}
     * @memberof ImageInfo
     */
    ImageIndex?: number | null;
    /**
     * Gets or sets the image tag.
     * @type {string}
     * @memberof ImageInfo
     */
    ImageTag?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ImageInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the blurhash.
     * @type {string}
     * @memberof ImageInfo
     */
    BlurHash?: string | null;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof ImageInfo
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof ImageInfo
     */
    Width?: number | null;
    /**
     * Gets or sets the size.
     * @type {number}
     * @memberof ImageInfo
     */
    Size?: number;
}
/**
 * 
 * @export
 * @interface ImageOption
 */
export interface ImageOption {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageOption
     */
    Type?: ImageType;
    /**
     * Gets or sets the limit.
     * @type {number}
     * @memberof ImageOption
     */
    Limit?: number;
    /**
     * Gets or sets the minimum width.
     * @type {number}
     * @memberof ImageOption
     */
    MinWidth?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageOrientation {
    TopLeft = 'TopLeft',
    TopRight = 'TopRight',
    BottomRight = 'BottomRight',
    BottomLeft = 'BottomLeft',
    LeftTop = 'LeftTop',
    RightTop = 'RightTop',
    RightBottom = 'RightBottom',
    LeftBottom = 'LeftBottom'
}

/**
 * Class ImageProviderInfo.
 * @export
 * @interface ImageProviderInfo
 */
export interface ImageProviderInfo {
    /**
     * Gets the name.
     * @type {string}
     * @memberof ImageProviderInfo
     */
    Name?: string | null;
    /**
     * Gets the supported image types.
     * @type {Array<ImageType>}
     * @memberof ImageProviderInfo
     */
    SupportedImages?: Array<ImageType> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageSavingConvention {
    Legacy = 'Legacy',
    Compatible = 'Compatible'
}

/**
 * Enum ImageType.
 * @export
 * @enum {string}
 */
export enum ImageType {
    Primary = 'Primary',
    Art = 'Art',
    Backdrop = 'Backdrop',
    Banner = 'Banner',
    Logo = 'Logo',
    Thumb = 'Thumb',
    Disc = 'Disc',
    Box = 'Box',
    Screenshot = 'Screenshot',
    Menu = 'Menu',
    Chapter = 'Chapter',
    BoxRear = 'BoxRear',
    Profile = 'Profile'
}

/**
 * Class InstallationInfo.
 * @export
 * @interface InstallationInfo
 */
export interface InstallationInfo {
    /**
     * Gets or sets the guid.
     * @type {string}
     * @memberof InstallationInfo
     */
    Guid?: string;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof InstallationInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof InstallationInfo
     */
    Version?: Version;
    /**
     * Gets or sets the changelog for this version.
     * @type {string}
     * @memberof InstallationInfo
     */
    Changelog?: string | null;
    /**
     * Gets or sets the source URL.
     * @type {string}
     * @memberof InstallationInfo
     */
    SourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     * @type {string}
     * @memberof InstallationInfo
     */
    Checksum?: string | null;
}
/**
 * Enum IsoType.
 * @export
 * @enum {string}
 */
export enum IsoType {
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * Class LibrarySummary.
 * @export
 * @interface ItemCounts
 */
export interface ItemCounts {
    /**
     * Gets or sets the movie count.
     * @type {number}
     * @memberof ItemCounts
     */
    MovieCount?: number;
    /**
     * Gets or sets the series count.
     * @type {number}
     * @memberof ItemCounts
     */
    SeriesCount?: number;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof ItemCounts
     */
    EpisodeCount?: number;
    /**
     * Gets or sets the artist count.
     * @type {number}
     * @memberof ItemCounts
     */
    ArtistCount?: number;
    /**
     * Gets or sets the program count.
     * @type {number}
     * @memberof ItemCounts
     */
    ProgramCount?: number;
    /**
     * Gets or sets the trailer count.
     * @type {number}
     * @memberof ItemCounts
     */
    TrailerCount?: number;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof ItemCounts
     */
    SongCount?: number;
    /**
     * Gets or sets the album count.
     * @type {number}
     * @memberof ItemCounts
     */
    AlbumCount?: number;
    /**
     * Gets or sets the music video count.
     * @type {number}
     * @memberof ItemCounts
     */
    MusicVideoCount?: number;
    /**
     * Gets or sets the box set count.
     * @type {number}
     * @memberof ItemCounts
     */
    BoxSetCount?: number;
    /**
     * Gets or sets the book count.
     * @type {number}
     * @memberof ItemCounts
     */
    BookCount?: number;
    /**
     * Gets or sets the item count.
     * @type {number}
     * @memberof ItemCounts
     */
    ItemCount?: number;
}
/**
 * Used to control the data that gets attached to DtoBaseItems.
 * @export
 * @enum {string}
 */
export enum ItemFields {
    AirTime = 'AirTime',
    CanDelete = 'CanDelete',
    CanDownload = 'CanDownload',
    ChannelInfo = 'ChannelInfo',
    Chapters = 'Chapters',
    ChildCount = 'ChildCount',
    CumulativeRunTimeTicks = 'CumulativeRunTimeTicks',
    CustomRating = 'CustomRating',
    DateCreated = 'DateCreated',
    DateLastMediaAdded = 'DateLastMediaAdded',
    DisplayPreferencesId = 'DisplayPreferencesId',
    Etag = 'Etag',
    ExternalUrls = 'ExternalUrls',
    Genres = 'Genres',
    HomePageUrl = 'HomePageUrl',
    ItemCounts = 'ItemCounts',
    MediaSourceCount = 'MediaSourceCount',
    MediaSources = 'MediaSources',
    OriginalTitle = 'OriginalTitle',
    Overview = 'Overview',
    ParentId = 'ParentId',
    Path = 'Path',
    People = 'People',
    PlayAccess = 'PlayAccess',
    ProductionLocations = 'ProductionLocations',
    ProviderIds = 'ProviderIds',
    PrimaryImageAspectRatio = 'PrimaryImageAspectRatio',
    RecursiveItemCount = 'RecursiveItemCount',
    Settings = 'Settings',
    ScreenshotImageTags = 'ScreenshotImageTags',
    SeriesPrimaryImage = 'SeriesPrimaryImage',
    SeriesStudio = 'SeriesStudio',
    SortName = 'SortName',
    SpecialEpisodeNumbers = 'SpecialEpisodeNumbers',
    Studios = 'Studios',
    BasicSyncInfo = 'BasicSyncInfo',
    SyncInfo = 'SyncInfo',
    Taglines = 'Taglines',
    Tags = 'Tags',
    RemoteTrailers = 'RemoteTrailers',
    MediaStreams = 'MediaStreams',
    SeasonUserData = 'SeasonUserData',
    ServiceName = 'ServiceName',
    ThemeSongIds = 'ThemeSongIds',
    ThemeVideoIds = 'ThemeVideoIds',
    ExternalEtag = 'ExternalEtag',
    PresentationUniqueKey = 'PresentationUniqueKey',
    InheritedParentalRatingValue = 'InheritedParentalRatingValue',
    ExternalSeriesId = 'ExternalSeriesId',
    SeriesPresentationUniqueKey = 'SeriesPresentationUniqueKey',
    DateLastRefreshed = 'DateLastRefreshed',
    DateLastSaved = 'DateLastSaved',
    RefreshState = 'RefreshState',
    ChannelImage = 'ChannelImage',
    EnableMediaSourceDisplay = 'EnableMediaSourceDisplay',
    Width = 'Width',
    Height = 'Height',
    ExtraIds = 'ExtraIds',
    LocalTrailerCount = 'LocalTrailerCount',
    IsHD = 'IsHD',
    SpecialFeatureCount = 'SpecialFeatureCount'
}

/**
 * Enum ItemFilter.
 * @export
 * @enum {string}
 */
export enum ItemFilter {
    IsFolder = 'IsFolder',
    IsNotFolder = 'IsNotFolder',
    IsUnplayed = 'IsUnplayed',
    IsPlayed = 'IsPlayed',
    IsFavorite = 'IsFavorite',
    IsResumable = 'IsResumable',
    Likes = 'Likes',
    Dislikes = 'Dislikes',
    IsFavoriteOrLikes = 'IsFavoriteOrLikes'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum KeepUntil {
    UntilDeleted = 'UntilDeleted',
    UntilSpaceNeeded = 'UntilSpaceNeeded',
    UntilWatched = 'UntilWatched',
    UntilDate = 'UntilDate'
}

/**
 * Library option info dto.
 * @export
 * @interface LibraryOptionInfoDto
 */
export interface LibraryOptionInfoDto {
    /**
     * Gets or sets name.
     * @type {string}
     * @memberof LibraryOptionInfoDto
     */
    Name?: string | null;
    /**
     * Gets or sets a value indicating whether default enabled.
     * @type {boolean}
     * @memberof LibraryOptionInfoDto
     */
    DefaultEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface LibraryOptions
 */
export interface LibraryOptions {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnablePhotos?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableRealtimeMonitor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableChapterImageExtraction?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    ExtractChapterImagesDuringLibraryScan?: boolean;
    /**
     * 
     * @type {Array<MediaPathInfo>}
     * @memberof LibraryOptions
     */
    PathInfos?: Array<MediaPathInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveLocalMetadata?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableInternetProviders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableAutomaticSeriesGrouping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedTitles?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedEpisodeInfos?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LibraryOptions
     */
    AutomaticRefreshIntervalDays?: number;
    /**
     * Gets or sets the preferred metadata language.
     * @type {string}
     * @memberof LibraryOptions
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof LibraryOptions
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LibraryOptions
     */
    SeasonZeroDisplayName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    MetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledLocalMetadataReaders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledSubtitleFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleDownloadLanguages?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    RequirePerfectSubtitleMatch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveSubtitlesWithMedia?: boolean;
    /**
     * 
     * @type {Array<TypeOptions>}
     * @memberof LibraryOptions
     */
    TypeOptions?: Array<TypeOptions> | null;
}
/**
 * Library options result dto.
 * @export
 * @interface LibraryOptionsResultDto
 */
export interface LibraryOptionsResultDto {
    /**
     * Gets or sets the metadata savers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataSavers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the metadata readers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataReaders?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the subtitle fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    SubtitleFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the type options.
     * @type {Array<LibraryTypeOptionsDto>}
     * @memberof LibraryOptionsResultDto
     */
    TypeOptions?: Array<LibraryTypeOptionsDto> | null;
}
/**
 * Library type options dto.
 * @export
 * @interface LibraryTypeOptionsDto
 */
export interface LibraryTypeOptionsDto {
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof LibraryTypeOptionsDto
     */
    Type?: string | null;
    /**
     * Gets or sets the metadata fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    MetadataFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the image fetchers.
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    ImageFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * Gets or sets the supported image types.
     * @type {Array<ImageType>}
     * @memberof LibraryTypeOptionsDto
     */
    SupportedImageTypes?: Array<ImageType> | null;
    /**
     * Gets or sets the default image options.
     * @type {Array<ImageOption>}
     * @memberof LibraryTypeOptionsDto
     */
    DefaultImageOptions?: Array<ImageOption> | null;
}
/**
 * Class LibraryUpdateInfo.
 * @export
 * @interface LibraryUpdateInfo
 */
export interface LibraryUpdateInfo {
    /**
     * Gets or sets the folders added to.
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    FoldersAddedTo?: Array<string> | null;
    /**
     * Gets or sets the folders removed from.
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    FoldersRemovedFrom?: Array<string> | null;
    /**
     * Gets or sets the items added.
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    ItemsAdded?: Array<string> | null;
    /**
     * Gets or sets the items removed.
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    ItemsRemoved?: Array<string> | null;
    /**
     * Gets or sets the items updated.
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    ItemsUpdated?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryUpdateInfo
     */
    CollectionFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryUpdateInfo
     */
    IsEmpty?: boolean;
}
/**
 * 
 * @export
 * @interface ListingsProviderInfo
 */
export interface ListingsProviderInfo {
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ListingsId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ZipCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    EnabledTuners?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListingsProviderInfo
     */
    EnableAllTuners?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    NewsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    SportsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    KidsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    MovieCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ListingsProviderInfo
     */
    ChannelMappings?: Array<NameValuePair> | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    MoviePrefix?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    PreferredLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface LiveStreamResponse
 */
export interface LiveStreamResponse {
    /**
     * 
     * @type {MediaSourceInfo}
     * @memberof LiveStreamResponse
     */
    MediaSource?: MediaSourceInfo;
}
/**
 * 
 * @export
 * @interface LiveTvInfo
 */
export interface LiveTvInfo {
    /**
     * Gets or sets the services.
     * @type {Array<LiveTvServiceInfo>}
     * @memberof LiveTvInfo
     */
    Services?: Array<LiveTvServiceInfo> | null;
    /**
     * Gets or sets a value indicating whether this instance is enabled.
     * @type {boolean}
     * @memberof LiveTvInfo
     */
    IsEnabled?: boolean;
    /**
     * Gets or sets the enabled users.
     * @type {Array<string>}
     * @memberof LiveTvInfo
     */
    EnabledUsers?: Array<string> | null;
}
/**
 * Class ServiceInfo.
 * @export
 * @interface LiveTvServiceInfo
 */
export interface LiveTvServiceInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the home page URL.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    HomePageUrl?: string | null;
    /**
     * 
     * @type {LiveTvServiceStatus}
     * @memberof LiveTvServiceInfo
     */
    Status?: LiveTvServiceStatus;
    /**
     * Gets or sets the status message.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    StatusMessage?: string | null;
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Version?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is visible.
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    IsVisible?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiveTvServiceInfo
     */
    Tuners?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LiveTvServiceStatus {
    Ok = 'Ok',
    Unavailable = 'Unavailable'
}

/**
 * 
 * @export
 * @interface LocalizationOption
 */
export interface LocalizationOption {
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Value?: string | null;
}
/**
 * Enum LocationType.
 * @export
 * @enum {string}
 */
export enum LocationType {
    FileSystem = 'FileSystem',
    Remote = 'Remote',
    Virtual = 'Virtual',
    Offline = 'Offline'
}

/**
 * 
 * @export
 * @interface LogFile
 */
export interface LogFile {
    /**
     * Gets or sets the date created.
     * @type {string}
     * @memberof LogFile
     */
    DateCreated?: string;
    /**
     * Gets or sets the date modified.
     * @type {string}
     * @memberof LogFile
     */
    DateModified?: string;
    /**
     * Gets or sets the size.
     * @type {number}
     * @memberof LogFile
     */
    Size?: number;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof LogFile
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LogLevel {
    Trace = 'Trace',
    Debug = 'Debug',
    Information = 'Information',
    Warning = 'Warning',
    Error = 'Error',
    Critical = 'Critical',
    None = 'None'
}

/**
 * MB Registration Record.
 * @export
 * @interface MBRegistrationRecord
 */
export interface MBRegistrationRecord {
    /**
     * Gets or sets expiration date.
     * @type {string}
     * @memberof MBRegistrationRecord
     */
    ExpirationDate?: string;
    /**
     * Gets or sets a value indicating whether is registered.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsRegistered?: boolean;
    /**
     * Gets or sets a value indicating whether reg checked.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegChecked?: boolean;
    /**
     * Gets or sets a value indicating whether reg error.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegError?: boolean;
    /**
     * Gets or sets a value indicating whether trial version.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    TrialVersion?: boolean;
    /**
     * Gets or sets a value indicating whether is valid.
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsValid?: boolean;
}
/**
 * Class MediaAttachment.
 * @export
 * @interface MediaAttachment
 */
export interface MediaAttachment {
    /**
     * Gets or sets the codec.
     * @type {string}
     * @memberof MediaAttachment
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     * @type {string}
     * @memberof MediaAttachment
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the comment.
     * @type {string}
     * @memberof MediaAttachment
     */
    Comment?: string | null;
    /**
     * Gets or sets the index.
     * @type {number}
     * @memberof MediaAttachment
     */
    Index?: number;
    /**
     * Gets or sets the filename.
     * @type {string}
     * @memberof MediaAttachment
     */
    FileName?: string | null;
    /**
     * Gets or sets the MIME type.
     * @type {string}
     * @memberof MediaAttachment
     */
    MimeType?: string | null;
    /**
     * Gets or sets the delivery URL.
     * @type {string}
     * @memberof MediaAttachment
     */
    DeliveryUrl?: string | null;
}
/**
 * Media Encoder Path Dto.
 * @export
 * @interface MediaEncoderPathDto
 */
export interface MediaEncoderPathDto {
    /**
     * Gets or sets media encoder path.
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    Path?: string | null;
    /**
     * Gets or sets media encoder path type.
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    PathType?: string | null;
}
/**
 * Media Path dto.
 * @export
 * @interface MediaPathDto
 */
export interface MediaPathDto {
    /**
     * Gets or sets the name of the library.
     * @type {string}
     * @memberof MediaPathDto
     */
    Name: string;
    /**
     * Gets or sets the path to add.
     * @type {string}
     * @memberof MediaPathDto
     */
    Path?: string | null;
    /**
     * 
     * @type {MediaPathInfo}
     * @memberof MediaPathDto
     */
    PathInfo?: MediaPathInfo;
}
/**
 * 
 * @export
 * @interface MediaPathInfo
 */
export interface MediaPathInfo {
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    NetworkPath?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaProtocol {
    File = 'File',
    Http = 'Http',
    Rtmp = 'Rtmp',
    Rtsp = 'Rtsp',
    Udp = 'Udp',
    Rtp = 'Rtp',
    Ftp = 'Ftp'
}

/**
 * 
 * @export
 * @interface MediaSourceInfo
 */
export interface MediaSourceInfo {
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    Protocol?: MediaProtocol;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    EncoderPath?: string | null;
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    EncoderProtocol?: MediaProtocol;
    /**
     * 
     * @type {MediaSourceType}
     * @memberof MediaSourceInfo
     */
    Type?: MediaSourceType;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Name?: string | null;
    /**
     * Differentiate internet url vs local network.
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsRemote?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    ETag?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    ReadAtNativeFramerate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreDts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreIndex?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    GenPtsInput?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectPlay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsInfiniteStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresOpening?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    OpenToken?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresClosing?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    BufferMs?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresLooping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsProbing?: boolean;
    /**
     * 
     * @type {VideoType}
     * @memberof MediaSourceInfo
     */
    VideoType?: VideoType;
    /**
     * 
     * @type {IsoType}
     * @memberof MediaSourceInfo
     */
    IsoType?: IsoType;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof MediaSourceInfo
     */
    Video3DFormat?: Video3DFormat;
    /**
     * 
     * @type {Array<MediaStream>}
     * @memberof MediaSourceInfo
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof MediaSourceInfo
     */
    MediaAttachments?: Array<MediaAttachment> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaSourceInfo
     */
    Formats?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {TransportStreamTimestamp}
     * @memberof MediaSourceInfo
     */
    Timestamp?: TransportStreamTimestamp;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MediaSourceInfo
     */
    RequiredHttpHeaders?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingSubProtocol?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingContainer?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    AnalyzeDurationMs?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultAudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultSubtitleStreamIndex?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaSourceType {
    Default = 'Default',
    Grouping = 'Grouping',
    Placeholder = 'Placeholder'
}

/**
 * Class MediaStream.
 * @export
 * @interface MediaStream
 */
export interface MediaStream {
    /**
     * Gets or sets the codec.
     * @type {string}
     * @memberof MediaStream
     */
    Codec?: string | null;
    /**
     * Gets or sets the codec tag.
     * @type {string}
     * @memberof MediaStream
     */
    CodecTag?: string | null;
    /**
     * Gets or sets the language.
     * @type {string}
     * @memberof MediaStream
     */
    Language?: string | null;
    /**
     * Gets or sets the color range.
     * @type {string}
     * @memberof MediaStream
     */
    ColorRange?: string | null;
    /**
     * Gets or sets the color space.
     * @type {string}
     * @memberof MediaStream
     */
    ColorSpace?: string | null;
    /**
     * Gets or sets the color transfer.
     * @type {string}
     * @memberof MediaStream
     */
    ColorTransfer?: string | null;
    /**
     * Gets or sets the color primaries.
     * @type {string}
     * @memberof MediaStream
     */
    ColorPrimaries?: string | null;
    /**
     * Gets or sets the comment.
     * @type {string}
     * @memberof MediaStream
     */
    Comment?: string | null;
    /**
     * Gets or sets the time base.
     * @type {string}
     * @memberof MediaStream
     */
    TimeBase?: string | null;
    /**
     * Gets or sets the codec time base.
     * @type {string}
     * @memberof MediaStream
     */
    CodecTimeBase?: string | null;
    /**
     * Gets or sets the title.
     * @type {string}
     * @memberof MediaStream
     */
    Title?: string | null;
    /**
     * Gets or sets the video range.
     * @type {string}
     * @memberof MediaStream
     */
    VideoRange?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedUndefined?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedDefault?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedForced?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    DisplayTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    NalLengthSize?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is interlaced.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsInterlaced?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAVC?: boolean | null;
    /**
     * Gets or sets the channel layout.
     * @type {string}
     * @memberof MediaStream
     */
    ChannelLayout?: string | null;
    /**
     * Gets or sets the bit rate.
     * @type {number}
     * @memberof MediaStream
     */
    BitRate?: number | null;
    /**
     * Gets or sets the bit depth.
     * @type {number}
     * @memberof MediaStream
     */
    BitDepth?: number | null;
    /**
     * Gets or sets the reference frames.
     * @type {number}
     * @memberof MediaStream
     */
    RefFrames?: number | null;
    /**
     * Gets or sets the length of the packet.
     * @type {number}
     * @memberof MediaStream
     */
    PacketLength?: number | null;
    /**
     * Gets or sets the channels.
     * @type {number}
     * @memberof MediaStream
     */
    Channels?: number | null;
    /**
     * Gets or sets the sample rate.
     * @type {number}
     * @memberof MediaStream
     */
    SampleRate?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is default.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsDefault?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is forced.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsForced?: boolean;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof MediaStream
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof MediaStream
     */
    Width?: number | null;
    /**
     * Gets or sets the average frame rate.
     * @type {number}
     * @memberof MediaStream
     */
    AverageFrameRate?: number | null;
    /**
     * Gets or sets the real frame rate.
     * @type {number}
     * @memberof MediaStream
     */
    RealFrameRate?: number | null;
    /**
     * Gets or sets the profile.
     * @type {string}
     * @memberof MediaStream
     */
    Profile?: string | null;
    /**
     * 
     * @type {MediaStreamType}
     * @memberof MediaStream
     */
    Type?: MediaStreamType;
    /**
     * Gets or sets the aspect ratio.
     * @type {string}
     * @memberof MediaStream
     */
    AspectRatio?: string | null;
    /**
     * Gets or sets the index.
     * @type {number}
     * @memberof MediaStream
     */
    Index?: number;
    /**
     * Gets or sets the score.
     * @type {number}
     * @memberof MediaStream
     */
    Score?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is external.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternal?: boolean;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof MediaStream
     */
    DeliveryMethod?: SubtitleDeliveryMethod;
    /**
     * Gets or sets the delivery URL.
     * @type {string}
     * @memberof MediaStream
     */
    DeliveryUrl?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is external URL.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternalUrl?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsTextSubtitleStream?: boolean;
    /**
     * Gets or sets a value indicating whether [supports external stream].
     * @type {boolean}
     * @memberof MediaStream
     */
    SupportsExternalStream?: boolean;
    /**
     * Gets or sets the filename.
     * @type {string}
     * @memberof MediaStream
     */
    Path?: string | null;
    /**
     * Gets or sets the pixel format.
     * @type {string}
     * @memberof MediaStream
     */
    PixelFormat?: string | null;
    /**
     * Gets or sets the level.
     * @type {number}
     * @memberof MediaStream
     */
    Level?: number | null;
    /**
     * Gets a value indicating whether this instance is anamorphic.
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAnamorphic?: boolean | null;
}
/**
 * Enum MediaStreamType.
 * @export
 * @enum {string}
 */
export enum MediaStreamType {
    Audio = 'Audio',
    Video = 'Video',
    Subtitle = 'Subtitle',
    EmbeddedImage = 'EmbeddedImage'
}

/**
 * Media Update Info Dto.
 * @export
 * @interface MediaUpdateInfoDto
 */
export interface MediaUpdateInfoDto {
    /**
     * Gets or sets media path.
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    Path?: string | null;
    /**
     * Gets or sets media update type.  Created, Modified, Deleted.
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    UpdateType?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUrl
 */
export interface MediaUrl {
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataEditorInfo
 */
export interface MetadataEditorInfo {
    /**
     * 
     * @type {Array<ParentalRating>}
     * @memberof MetadataEditorInfo
     */
    ParentalRatingOptions?: Array<ParentalRating> | null;
    /**
     * 
     * @type {Array<CountryInfo>}
     * @memberof MetadataEditorInfo
     */
    Countries?: Array<CountryInfo> | null;
    /**
     * 
     * @type {Array<CultureDto>}
     * @memberof MetadataEditorInfo
     */
    Cultures?: Array<CultureDto> | null;
    /**
     * 
     * @type {Array<ExternalIdInfo>}
     * @memberof MetadataEditorInfo
     */
    ExternalIdInfos?: Array<ExternalIdInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof MetadataEditorInfo
     */
    ContentType?: string | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof MetadataEditorInfo
     */
    ContentTypeOptions?: Array<NameValuePair> | null;
}
/**
 * Enum MetadataFields.
 * @export
 * @enum {string}
 */
export enum MetadataField {
    Cast = 'Cast',
    Genres = 'Genres',
    ProductionLocations = 'ProductionLocations',
    Studios = 'Studios',
    Tags = 'Tags',
    Name = 'Name',
    Overview = 'Overview',
    Runtime = 'Runtime',
    OfficialRating = 'OfficialRating'
}

/**
 * Class MetadataOptions.
 * @export
 * @interface MetadataOptions
 */
export interface MetadataOptions {
    /**
     * 
     * @type {string}
     * @memberof MetadataOptions
     */
    ItemType?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    ImageFetcherOrder?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetadataRefreshMode {
    None = 'None',
    ValidationOnly = 'ValidationOnly',
    Default = 'Default',
    FullRefresh = 'FullRefresh'
}

/**
 * 
 * @export
 * @interface MovieInfo
 */
export interface MovieInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof MovieInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof MovieInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof MovieInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof MovieInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MovieInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface MovieInfoRemoteSearchQuery
 */
export interface MovieInfoRemoteSearchQuery {
    /**
     * 
     * @type {MovieInfo}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchInfo?: MovieInfo;
    /**
     * 
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof MovieInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface MusicVideoInfo
 */
export interface MusicVideoInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof MusicVideoInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof MusicVideoInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicVideoInfo
     */
    IsAutomated?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MusicVideoInfo
     */
    Artists?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface MusicVideoInfoRemoteSearchQuery
 */
export interface MusicVideoInfoRemoteSearchQuery {
    /**
     * 
     * @type {MusicVideoInfo}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchInfo?: MusicVideoInfo;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface NameGuidPair
 */
export interface NameGuidPair {
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Id?: string;
}
/**
 * 
 * @export
 * @interface NameIdPair
 */
export interface NameIdPair {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof NameIdPair
     */
    Name?: string | null;
    /**
     * Gets or sets the identifier.
     * @type {string}
     * @memberof NameIdPair
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface NameValuePair
 */
export interface NameValuePair {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof NameValuePair
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     * @type {string}
     * @memberof NameValuePair
     */
    Value?: string | null;
}
/**
 * The notification DTO.
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * Gets or sets the notification ID. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Id?: string | null;
    /**
     * Gets or sets the notification\'s user ID. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    UserId?: string | null;
    /**
     * Gets or sets the notification date.
     * @type {string}
     * @memberof NotificationDto
     */
    Date?: string;
    /**
     * Gets or sets a value indicating whether the notification has been read. Defaults to false.
     * @type {boolean}
     * @memberof NotificationDto
     */
    IsRead?: boolean;
    /**
     * Gets or sets the notification\'s name. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Name?: string | null;
    /**
     * Gets or sets the notification\'s description. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Description?: string | null;
    /**
     * Gets or sets the notification\'s URL. Defaults to an empty string.
     * @type {string}
     * @memberof NotificationDto
     */
    Url?: string | null;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationDto
     */
    Level?: NotificationLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NotificationLevel {
    Normal = 'Normal',
    Warning = 'Warning',
    Error = 'Error'
}

/**
 * A list of notifications with the total record count for pagination.
 * @export
 * @interface NotificationResultDto
 */
export interface NotificationResultDto {
    /**
     * Gets or sets the current page of notifications.
     * @type {Array<NotificationDto>}
     * @memberof NotificationResultDto
     */
    Notifications?: Array<NotificationDto> | null;
    /**
     * Gets or sets the total number of notifications.
     * @type {number}
     * @memberof NotificationResultDto
     */
    TotalRecordCount?: number;
}
/**
 * 
 * @export
 * @interface NotificationTypeInfo
 */
export interface NotificationTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    Enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Category?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    IsBasedOnUserEvent?: boolean;
}
/**
 * The notification summary DTO.
 * @export
 * @interface NotificationsSummaryDto
 */
export interface NotificationsSummaryDto {
    /**
     * Gets or sets the number of unread notifications.
     * @type {number}
     * @memberof NotificationsSummaryDto
     */
    UnreadCount?: number;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationsSummaryDto
     */
    MaxUnreadNotificationLevel?: NotificationLevel;
}
/**
 * Class GroupUpdate.
 * @export
 * @interface ObjectGroupUpdate
 */
export interface ObjectGroupUpdate {
    /**
     * Gets or sets the group identifier.
     * @type {string}
     * @memberof ObjectGroupUpdate
     */
    GroupId?: string | null;
    /**
     * 
     * @type {GroupUpdateType}
     * @memberof ObjectGroupUpdate
     */
    Type?: GroupUpdateType;
    /**
     * Gets or sets the data.
     * @type {any}
     * @memberof ObjectGroupUpdate
     */
    Data?: any | null;
}
/**
 * Open live stream dto.
 * @export
 * @interface OpenLiveStreamDto
 */
export interface OpenLiveStreamDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof OpenLiveStreamDto
     */
    DeviceProfile?: DeviceProfile;
    /**
     * Gets or sets the device play protocols.
     * @type {Array<MediaProtocol>}
     * @memberof OpenLiveStreamDto
     */
    DirectPlayProtocols?: Array<MediaProtocol> | null;
}
/**
 * Class PackageInfo.
 * @export
 * @interface PackageInfo
 */
export interface PackageInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PackageInfo
     */
    name?: string | null;
    /**
     * Gets or sets a long description of the plugin containing features or helpful explanations.
     * @type {string}
     * @memberof PackageInfo
     */
    description?: string | null;
    /**
     * Gets or sets a short overview of what the plugin does.
     * @type {string}
     * @memberof PackageInfo
     */
    overview?: string | null;
    /**
     * Gets or sets the owner.
     * @type {string}
     * @memberof PackageInfo
     */
    owner?: string | null;
    /**
     * Gets or sets the category.
     * @type {string}
     * @memberof PackageInfo
     */
    category?: string | null;
    /**
     * The guid of the assembly associated with this plugin.  This is used to identify the proper item for automatic updates.
     * @type {string}
     * @memberof PackageInfo
     */
    guid?: string | null;
    /**
     * Gets or sets the versions.
     * @type {Array<VersionInfo>}
     * @memberof PackageInfo
     */
    versions?: Array<VersionInfo> | null;
    /**
     * Gets or sets the repository name.
     * @type {string}
     * @memberof PackageInfo
     */
    repositoryName?: string | null;
    /**
     * Gets or sets the repository url.
     * @type {string}
     * @memberof PackageInfo
     */
    repositoryUrl?: string | null;
}
/**
 * Class ParentalRating.
 * @export
 * @interface ParentalRating
 */
export interface ParentalRating {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof ParentalRating
     */
    Name?: string | null;
    /**
     * Gets or sets the value.
     * @type {number}
     * @memberof ParentalRating
     */
    Value?: number;
}
/**
 * 
 * @export
 * @interface PathSubstitution
 */
export interface PathSubstitution {
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    From?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    To?: string | null;
}
/**
 * 
 * @export
 * @interface PersonLookupInfo
 */
export interface PersonLookupInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof PersonLookupInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof PersonLookupInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PersonLookupInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface PersonLookupInfoRemoteSearchQuery
 */
export interface PersonLookupInfoRemoteSearchQuery {
    /**
     * 
     * @type {PersonLookupInfo}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchInfo?: PersonLookupInfo;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface PinRedeemResult
 */
export interface PinRedeemResult {
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success.
     * @type {boolean}
     * @memberof PinRedeemResult
     */
    Success?: boolean;
    /**
     * Gets or sets the users reset.
     * @type {Array<string>}
     * @memberof PinRedeemResult
     */
    UsersReset?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayAccess {
    Full = 'Full',
    None = 'None'
}

/**
 * Enum PlayCommand.
 * @export
 * @enum {string}
 */
export enum PlayCommand {
    PlayNow = 'PlayNow',
    PlayNext = 'PlayNext',
    PlayLast = 'PlayLast',
    PlayInstantMix = 'PlayInstantMix',
    PlayShuffle = 'PlayShuffle'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayMethod {
    Transcode = 'Transcode',
    DirectStream = 'DirectStream',
    DirectPlay = 'DirectPlay'
}

/**
 * Class PlayRequest.
 * @export
 * @interface PlayRequest
 */
export interface PlayRequest {
    /**
     * Gets or sets the item ids.
     * @type {Array<string>}
     * @memberof PlayRequest
     */
    ItemIds?: Array<string> | null;
    /**
     * Gets or sets the start position ticks that the first item should be played at.
     * @type {number}
     * @memberof PlayRequest
     */
    StartPositionTicks?: number | null;
    /**
     * 
     * @type {PlayCommand}
     * @memberof PlayRequest
     */
    PlayCommand?: PlayCommand;
    /**
     * Gets or sets the controlling user identifier.
     * @type {string}
     * @memberof PlayRequest
     */
    ControllingUserId?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayRequest
     */
    SubtitleStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayRequest
     */
    AudioStreamIndex?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlayRequest
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlayRequest
     */
    StartIndex?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlaybackErrorCode {
    NotAllowed = 'NotAllowed',
    NoCompatibleStream = 'NoCompatibleStream',
    RateLimitExceeded = 'RateLimitExceeded'
}

/**
 * Class PlaybackInfoResponse.
 * @export
 * @interface PlaybackInfoResponse
 */
export interface PlaybackInfoResponse {
    /**
     * Gets or sets the media sources.
     * @type {Array<MediaSourceInfo>}
     * @memberof PlaybackInfoResponse
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {PlaybackErrorCode}
     * @memberof PlaybackInfoResponse
     */
    ErrorCode?: PlaybackErrorCode;
}
/**
 * Class PlaybackProgressInfo.
 * @export
 * @interface PlaybackProgressInfo
 */
export interface PlaybackProgressInfo {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackProgressInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackProgressInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackProgressInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackProgressInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * Class PlaybackStartInfo.
 * @export
 * @interface PlaybackStartInfo
 */
export interface PlaybackStartInfo {
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStartInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the index of the audio stream.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the subtitle stream.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackStartInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackStartInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStartInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * Class PlaybackStopInfo.
 * @export
 * @interface PlaybackStopInfo
 */
export interface PlaybackStopInfo {
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStopInfo
     */
    Item?: BaseItemDto;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    ItemId?: string;
    /**
     * Gets or sets the session id.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    SessionId?: string | null;
    /**
     * Gets or sets the media version identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    MediaSourceId?: string | null;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof PlaybackStopInfo
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets the live stream identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    LiveStreamId?: string | null;
    /**
     * Gets or sets the play session identifier.
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaySessionId?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed.
     * @type {boolean}
     * @memberof PlaybackStopInfo
     */
    Failed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    NextMediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStopInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
}
/**
 * 
 * @export
 * @interface PlayerStateInfo
 */
export interface PlayerStateInfo {
    /**
     * Gets or sets the now playing position ticks.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    PositionTicks?: number | null;
    /**
     * Gets or sets a value indicating whether this instance can seek.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    CanSeek?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is paused.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsPaused?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is muted.
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsMuted?: boolean;
    /**
     * Gets or sets the volume level.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    VolumeLevel?: number | null;
    /**
     * Gets or sets the index of the now playing audio stream.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * Gets or sets the index of the now playing subtitle stream.
     * @type {number}
     * @memberof PlayerStateInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * Gets or sets the now playing media version identifier.
     * @type {string}
     * @memberof PlayerStateInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlayerStateInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlayerStateInfo
     */
    RepeatMode?: RepeatMode;
}
/**
 * 
 * @export
 * @interface PlaylistCreationResult
 */
export interface PlaylistCreationResult {
    /**
     * 
     * @type {string}
     * @memberof PlaylistCreationResult
     */
    Id?: string | null;
}
/**
 * Enum PlaystateCommand.
 * @export
 * @enum {string}
 */
export enum PlaystateCommand {
    Stop = 'Stop',
    Pause = 'Pause',
    Unpause = 'Unpause',
    NextTrack = 'NextTrack',
    PreviousTrack = 'PreviousTrack',
    Seek = 'Seek',
    Rewind = 'Rewind',
    FastForward = 'FastForward',
    PlayPause = 'PlayPause'
}

/**
 * 
 * @export
 * @interface PlaystateRequest
 */
export interface PlaystateRequest {
    /**
     * 
     * @type {PlaystateCommand}
     * @memberof PlaystateRequest
     */
    Command?: PlaystateCommand;
    /**
     * 
     * @type {number}
     * @memberof PlaystateRequest
     */
    SeekPositionTicks?: number | null;
    /**
     * Gets or sets the controlling user identifier.
     * @type {string}
     * @memberof PlaystateRequest
     */
    ControllingUserId?: string | null;
}
/**
 * This is a serializable stub class that is used by the api to provide information about installed plugins.
 * @export
 * @interface PluginInfo
 */
export interface PluginInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof PluginInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof PluginInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the name of the configuration file.
     * @type {string}
     * @memberof PluginInfo
     */
    ConfigurationFileName?: string | null;
    /**
     * Gets or sets the description.
     * @type {string}
     * @memberof PluginInfo
     */
    Description?: string | null;
    /**
     * Gets or sets the unique id.
     * @type {string}
     * @memberof PluginInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the plugin can be uninstalled.
     * @type {boolean}
     * @memberof PluginInfo
     */
    CanUninstall?: boolean;
    /**
     * Gets or sets the image URL.
     * @type {string}
     * @memberof PluginInfo
     */
    ImageUrl?: string | null;
}
/**
 * Plugin security info.
 * @export
 * @interface PluginSecurityInfo
 */
export interface PluginSecurityInfo {
    /**
     * Gets or sets the supporter key.
     * @type {string}
     * @memberof PluginSecurityInfo
     */
    SupporterKey?: string | null;
    /**
     * Gets or sets a value indicating whether is mb supporter.
     * @type {boolean}
     * @memberof PluginSecurityInfo
     */
    IsMbSupporter?: boolean;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any | any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    title?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    status?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    detail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    instance?: string | null;
}
/**
 * 
 * @export
 * @interface ProfileCondition
 */
export interface ProfileCondition {
    /**
     * 
     * @type {ProfileConditionType}
     * @memberof ProfileCondition
     */
    Condition?: ProfileConditionType;
    /**
     * 
     * @type {ProfileConditionValue}
     * @memberof ProfileCondition
     */
    Property?: ProfileConditionValue;
    /**
     * 
     * @type {string}
     * @memberof ProfileCondition
     */
    Value?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCondition
     */
    IsRequired?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionType {
    Equals = 'Equals',
    NotEquals = 'NotEquals',
    LessThanEqual = 'LessThanEqual',
    GreaterThanEqual = 'GreaterThanEqual',
    EqualsAny = 'EqualsAny'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionValue {
    AudioChannels = 'AudioChannels',
    AudioBitrate = 'AudioBitrate',
    AudioProfile = 'AudioProfile',
    Width = 'Width',
    Height = 'Height',
    Has64BitOffsets = 'Has64BitOffsets',
    PacketLength = 'PacketLength',
    VideoBitDepth = 'VideoBitDepth',
    VideoBitrate = 'VideoBitrate',
    VideoFramerate = 'VideoFramerate',
    VideoLevel = 'VideoLevel',
    VideoProfile = 'VideoProfile',
    VideoTimestamp = 'VideoTimestamp',
    IsAnamorphic = 'IsAnamorphic',
    RefFrames = 'RefFrames',
    NumAudioStreams = 'NumAudioStreams',
    NumVideoStreams = 'NumVideoStreams',
    IsSecondaryAudio = 'IsSecondaryAudio',
    VideoCodecTag = 'VideoCodecTag',
    IsAvc = 'IsAvc',
    IsInterlaced = 'IsInterlaced',
    AudioSampleRate = 'AudioSampleRate',
    AudioBitDepth = 'AudioBitDepth'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProgramAudio {
    Mono = 'Mono',
    Stereo = 'Stereo',
    Dolby = 'Dolby',
    DolbyDigital = 'DolbyDigital',
    Thx = 'Thx',
    Atmos = 'Atmos'
}

/**
 * 
 * @export
 * @interface PublicSystemInfo
 */
export interface PublicSystemInfo {
    /**
     * Gets or sets the local address.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     * @type {boolean}
     * @memberof PublicSystemInfo
     */
    StartupWizardCompleted?: boolean | null;
}
/**
 * 
 * @export
 * @interface QueryFilters
 */
export interface QueryFilters {
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof QueryFilters
     */
    Genres?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFilters
     */
    Tags?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface QueryFiltersLegacy
 */
export interface QueryFiltersLegacy {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Genres?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Tags?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    OfficialRatings?: Array<string> | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof QueryFiltersLegacy
     */
    Years?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface QueueItem
 */
export interface QueueItem {
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    PlaylistItemId?: string | null;
}
/**
 * The quick connect request body.
 * @export
 * @interface QuickConnectDto
 */
export interface QuickConnectDto {
    /**
     * Gets or sets the quick connect token.
     * @type {string}
     * @memberof QuickConnectDto
     */
    Token: string;
}
/**
 * Stores the result of an incoming quick connect request.
 * @export
 * @interface QuickConnectResult
 */
export interface QuickConnectResult {
    /**
     * Gets a value indicating whether this request is authorized.
     * @type {boolean}
     * @memberof QuickConnectResult
     */
    Authenticated?: boolean;
    /**
     * Gets or sets the secret value used to uniquely identify this request. Can be used to retrieve authentication information.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Secret?: string | null;
    /**
     * Gets or sets the user facing code used so the user can quickly differentiate this request from others.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Code?: string | null;
    /**
     * Gets or sets the private access token.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Authentication?: string | null;
    /**
     * Gets or sets an error message.
     * @type {string}
     * @memberof QuickConnectResult
     */
    Error?: string | null;
    /**
     * Gets or sets the DateTime that this request was created.
     * @type {string}
     * @memberof QuickConnectResult
     */
    DateAdded?: string | null;
}
/**
 * Quick connect state.
 * @export
 * @enum {string}
 */
export enum QuickConnectState {
    Unavailable = 'Unavailable',
    Available = 'Available',
    Active = 'Active'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RatingType {
    Score = 'Score',
    Likes = 'Likes'
}

/**
 * 
 * @export
 * @interface RecommendationDto
 */
export interface RecommendationDto {
    /**
     * 
     * @type {Array<BaseItemDto>}
     * @memberof RecommendationDto
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * 
     * @type {RecommendationType}
     * @memberof RecommendationDto
     */
    RecommendationType?: RecommendationType;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    BaselineItemName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    CategoryId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RecommendationType {
    SimilarToRecentlyPlayed = 'SimilarToRecentlyPlayed',
    SimilarToLikedItem = 'SimilarToLikedItem',
    HasDirectorFromRecentlyPlayed = 'HasDirectorFromRecentlyPlayed',
    HasActorFromRecentlyPlayed = 'HasActorFromRecentlyPlayed',
    HasLikedDirector = 'HasLikedDirector',
    HasLikedActor = 'HasLikedActor'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RecordingStatus {
    New = 'New',
    InProgress = 'InProgress',
    Completed = 'Completed',
    Cancelled = 'Cancelled',
    ConflictedOk = 'ConflictedOk',
    ConflictedNotOk = 'ConflictedNotOk',
    Error = 'Error'
}

/**
 * Class RemoteImageInfo.
 * @export
 * @interface RemoteImageInfo
 */
export interface RemoteImageInfo {
    /**
     * Gets or sets the name of the provider.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ProviderName?: string | null;
    /**
     * Gets or sets the URL.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Url?: string | null;
    /**
     * Gets a url used for previewing a smaller version.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ThumbnailUrl?: string | null;
    /**
     * Gets or sets the height.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Height?: number | null;
    /**
     * Gets or sets the width.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Width?: number | null;
    /**
     * Gets or sets the community rating.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    CommunityRating?: number | null;
    /**
     * Gets or sets the vote count.
     * @type {number}
     * @memberof RemoteImageInfo
     */
    VoteCount?: number | null;
    /**
     * Gets or sets the language.
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Language?: string | null;
    /**
     * 
     * @type {ImageType}
     * @memberof RemoteImageInfo
     */
    Type?: ImageType;
    /**
     * 
     * @type {RatingType}
     * @memberof RemoteImageInfo
     */
    RatingType?: RatingType;
}
/**
 * Class RemoteImageResult.
 * @export
 * @interface RemoteImageResult
 */
export interface RemoteImageResult {
    /**
     * Gets or sets the images.
     * @type {Array<RemoteImageInfo>}
     * @memberof RemoteImageResult
     */
    Images?: Array<RemoteImageInfo> | null;
    /**
     * Gets or sets the total record count.
     * @type {number}
     * @memberof RemoteImageResult
     */
    TotalRecordCount?: number;
    /**
     * Gets or sets the providers.
     * @type {Array<string>}
     * @memberof RemoteImageResult
     */
    Providers?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RemoteSearchResult
 */
export interface RemoteSearchResult {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Name?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof RemoteSearchResult
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ProductionYear?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumberEnd?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    ImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Overview?: string | null;
    /**
     * 
     * @type {RemoteSearchResult}
     * @memberof RemoteSearchResult
     */
    AlbumArtist?: RemoteSearchResult;
    /**
     * 
     * @type {Array<RemoteSearchResult>}
     * @memberof RemoteSearchResult
     */
    Artists?: Array<RemoteSearchResult> | null;
}
/**
 * 
 * @export
 * @interface RemoteSubtitleInfo
 */
export interface RemoteSubtitleInfo {
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Format?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Author?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    CommunityRating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    DownloadCount?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteSubtitleInfo
     */
    IsHashMatch?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RepeatMode {
    RepeatNone = 'RepeatNone',
    RepeatAll = 'RepeatAll',
    RepeatOne = 'RepeatOne'
}

/**
 * Class RepositoryInfo.
 * @export
 * @interface RepositoryInfo
 */
export interface RepositoryInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof RepositoryInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the URL.
     * @type {string}
     * @memberof RepositoryInfo
     */
    Url?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseProfile
 */
export interface ResponseProfile {
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ResponseProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    OrgPn?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    MimeType?: string | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ResponseProfile
     */
    Conditions?: Array<ProfileCondition> | null;
}
/**
 * An enum representing the axis that should be scrolled.
 * @export
 * @enum {string}
 */
export enum ScrollDirection {
    Horizontal = 'Horizontal',
    Vertical = 'Vertical'
}

/**
 * Class SearchHintResult.
 * @export
 * @interface SearchHint
 */
export interface SearchHint {
    /**
     * Gets or sets the item id.
     * @type {string}
     * @memberof SearchHint
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Id?: string;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SearchHint
     */
    Name?: string | null;
    /**
     * Gets or sets the matched term.
     * @type {string}
     * @memberof SearchHint
     */
    MatchedTerm?: string | null;
    /**
     * Gets or sets the index number.
     * @type {number}
     * @memberof SearchHint
     */
    IndexNumber?: number | null;
    /**
     * Gets or sets the production year.
     * @type {number}
     * @memberof SearchHint
     */
    ProductionYear?: number | null;
    /**
     * Gets or sets the parent index number.
     * @type {number}
     * @memberof SearchHint
     */
    ParentIndexNumber?: number | null;
    /**
     * Gets or sets the image tag.
     * @type {string}
     * @memberof SearchHint
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets the thumb image tag.
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageTag?: string | null;
    /**
     * Gets or sets the thumb image item identifier.
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageItemId?: string | null;
    /**
     * Gets or sets the backdrop image tag.
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageTag?: string | null;
    /**
     * Gets or sets the backdrop image item identifier.
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageItemId?: string | null;
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof SearchHint
     */
    Type?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SearchHint
     */
    IsFolder?: boolean | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof SearchHint
     */
    RunTimeTicks?: number | null;
    /**
     * Gets or sets the type of the media.
     * @type {string}
     * @memberof SearchHint
     */
    MediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    StartDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    EndDate?: string | null;
    /**
     * Gets or sets the series.
     * @type {string}
     * @memberof SearchHint
     */
    Series?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Status?: string | null;
    /**
     * Gets or sets the album.
     * @type {string}
     * @memberof SearchHint
     */
    Album?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    AlbumId?: string;
    /**
     * Gets or sets the album artist.
     * @type {string}
     * @memberof SearchHint
     */
    AlbumArtist?: string | null;
    /**
     * Gets or sets the artists.
     * @type {Array<string>}
     * @memberof SearchHint
     */
    Artists?: Array<string> | null;
    /**
     * Gets or sets the song count.
     * @type {number}
     * @memberof SearchHint
     */
    SongCount?: number | null;
    /**
     * Gets or sets the episode count.
     * @type {number}
     * @memberof SearchHint
     */
    EpisodeCount?: number | null;
    /**
     * Gets or sets the channel identifier.
     * @type {string}
     * @memberof SearchHint
     */
    ChannelId?: string;
    /**
     * Gets or sets the name of the channel.
     * @type {string}
     * @memberof SearchHint
     */
    ChannelName?: string | null;
    /**
     * Gets or sets the primary image aspect ratio.
     * @type {number}
     * @memberof SearchHint
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * Class SearchHintResult.
 * @export
 * @interface SearchHintResult
 */
export interface SearchHintResult {
    /**
     * Gets or sets the search hints.
     * @type {Array<SearchHint>}
     * @memberof SearchHintResult
     */
    SearchHints?: Array<SearchHint> | null;
    /**
     * Gets or sets the total record count.
     * @type {number}
     * @memberof SearchHintResult
     */
    TotalRecordCount?: number;
}
/**
 * Class SendCommand.
 * @export
 * @interface SendCommand
 */
export interface SendCommand {
    /**
     * Gets or sets the group identifier.
     * @type {string}
     * @memberof SendCommand
     */
    GroupId?: string | null;
    /**
     * Gets or sets the UTC time when to execute the command.
     * @type {string}
     * @memberof SendCommand
     */
    When?: string | null;
    /**
     * Gets or sets the position ticks.
     * @type {number}
     * @memberof SendCommand
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {SendCommandType}
     * @memberof SendCommand
     */
    Command?: SendCommandType;
    /**
     * Gets or sets the UTC time when this command has been emitted.
     * @type {string}
     * @memberof SendCommand
     */
    EmittedAt?: string | null;
}
/**
 * Enum SendCommandType.
 * @export
 * @enum {string}
 */
export enum SendCommandType {
    Play = 'Play',
    Pause = 'Pause',
    Seek = 'Seek'
}

/**
 * 
 * @export
 * @interface SeriesInfo
 */
export interface SeriesInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SeriesInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof SeriesInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof SeriesInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof SeriesInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface SeriesInfoRemoteSearchQuery
 */
export interface SeriesInfoRemoteSearchQuery {
    /**
     * 
     * @type {SeriesInfo}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchInfo?: SeriesInfo;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * Class SeriesTimerInfoDto.
 * @export
 * @interface SeriesTimerInfoDto
 */
export interface SeriesTimerInfoDto {
    /**
     * Id of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * ChannelId of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * ChannelName of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * Name of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Name?: string | null;
    /**
     * Description of the recording.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Overview?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof SeriesTimerInfoDto
     */
    KeepUntil?: KeepUntil;
    /**
     * Gets or sets a value indicating whether [record any time].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyTime?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    SkipEpisodesInLibrary?: boolean;
    /**
     * Gets or sets a value indicating whether [record any channel].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyChannel?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    KeepUpTo?: number;
    /**
     * Gets or sets a value indicating whether [record new only].
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordNewOnly?: boolean;
    /**
     * Gets or sets the days.
     * @type {Array<DayOfWeek>}
     * @memberof SeriesTimerInfoDto
     */
    Days?: Array<DayOfWeek> | null;
    /**
     * 
     * @type {DayPattern}
     * @memberof SeriesTimerInfoDto
     */
    DayPattern?: DayPattern;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof SeriesTimerInfoDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * Gets or sets the parent thumb item id.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbItemId?: string | null;
    /**
     * Gets or sets the parent thumb image tag.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * Gets or sets the parent primary image item identifier.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * Gets or sets the parent primary image tag.
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageTag?: string | null;
}
/**
 * 
 * @export
 * @interface SeriesTimerInfoDtoQueryResult
 */
export interface SeriesTimerInfoDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<SeriesTimerInfoDto>}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    Items?: Array<SeriesTimerInfoDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * Represents the server configuration.
 * @export
 * @interface ServerConfiguration
 */
export interface ServerConfiguration {
    /**
     * Gets or sets the number of days we should retain log files.
     * @type {number}
     * @memberof ServerConfiguration
     */
    LogFileRetentionDays?: number;
    /**
     * Gets or sets a value indicating whether this instance is first run.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * Gets or sets the cache path.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CachePath?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof ServerConfiguration
     */
    PreviousVersion?: Version;
    /**
     * Gets or sets the stringified PreviousVersion to be stored/loaded,  because System.Version itself isn\'t xml-serializable.
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreviousVersionStr?: string | null;
    /**
     * Gets or sets a value indicating whether to enable automatic port forwarding.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableUPnP?: boolean;
    /**
     * Gets or sets a value indicating whether to enable prometheus metrics exporting.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableMetrics?: boolean;
    /**
     * Gets or sets the public mapped port.
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicPort?: number;
    /**
     * Gets or sets the public HTTPS port.
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicHttpsPort?: number;
    /**
     * Gets or sets the HTTP server port number.
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpServerPortNumber?: number;
    /**
     * Gets or sets the HTTPS server port number.
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpsPortNumber?: number;
    /**
     * Gets or sets a value indicating whether to use HTTPS.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNormalizedItemByNameIds?: boolean;
    /**
     * Gets or sets the filesystem path of an X.509 certificate to use for SSL.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePath?: string | null;
    /**
     * Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Model.Configuration.ServerConfiguration.CertificatePath.
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePassword?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is port authorized.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsPortAuthorized?: boolean;
    /**
     * Gets or sets if quick connect is available for use on this server.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    QuickConnectAvailable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableRemoteAccess?: boolean;
    /**
     * Gets or sets a value indicating whether [enable case sensitive item ids].
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableCaseSensitiveItemIds?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisableLiveTvChannelUserDataName?: boolean;
    /**
     * Gets or sets the metadata path.
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataNetworkPath?: string | null;
    /**
     * Gets or sets the preferred metadata language.
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataCountryCode?: string | null;
    /**
     * Characters to be replaced with a \' \' in strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortReplaceCharacters?: Array<string> | null;
    /**
     * Characters to be removed from strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveCharacters?: Array<string> | null;
    /**
     * Words to be removed from strings to create a sort name.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveWords?: Array<string> | null;
    /**
     * Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumePct?: number;
    /**
     * Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     * @type {number}
     * @memberof ServerConfiguration
     */
    MaxResumePct?: number;
    /**
     * Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumeDurationSeconds?: number;
    /**
     * The delay in seconds that we will wait after a file system change to try and discover what has been added/removed  Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several  different directories and files.
     * @type {number}
     * @memberof ServerConfiguration
     */
    LibraryMonitorDelay?: number;
    /**
     * Gets or sets a value indicating whether [enable dashboard response caching].  Allows potential contributors without visual studio to modify production dashboard code and test changes.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableDashboardResponseCaching?: boolean;
    /**
     * 
     * @type {ImageSavingConvention}
     * @memberof ServerConfiguration
     */
    ImageSavingConvention?: ImageSavingConvention;
    /**
     * 
     * @type {Array<MetadataOptions>}
     * @memberof ServerConfiguration
     */
    MetadataOptions?: Array<MetadataOptions> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SkipDeserializationForBasicTypes?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    BaseUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    UICulture?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SaveMetadataHidden?: boolean;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ServerConfiguration
     */
    ContentTypes?: Array<NameValuePair> | null;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableFolderView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableGroupingIntoCollections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisplaySpecialsWithinSeasons?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkSubnets?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkAddresses?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    CodecsUsed?: Array<string> | null;
    /**
     * 
     * @type {Array<RepositoryInfo>}
     * @memberof ServerConfiguration
     */
    PluginRepositories?: Array<RepositoryInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IgnoreVirtualInterfaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableExternalContentInSuggestions?: boolean;
    /**
     * Gets or sets a value indicating whether the server should force connections over HTTPS.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    RequireHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNewOmdbSupport?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    RemoteIPFilter?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsRemoteIPFilterBlacklist?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    ImageExtractionTimeoutMs?: number;
    /**
     * 
     * @type {Array<PathSubstitution>}
     * @memberof ServerConfiguration
     */
    PathSubstitutions?: Array<PathSubstitution> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSimpleArtistDetection?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    UninstalledPlugins?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether slow server responses should be logged as a warning.
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSlowResponseWarning?: boolean;
    /**
     * Gets or sets the threshold for the slow response time warning in ms.
     * @type {number}
     * @memberof ServerConfiguration
     */
    SlowResponseThresholdMs?: number;
    /**
     * Gets or sets the cors hosts.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    CorsHosts?: Array<string> | null;
    /**
     * Gets or sets the known proxies.
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    KnownProxies?: Array<string> | null;
    /**
     * Gets or sets the number of days we should retain activity logs.
     * @type {number}
     * @memberof ServerConfiguration
     */
    ActivityLogRetentionDays?: number | null;
}
/**
 * Class SessionInfo.
 * @export
 * @interface SessionInfo
 */
export interface SessionInfo {
    /**
     * 
     * @type {PlayerStateInfo}
     * @memberof SessionInfo
     */
    PlayState?: PlayerStateInfo;
    /**
     * 
     * @type {Array<SessionUserInfo>}
     * @memberof SessionInfo
     */
    AdditionalUsers?: Array<SessionUserInfo> | null;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof SessionInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * Gets or sets the remote end point.
     * @type {string}
     * @memberof SessionInfo
     */
    RemoteEndPoint?: string | null;
    /**
     * Gets or sets the playable media types.
     * @type {Array<string>}
     * @memberof SessionInfo
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof SessionInfo
     */
    Id?: string | null;
    /**
     * Gets or sets the user id.
     * @type {string}
     * @memberof SessionInfo
     */
    UserId?: string;
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof SessionInfo
     */
    UserName?: string | null;
    /**
     * Gets or sets the type of the client.
     * @type {string}
     * @memberof SessionInfo
     */
    Client?: string | null;
    /**
     * Gets or sets the last activity date.
     * @type {string}
     * @memberof SessionInfo
     */
    LastActivityDate?: string;
    /**
     * Gets or sets the last playback check in.
     * @type {string}
     * @memberof SessionInfo
     */
    LastPlaybackCheckIn?: string;
    /**
     * Gets or sets the name of the device.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceName?: string | null;
    /**
     * Gets or sets the type of the device.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceType?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowPlayingItem?: BaseItemDto;
    /**
     * 
     * @type {BaseItem}
     * @memberof SessionInfo
     */
    FullNowPlayingItem?: BaseItem;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowViewingItem?: BaseItemDto;
    /**
     * Gets or sets the device id.
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceId?: string | null;
    /**
     * Gets or sets the application version.
     * @type {string}
     * @memberof SessionInfo
     */
    ApplicationVersion?: string | null;
    /**
     * 
     * @type {TranscodingInfo}
     * @memberof SessionInfo
     */
    TranscodingInfo?: TranscodingInfo;
    /**
     * Gets a value indicating whether this instance is active.
     * @type {boolean}
     * @memberof SessionInfo
     */
    IsActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsRemoteControl?: boolean;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof SessionInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    HasCustomDeviceName?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    UserPrimaryImageTag?: string | null;
    /**
     * Gets or sets the supported commands.
     * @type {Array<GeneralCommandType>}
     * @memberof SessionInfo
     */
    SupportedCommands?: Array<GeneralCommandType> | null;
}
/**
 * Class SessionUserInfo.
 * @export
 * @interface SessionUserInfo
 */
export interface SessionUserInfo {
    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserId?: string;
    /**
     * Gets or sets the name of the user.
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface SongInfo
 */
export interface SongInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof SongInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof SongInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof SongInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof SongInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof SongInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof SongInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SongInfo
     */
    IsAutomated?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    Album?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    Artists?: Array<string> | null;
}
/**
 * An enum representing the sorting order.
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Ascending = 'Ascending',
    Descending = 'Descending'
}

/**
 * Special view option dto.
 * @export
 * @interface SpecialViewOptionDto
 */
export interface SpecialViewOptionDto {
    /**
     * Gets or sets view option name.
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Name?: string | null;
    /**
     * Gets or sets view option id.
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Id?: string | null;
}
/**
 * The startup configuration DTO.
 * @export
 * @interface StartupConfigurationDto
 */
export interface StartupConfigurationDto {
    /**
     * Gets or sets UI language culture.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    UICulture?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the preferred language for the metadata.
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    PreferredMetadataLanguage?: string | null;
}
/**
 * Startup remote access dto.
 * @export
 * @interface StartupRemoteAccessDto
 */
export interface StartupRemoteAccessDto {
    /**
     * Gets or sets a value indicating whether enable remote access.
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableRemoteAccess: boolean;
    /**
     * Gets or sets a value indicating whether enable automatic port mapping.
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableAutomaticPortMapping: boolean;
}
/**
 * The startup user DTO.
 * @export
 * @interface StartupUserDto
 */
export interface StartupUserDto {
    /**
     * Gets or sets the username.
     * @type {string}
     * @memberof StartupUserDto
     */
    Name?: string | null;
    /**
     * Gets or sets the user\'s password.
     * @type {string}
     * @memberof StartupUserDto
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SubtitleDeliveryMethod {
    Encode = 'Encode',
    Embed = 'Embed',
    External = 'External',
    Hls = 'Hls'
}

/**
 * An enum representing a subtitle playback mode.
 * @export
 * @enum {string}
 */
export enum SubtitlePlaybackMode {
    Default = 'Default',
    Always = 'Always',
    OnlyForced = 'OnlyForced',
    None = 'None',
    Smart = 'Smart'
}

/**
 * 
 * @export
 * @interface SubtitleProfile
 */
export interface SubtitleProfile {
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Format?: string | null;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof SubtitleProfile
     */
    Method?: SubtitleDeliveryMethod;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    DidlMode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Language?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Container?: string | null;
}
/**
 * Enum SyncPlayAccess.
 * @export
 * @enum {string}
 */
export enum SyncPlayAccess {
    CreateAndJoinGroups = 'CreateAndJoinGroups',
    JoinGroups = 'JoinGroups',
    None = 'None'
}

/**
 * Class SystemInfo.
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * Gets or sets the local address.
     * @type {string}
     * @memberof SystemInfo
     */
    LocalAddress?: string | null;
    /**
     * Gets or sets the name of the server.
     * @type {string}
     * @memberof SystemInfo
     */
    ServerName?: string | null;
    /**
     * Gets or sets the server version.
     * @type {string}
     * @memberof SystemInfo
     */
    Version?: string | null;
    /**
     * Gets or sets the product name. This is the AssemblyProduct name.
     * @type {string}
     * @memberof SystemInfo
     */
    ProductName?: string | null;
    /**
     * Gets or sets the operating system.
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof SystemInfo
     */
    Id?: string | null;
    /**
     * Gets or sets a value indicating whether the startup wizard is completed.
     * @type {boolean}
     * @memberof SystemInfo
     */
    StartupWizardCompleted?: boolean | null;
    /**
     * Gets or sets the display name of the operating system.
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystemDisplayName?: string | null;
    /**
     * Get or sets the package name.
     * @type {string}
     * @memberof SystemInfo
     */
    PackageName?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has pending restart.
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasPendingRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    IsShuttingDown?: boolean;
    /**
     * Gets or sets a value indicating whether [supports library monitor].
     * @type {boolean}
     * @memberof SystemInfo
     */
    SupportsLibraryMonitor?: boolean;
    /**
     * Gets or sets the web socket port number.
     * @type {number}
     * @memberof SystemInfo
     */
    WebSocketPortNumber?: number;
    /**
     * Gets or sets the completed installations.
     * @type {Array<InstallationInfo>}
     * @memberof SystemInfo
     */
    CompletedInstallations?: Array<InstallationInfo> | null;
    /**
     * Gets or sets a value indicating whether this instance can self restart.
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanSelfRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanLaunchWebBrowser?: boolean;
    /**
     * Gets or sets the program data path.
     * @type {string}
     * @memberof SystemInfo
     */
    ProgramDataPath?: string | null;
    /**
     * Gets or sets the web UI resources path.
     * @type {string}
     * @memberof SystemInfo
     */
    WebPath?: string | null;
    /**
     * Gets or sets the items by name path.
     * @type {string}
     * @memberof SystemInfo
     */
    ItemsByNamePath?: string | null;
    /**
     * Gets or sets the cache path.
     * @type {string}
     * @memberof SystemInfo
     */
    CachePath?: string | null;
    /**
     * Gets or sets the log path.
     * @type {string}
     * @memberof SystemInfo
     */
    LogPath?: string | null;
    /**
     * Gets or sets the internal metadata path.
     * @type {string}
     * @memberof SystemInfo
     */
    InternalMetadataPath?: string | null;
    /**
     * Gets or sets the transcode path.
     * @type {string}
     * @memberof SystemInfo
     */
    TranscodingTempPath?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has update available.
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * 
     * @type {FFmpegLocation}
     * @memberof SystemInfo
     */
    EncoderLocation?: FFmpegLocation;
    /**
     * 
     * @type {Architecture}
     * @memberof SystemInfo
     */
    SystemArchitecture?: Architecture;
}
/**
 * Enum TaskCompletionStatus.
 * @export
 * @enum {string}
 */
export enum TaskCompletionStatus {
    Completed = 'Completed',
    Failed = 'Failed',
    Cancelled = 'Cancelled',
    Aborted = 'Aborted'
}

/**
 * Class TaskInfo.
 * @export
 * @interface TaskInfo
 */
export interface TaskInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TaskInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {TaskState}
     * @memberof TaskInfo
     */
    State?: TaskState;
    /**
     * Gets or sets the progress.
     * @type {number}
     * @memberof TaskInfo
     */
    CurrentProgressPercentage?: number | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof TaskInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {TaskResult}
     * @memberof TaskInfo
     */
    LastExecutionResult?: TaskResult;
    /**
     * Gets or sets the triggers.
     * @type {Array<TaskTriggerInfo>}
     * @memberof TaskInfo
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * Gets or sets the description.
     * @type {string}
     * @memberof TaskInfo
     */
    Description?: string | null;
    /**
     * Gets or sets the category.
     * @type {string}
     * @memberof TaskInfo
     */
    Category?: string | null;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     * @type {boolean}
     * @memberof TaskInfo
     */
    IsHidden?: boolean;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof TaskInfo
     */
    Key?: string | null;
}
/**
 * Class TaskExecutionInfo.
 * @export
 * @interface TaskResult
 */
export interface TaskResult {
    /**
     * Gets or sets the start time UTC.
     * @type {string}
     * @memberof TaskResult
     */
    StartTimeUtc?: string;
    /**
     * Gets or sets the end time UTC.
     * @type {string}
     * @memberof TaskResult
     */
    EndTimeUtc?: string;
    /**
     * 
     * @type {TaskCompletionStatus}
     * @memberof TaskResult
     */
    Status?: TaskCompletionStatus;
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TaskResult
     */
    Name?: string | null;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof TaskResult
     */
    Key?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof TaskResult
     */
    Id?: string | null;
    /**
     * Gets or sets the error message.
     * @type {string}
     * @memberof TaskResult
     */
    ErrorMessage?: string | null;
    /**
     * Gets or sets the long error message.
     * @type {string}
     * @memberof TaskResult
     */
    LongErrorMessage?: string | null;
}
/**
 * Enum TaskState.
 * @export
 * @enum {string}
 */
export enum TaskState {
    Idle = 'Idle',
    Cancelling = 'Cancelling',
    Running = 'Running'
}

/**
 * Class TaskTriggerInfo.
 * @export
 * @interface TaskTriggerInfo
 */
export interface TaskTriggerInfo {
    /**
     * Gets or sets the type.
     * @type {string}
     * @memberof TaskTriggerInfo
     */
    Type?: string | null;
    /**
     * Gets or sets the time of day.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    TimeOfDayTicks?: number | null;
    /**
     * Gets or sets the interval.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    IntervalTicks?: number | null;
    /**
     * 
     * @type {DayOfWeek}
     * @memberof TaskTriggerInfo
     */
    DayOfWeek?: DayOfWeek;
    /**
     * Gets or sets the maximum runtime ticks.
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    MaxRuntimeTicks?: number | null;
}
/**
 * Class ThemeMediaResult.
 * @export
 * @interface ThemeMediaResult
 */
export interface ThemeMediaResult {
    /**
     * Gets or sets the items.
     * @type {Array<BaseItemDto>}
     * @memberof ThemeMediaResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof ThemeMediaResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof ThemeMediaResult
     */
    StartIndex?: number;
    /**
     * Gets or sets the owner id.
     * @type {string}
     * @memberof ThemeMediaResult
     */
    OwnerId?: string;
}
/**
 * 
 * @export
 * @interface TimerEventInfo
 */
export interface TimerEventInfo {
    /**
     * 
     * @type {string}
     * @memberof TimerEventInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerEventInfo
     */
    ProgramId?: string | null;
}
/**
 * 
 * @export
 * @interface TimerInfoDto
 */
export interface TimerInfoDto {
    /**
     * Id of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Type?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the external identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * ChannelId of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelId?: string;
    /**
     * Gets or sets the external channel identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * ChannelName of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * Gets or sets the program identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * Gets or sets the external program identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * Name of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Name?: string | null;
    /**
     * Description of the recording.
     * @type {string}
     * @memberof TimerInfoDto
     */
    Overview?: string | null;
    /**
     * The start date of the recording, in UTC.
     * @type {string}
     * @memberof TimerInfoDto
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     * @type {string}
     * @memberof TimerInfoDto
     */
    EndDate?: string;
    /**
     * Gets or sets the name of the service.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * Gets or sets the priority.
     * @type {number}
     * @memberof TimerInfoDto
     */
    Priority?: number;
    /**
     * Gets or sets the pre padding seconds.
     * @type {number}
     * @memberof TimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * Gets or sets the post padding seconds.
     * @type {number}
     * @memberof TimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * Gets or sets a value indicating whether this instance is pre padding required.
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * Gets or sets the parent backdrop image tags.
     * @type {Array<string>}
     * @memberof TimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * Gets or sets a value indicating whether this instance is post padding required.
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof TimerInfoDto
     */
    KeepUntil?: KeepUntil;
    /**
     * 
     * @type {RecordingStatus}
     * @memberof TimerInfoDto
     */
    Status?: RecordingStatus;
    /**
     * Gets or sets the series timer identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    SeriesTimerId?: string | null;
    /**
     * Gets or sets the external series timer identifier.
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalSeriesTimerId?: string | null;
    /**
     * Gets or sets the run time ticks.
     * @type {number}
     * @memberof TimerInfoDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof TimerInfoDto
     */
    ProgramInfo?: BaseItemDto;
}
/**
 * 
 * @export
 * @interface TimerInfoDtoQueryResult
 */
export interface TimerInfoDtoQueryResult {
    /**
     * Gets or sets the items.
     * @type {Array<TimerInfoDto>}
     * @memberof TimerInfoDtoQueryResult
     */
    Items?: Array<TimerInfoDto> | null;
    /**
     * The total number of records available.
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * The index of the first record in Items.
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface TrailerInfo
 */
export interface TrailerInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof TrailerInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof TrailerInfo
     */
    Path?: string | null;
    /**
     * Gets or sets the metadata language.
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataLanguage?: string | null;
    /**
     * Gets or sets the metadata country code.
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * Gets or sets the provider ids.
     * @type {{ [key: string]: string; }}
     * @memberof TrailerInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * Gets or sets the year.
     * @type {number}
     * @memberof TrailerInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrailerInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface TrailerInfoRemoteSearchQuery
 */
export interface TrailerInfoRemoteSearchQuery {
    /**
     * 
     * @type {TrailerInfo}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchInfo?: TrailerInfo;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * Will only search within the given provider when set.
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * Gets or sets a value indicating whether disabled providers should be included.
     * @type {boolean}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeReason {
    ContainerNotSupported = 'ContainerNotSupported',
    VideoCodecNotSupported = 'VideoCodecNotSupported',
    AudioCodecNotSupported = 'AudioCodecNotSupported',
    ContainerBitrateExceedsLimit = 'ContainerBitrateExceedsLimit',
    AudioBitrateNotSupported = 'AudioBitrateNotSupported',
    AudioChannelsNotSupported = 'AudioChannelsNotSupported',
    VideoResolutionNotSupported = 'VideoResolutionNotSupported',
    UnknownVideoStreamInfo = 'UnknownVideoStreamInfo',
    UnknownAudioStreamInfo = 'UnknownAudioStreamInfo',
    AudioProfileNotSupported = 'AudioProfileNotSupported',
    AudioSampleRateNotSupported = 'AudioSampleRateNotSupported',
    AnamorphicVideoNotSupported = 'AnamorphicVideoNotSupported',
    InterlacedVideoNotSupported = 'InterlacedVideoNotSupported',
    SecondaryAudioNotSupported = 'SecondaryAudioNotSupported',
    RefFramesNotSupported = 'RefFramesNotSupported',
    VideoBitDepthNotSupported = 'VideoBitDepthNotSupported',
    VideoBitrateNotSupported = 'VideoBitrateNotSupported',
    VideoFramerateNotSupported = 'VideoFramerateNotSupported',
    VideoLevelNotSupported = 'VideoLevelNotSupported',
    VideoProfileNotSupported = 'VideoProfileNotSupported',
    AudioBitDepthNotSupported = 'AudioBitDepthNotSupported',
    SubtitleCodecNotSupported = 'SubtitleCodecNotSupported',
    DirectPlayError = 'DirectPlayError'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeSeekInfo {
    Auto = 'Auto',
    Bytes = 'Bytes'
}

/**
 * 
 * @export
 * @interface TranscodingInfo
 */
export interface TranscodingInfo {
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsVideoDirect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsAudioDirect?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Framerate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    CompletionPercentage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    AudioChannels?: number | null;
    /**
     * 
     * @type {Array<TranscodeReason>}
     * @memberof TranscodingInfo
     */
    TranscodeReasons?: Array<TranscodeReason> | null;
}
/**
 * 
 * @export
 * @interface TranscodingProfile
 */
export interface TranscodingProfile {
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof TranscodingProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Protocol?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EstimateContentLength?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableMpegtsM2TsMode?: boolean;
    /**
     * 
     * @type {TranscodeSeekInfo}
     * @memberof TranscodingProfile
     */
    TranscodeSeekInfo?: TranscodeSeekInfo;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    CopyTimestamps?: boolean;
    /**
     * 
     * @type {EncodingContext}
     * @memberof TranscodingProfile
     */
    Context?: EncodingContext;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableSubtitlesInManifest?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    MaxAudioChannels?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    MinSegments?: number;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    SegmentLength?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    BreakOnNonKeyFrames?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransportStreamTimestamp {
    None = 'None',
    Zero = 'Zero',
    Valid = 'Valid'
}

/**
 * 
 * @export
 * @interface TunerChannelMapping
 */
export interface TunerChannelMapping {
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface TunerHostInfo
 */
export interface TunerHostInfo {
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    DeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    ImportFavoritesOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    AllowHWTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    EnableStreamLooping?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Source?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TunerHostInfo
     */
    TunerCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface TypeOptions
 */
export interface TypeOptions {
    /**
     * 
     * @type {string}
     * @memberof TypeOptions
     */
    Type?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<ImageOption>}
     * @memberof TypeOptions
     */
    ImageOptions?: Array<ImageOption> | null;
}
/**
 * An enum representing an unrated item.
 * @export
 * @enum {string}
 */
export enum UnratedItem {
    Movie = 'Movie',
    Trailer = 'Trailer',
    Series = 'Series',
    Music = 'Music',
    Book = 'Book',
    LiveTvChannel = 'LiveTvChannel',
    LiveTvProgram = 'LiveTvProgram',
    ChannelContent = 'ChannelContent',
    Other = 'Other'
}

/**
 * Update library options dto.
 * @export
 * @interface UpdateLibraryOptionsDto
 */
export interface UpdateLibraryOptionsDto {
    /**
     * Gets or sets the library item id.
     * @type {string}
     * @memberof UpdateLibraryOptionsDto
     */
    Id?: string;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof UpdateLibraryOptionsDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * The update user easy password request body.
 * @export
 * @interface UpdateUserEasyPassword
 */
export interface UpdateUserEasyPassword {
    /**
     * Gets or sets the new sha1-hashed password.
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPassword?: string | null;
    /**
     * Gets or sets the new password.
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPw?: string | null;
    /**
     * Gets or sets a value indicating whether to reset the password.
     * @type {boolean}
     * @memberof UpdateUserEasyPassword
     */
    ResetPassword?: boolean;
}
/**
 * The update user password request body.
 * @export
 * @interface UpdateUserPassword
 */
export interface UpdateUserPassword {
    /**
     * Gets or sets the current sha1-hashed password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPassword?: string | null;
    /**
     * Gets or sets the current plain text password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPw?: string | null;
    /**
     * Gets or sets the new plain text password.
     * @type {string}
     * @memberof UpdateUserPassword
     */
    NewPw?: string | null;
    /**
     * Gets or sets a value indicating whether to reset the password.
     * @type {boolean}
     * @memberof UpdateUserPassword
     */
    ResetPassword?: boolean;
}
/**
 * Upload subtitles dto.
 * @export
 * @interface UploadSubtitleDto
 */
export interface UploadSubtitleDto {
    /**
     * Gets or sets the subtitle language.
     * @type {string}
     * @memberof UploadSubtitleDto
     */
    Language: string;
    /**
     * Gets or sets the subtitle format.
     * @type {string}
     * @memberof UploadSubtitleDto
     */
    Format: string;
    /**
     * Gets or sets a value indicating whether the subtitle is forced.
     * @type {boolean}
     * @memberof UploadSubtitleDto
     */
    IsForced: boolean;
    /**
     * Gets or sets the subtitle data.
     * @type {string}
     * @memberof UploadSubtitleDto
     */
    Data: string;
}
/**
 * Class UserConfiguration.
 * @export
 * @interface UserConfiguration
 */
export interface UserConfiguration {
    /**
     * Gets or sets the audio language preference.
     * @type {string}
     * @memberof UserConfiguration
     */
    AudioLanguagePreference?: string | null;
    /**
     * Gets or sets a value indicating whether [play default audio track].
     * @type {boolean}
     * @memberof UserConfiguration
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * Gets or sets the subtitle language preference.
     * @type {string}
     * @memberof UserConfiguration
     */
    SubtitleLanguagePreference?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayMissingEpisodes?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    GroupedFolders?: Array<string> | null;
    /**
     * 
     * @type {SubtitlePlaybackMode}
     * @memberof UserConfiguration
     */
    SubtitleMode?: SubtitlePlaybackMode;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayCollectionsView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableLocalPassword?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    OrderedViews?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    LatestItemsExcludes?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    MyMediaExcludes?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    HidePlayedInLatest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberAudioSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberSubtitleSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableNextEpisodeAutoPlay?: boolean;
}
/**
 * Class UserDto.
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof UserDto
     */
    Name?: string | null;
    /**
     * Gets or sets the server identifier.
     * @type {string}
     * @memberof UserDto
     */
    ServerId?: string | null;
    /**
     * Gets or sets the name of the server.  This is not used by the server and is for client-side usage only.
     * @type {string}
     * @memberof UserDto
     */
    ServerName?: string | null;
    /**
     * Gets or sets the id.
     * @type {string}
     * @memberof UserDto
     */
    Id?: string;
    /**
     * Gets or sets the primary image tag.
     * @type {string}
     * @memberof UserDto
     */
    PrimaryImageTag?: string | null;
    /**
     * Gets or sets a value indicating whether this instance has password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredPassword?: boolean;
    /**
     * Gets or sets a value indicating whether this instance has configured easy password.
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredEasyPassword?: boolean;
    /**
     * Gets or sets whether async login is enabled or not.
     * @type {boolean}
     * @memberof UserDto
     */
    EnableAutoLogin?: boolean | null;
    /**
     * Gets or sets the last login date.
     * @type {string}
     * @memberof UserDto
     */
    LastLoginDate?: string | null;
    /**
     * Gets or sets the last activity date.
     * @type {string}
     * @memberof UserDto
     */
    LastActivityDate?: string | null;
    /**
     * 
     * @type {UserConfiguration}
     * @memberof UserDto
     */
    Configuration?: UserConfiguration;
    /**
     * 
     * @type {UserPolicy}
     * @memberof UserDto
     */
    Policy?: UserPolicy;
    /**
     * Gets or sets the primary image aspect ratio.
     * @type {number}
     * @memberof UserDto
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * Class UserItemDataDto.
 * @export
 * @interface UserItemDataDto
 */
export interface UserItemDataDto {
    /**
     * Gets or sets the rating.
     * @type {number}
     * @memberof UserItemDataDto
     */
    Rating?: number | null;
    /**
     * Gets or sets the played percentage.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayedPercentage?: number | null;
    /**
     * Gets or sets the unplayed item count.
     * @type {number}
     * @memberof UserItemDataDto
     */
    UnplayedItemCount?: number | null;
    /**
     * Gets or sets the playback position ticks.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlaybackPositionTicks?: number;
    /**
     * Gets or sets the play count.
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayCount?: number;
    /**
     * Gets or sets a value indicating whether this instance is favorite.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    IsFavorite?: boolean;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Likes?: boolean | null;
    /**
     * Gets or sets the last played date.
     * @type {string}
     * @memberof UserItemDataDto
     */
    LastPlayedDate?: string | null;
    /**
     * Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Played?: boolean;
    /**
     * Gets or sets the key.
     * @type {string}
     * @memberof UserItemDataDto
     */
    Key?: string | null;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof UserItemDataDto
     */
    ItemId?: string | null;
}
/**
 * 
 * @export
 * @interface UserPolicy
 */
export interface UserPolicy {
    /**
     * Gets or sets a value indicating whether this instance is administrator.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsAdministrator?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is hidden.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsHidden?: boolean;
    /**
     * Gets or sets a value indicating whether this instance is disabled.
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsDisabled?: boolean;
    /**
     * Gets or sets the max parental rating.
     * @type {number}
     * @memberof UserPolicy
     */
    MaxParentalRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedTags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableUserPreferenceAccess?: boolean;
    /**
     * 
     * @type {Array<AccessSchedule>}
     * @memberof UserPolicy
     */
    AccessSchedules?: Array<AccessSchedule> | null;
    /**
     * 
     * @type {Array<UnratedItem>}
     * @memberof UserPolicy
     */
    BlockUnratedItems?: Array<UnratedItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteControlOfOtherUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSharedDeviceControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvManagement?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaPlayback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAudioPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableVideoPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePlaybackRemuxing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    ForceRemoteSourceTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDeletion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnableContentDeletionFromFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDownloading?: boolean;
    /**
     * Gets or sets a value indicating whether [enable synchronize].
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSyncTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaConversion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledDevices?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllDevices?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledChannels?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllChannels?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllFolders?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    InvalidLoginAttemptCount?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    LoginAttemptsBeforeLockout?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    MaxActiveSessions?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePublicSharing?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedMediaFolders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedChannels?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    AuthenticationProviderId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    PasswordResetProviderId?: string | null;
    /**
     * 
     * @type {SyncPlayAccess}
     * @memberof UserPolicy
     */
    SyncPlayAccess?: SyncPlayAccess;
}
/**
 * Class UtcTimeResponse.
 * @export
 * @interface UtcTimeResponse
 */
export interface UtcTimeResponse {
    /**
     * Gets or sets the UTC time when request has been received.
     * @type {string}
     * @memberof UtcTimeResponse
     */
    RequestReceptionTime?: string | null;
    /**
     * Gets or sets the UTC time when response has been sent.
     * @type {string}
     * @memberof UtcTimeResponse
     */
    ResponseTransmissionTime?: string | null;
}
/**
 * Validate path object.
 * @export
 * @interface ValidatePathDto
 */
export interface ValidatePathDto {
    /**
     * Gets or sets a value indicating whether validate if path is writable.
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    ValidateWritable?: boolean;
    /**
     * Gets or sets the path.
     * @type {string}
     * @memberof ValidatePathDto
     */
    Path?: string | null;
    /**
     * Gets or sets is path file.
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    IsFile?: boolean | null;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Major?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Minor?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Build?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Revision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MajorRevision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MinorRevision?: number;
}
/**
 * Class PackageVersionInfo.
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * Gets or sets the version.
     * @type {string}
     * @memberof VersionInfo
     */
    version?: string | null;
    /**
     * Gets or sets the changelog for this version.
     * @type {string}
     * @memberof VersionInfo
     */
    changelog?: string | null;
    /**
     * Gets or sets the ABI that this version was built against.
     * @type {string}
     * @memberof VersionInfo
     */
    targetAbi?: string | null;
    /**
     * Gets or sets the source URL.
     * @type {string}
     * @memberof VersionInfo
     */
    sourceUrl?: string | null;
    /**
     * Gets or sets a checksum for the binary.
     * @type {string}
     * @memberof VersionInfo
     */
    checksum?: string | null;
    /**
     * Gets or sets a timestamp of when the binary was built.
     * @type {string}
     * @memberof VersionInfo
     */
    timestamp?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Video3DFormat {
    HalfSideBySide = 'HalfSideBySide',
    FullSideBySide = 'FullSideBySide',
    FullTopAndBottom = 'FullTopAndBottom',
    HalfTopAndBottom = 'HalfTopAndBottom',
    MVC = 'MVC'
}

/**
 * Enum VideoType.
 * @export
 * @enum {string}
 */
export enum VideoType {
    VideoFile = 'VideoFile',
    Iso = 'Iso',
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * Used to hold information about a user\'s list of configured virtual folders.
 * @export
 * @interface VirtualFolderInfo
 */
export interface VirtualFolderInfo {
    /**
     * Gets or sets the name.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    Name?: string | null;
    /**
     * Gets or sets the locations.
     * @type {Array<string>}
     * @memberof VirtualFolderInfo
     */
    Locations?: Array<string> | null;
    /**
     * Gets or sets the type of the collection.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    CollectionType?: string | null;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof VirtualFolderInfo
     */
    LibraryOptions?: LibraryOptions;
    /**
     * Gets or sets the item identifier.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    ItemId?: string | null;
    /**
     * Gets or sets the primary image item identifier.
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    PrimaryImageItemId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VirtualFolderInfo
     */
    RefreshProgress?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    RefreshStatus?: string | null;
}
/**
 * Provides the MAC address and port for wake-on-LAN functionality.
 * @export
 * @interface WakeOnLanInfo
 */
export interface WakeOnLanInfo {
    /**
     * Gets the MAC address of the device.
     * @type {string}
     * @memberof WakeOnLanInfo
     */
    MacAddress?: string | null;
    /**
     * Gets or sets the wake-on-LAN port.
     * @type {number}
     * @memberof WakeOnLanInfo
     */
    Port?: number;
}
/**
 * 
 * @export
 * @interface XmlAttribute
 */
export interface XmlAttribute {
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Value?: string | null;
}

/**
 * ActivityLogApi - axios parameter creator
 * @export
 */
export const ActivityLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries: async (startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/ActivityLog/Entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = (minDate as any instanceof Date) ?
                    (minDate as any).toISOString() :
                    minDate;
            }

            if (hasUserId !== undefined) {
                localVarQueryParameter['hasUserId'] = hasUserId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogApi - functional programming interface
 * @export
 */
export const ActivityLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogEntryQueryResult>> {
            const localVarAxiosArgs = await ActivityLogApiAxiosParamCreator(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActivityLogApi - factory interface
 * @export
 */
export const ActivityLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets activity log entries.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [minDate] Optional. The minimum date. Format &#x3D; ISO.
         * @param {boolean} [hasUserId] Optional. Filter log entries if it has user id, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): AxiosPromise<ActivityLogEntryQueryResult> {
            return ActivityLogApiFp(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLogEntries operation in ActivityLogApi.
 * @export
 * @interface ActivityLogApiGetLogEntriesRequest
 */
export interface ActivityLogApiGetLogEntriesRequest {
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly limit?: number

    /**
     * Optional. The minimum date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly minDate?: string

    /**
     * Optional. Filter log entries if it has user id, or not.
     * @type {boolean}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly hasUserId?: boolean
}

/**
 * ActivityLogApi - object-oriented interface
 * @export
 * @class ActivityLogApi
 * @extends {BaseAPI}
 */
export class ActivityLogApi extends BaseAPI {
    /**
     * 
     * @summary Gets activity log entries.
     * @param {ActivityLogApiGetLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public getLogEntries(requestParameters: ActivityLogApiGetLogEntriesRequest = {}, options?: any) {
        return ActivityLogApiFp(this.configuration).getLogEntries(requestParameters.startIndex, requestParameters.limit, requestParameters.minDate, requestParameters.hasUserId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (app: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling createKey.');
            }
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling revokeKey.');
            }
            const localVarPath = `/Auth/Keys/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(app: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createKey(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationInfoQueryResult>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeKey(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).revokeKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a new api key.
         * @param {string} app Name of the app using the authentication key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(app: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).createKey(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<AuthenticationInfoQueryResult> {
            return ApiKeyApiFp(configuration).getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an api key.
         * @param {string} key The access token to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey(key: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).revokeKey(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createKey operation in ApiKeyApi.
 * @export
 * @interface ApiKeyApiCreateKeyRequest
 */
export interface ApiKeyApiCreateKeyRequest {
    /**
     * Name of the app using the authentication key.
     * @type {string}
     * @memberof ApiKeyApiCreateKey
     */
    readonly app: string
}

/**
 * Request parameters for revokeKey operation in ApiKeyApi.
 * @export
 * @interface ApiKeyApiRevokeKeyRequest
 */
export interface ApiKeyApiRevokeKeyRequest {
    /**
     * The access token to delete.
     * @type {string}
     * @memberof ApiKeyApiRevokeKey
     */
    readonly key: string
}

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @summary Create a new api key.
     * @param {ApiKeyApiCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createKey(requestParameters: ApiKeyApiCreateKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).createKey(requestParameters.app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getKeys(options?: any) {
        return ApiKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an api key.
     * @param {ApiKeyApiRevokeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public revokeKey(requestParameters: ApiKeyApiRevokeKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).revokeKey(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtistsApi - axios parameter creator
 * @export
 */
export const ArtistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists/AlbumArtists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistByName.');
            }
            const localVarPath = `/Artists/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtistsApi - functional programming interface
 * @export
 */
export const ArtistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistByName(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtistByName(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtistsApi - factory interface
 * @export
 */
export const ArtistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets all album artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an artist by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return ArtistsApiFp(configuration).getArtistByName(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all artists from a given item, folder, or the entire library.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person ids.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAlbumArtists operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetAlbumArtistsRequest
 */
export interface ArtistsApiGetAlbumArtistsRequest {
    /**
     * Optional filter by minimum community rating.
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly minCommunityRating?: number

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly limit?: number

    /**
     * Optional. Search term.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Specify additional filters to apply.
     * @type {Array<ItemFilter>}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly isFavorite?: boolean

    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly mediaTypes?: string

    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly genres?: string

    /**
     * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly genreIds?: string

    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly officialRatings?: string

    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly tags?: string

    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly years?: string

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly person?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person ids.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly personIds?: string

    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly studios?: string

    /**
     * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly studioIds?: string

    /**
     * User id.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly userId?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameLessThan?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableImages?: boolean

    /**
     * Total record count.
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getArtistByName operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetArtistByNameRequest
 */
export interface ArtistsApiGetArtistByNameRequest {
    /**
     * Studio name.
     * @type {string}
     * @memberof ArtistsApiGetArtistByName
     */
    readonly name: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof ArtistsApiGetArtistByName
     */
    readonly userId?: string
}

/**
 * Request parameters for getArtists operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetArtistsRequest
 */
export interface ArtistsApiGetArtistsRequest {
    /**
     * Optional filter by minimum community rating.
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly minCommunityRating?: number

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly limit?: number

    /**
     * Optional. Search term.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof ArtistsApiGetArtists
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Specify additional filters to apply.
     * @type {Array<ItemFilter>}
     * @memberof ArtistsApiGetArtists
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly isFavorite?: boolean

    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly mediaTypes?: string

    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly genres?: string

    /**
     * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly genreIds?: string

    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly officialRatings?: string

    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly tags?: string

    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly years?: string

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly person?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person ids.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly personIds?: string

    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly studios?: string

    /**
     * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly studioIds?: string

    /**
     * User id.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly userId?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameLessThan?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableImages?: boolean

    /**
     * Total record count.
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * ArtistsApi - object-oriented interface
 * @export
 * @class ArtistsApi
 * @extends {BaseAPI}
 */
export class ArtistsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all album artists from a given item, folder, or the entire library.
     * @param {ArtistsApiGetAlbumArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getAlbumArtists(requestParameters: ArtistsApiGetAlbumArtistsRequest = {}, options?: any) {
        return ArtistsApiFp(this.configuration).getAlbumArtists(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an artist by name.
     * @param {ArtistsApiGetArtistByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtistByName(requestParameters: ArtistsApiGetArtistByNameRequest, options?: any) {
        return ArtistsApiFp(this.configuration).getArtistByName(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all artists from a given item, folder, or the entire library.
     * @param {ArtistsApiGetArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtists(requestParameters: ArtistsApiGetArtistsRequest = {}, options?: any) {
        return ArtistsApiFp(this.configuration).getArtists(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} container The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return AudioApiFp(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAudioStream operation in AudioApi.
 * @export
 * @interface AudioApiGetAudioStreamRequest
 */
export interface AudioApiGetAudioStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly itemId: string

    /**
     * The audio container.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof AudioApiGetAudioStream
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiGetAudioStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getAudioStreamByContainer operation in AudioApi.
 * @export
 * @interface AudioApiGetAudioStreamByContainerRequest
 */
export interface AudioApiGetAudioStreamByContainerRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly itemId: string

    /**
     * The audio container.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headAudioStream operation in AudioApi.
 * @export
 * @interface AudioApiHeadAudioStreamRequest
 */
export interface AudioApiHeadAudioStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly itemId: string

    /**
     * The audio container.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof AudioApiHeadAudioStream
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiHeadAudioStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headAudioStreamByContainer operation in AudioApi.
 * @export
 * @interface AudioApiHeadAudioStreamByContainerRequest
 */
export interface AudioApiHeadAudioStreamByContainerRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly itemId: string

    /**
     * The audio container.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
    /**
     * 
     * @summary Gets an audio stream.
     * @param {AudioApiGetAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStream(requestParameters: AudioApiGetAudioStreamRequest, options?: any) {
        return AudioApiFp(this.configuration).getAudioStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {AudioApiGetAudioStreamByContainerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStreamByContainer(requestParameters: AudioApiGetAudioStreamByContainerRequest, options?: any) {
        return AudioApiFp(this.configuration).getAudioStreamByContainer(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {AudioApiHeadAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStream(requestParameters: AudioApiHeadAudioStreamRequest, options?: any) {
        return AudioApiFp(this.configuration).headAudioStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {AudioApiHeadAudioStreamByContainerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStreamByContainer(requestParameters: AudioApiHeadAudioStreamByContainerRequest, options?: any) {
        return AudioApiFp(this.configuration).headAudioStreamByContainer(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css.css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingOptions>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets branding css.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets branding configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions(options?: any): AxiosPromise<BrandingOptions> {
            return BrandingApiFp(configuration).getBrandingOptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * 
     * @summary Gets branding css.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets branding css.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss2(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets branding configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingOptions(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingOptions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelFeatures.');
            }
            const localVarPath = `/Channels/{channelId}/Features`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems: async (channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: Array<ItemFilter>, sortBy?: string, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelItems.');
            }
            const localVarPath = `/Channels/{channelId}/Items`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (supportsLatestItems !== undefined) {
                localVarQueryParameter['supportsLatestItems'] = supportsLatestItems;
            }

            if (supportsMediaDeletion !== undefined) {
                localVarQueryParameter['supportsMediaDeletion'] = supportsMediaDeletion;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems: async (userId?: string, startIndex?: number, limit?: number, filters?: Array<ItemFilter>, fields?: Array<ItemFields>, channelIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Items/Latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllChannelFeatures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelFeatures>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getAllChannelFeatures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelFeatures(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelFeatures>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelFeatures(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: Array<ItemFilter>, sortBy?: string, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: Array<ItemFilter>, fields?: Array<ItemFields>, channelIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get all channel features.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures(options?: any): AxiosPromise<Array<ChannelFeatures>> {
            return ChannelsApiFp(configuration).getAllChannelFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel features.
         * @param {string} channelId Channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures(channelId: string, options?: any): AxiosPromise<ChannelFeatures> {
            return ChannelsApiFp(configuration).getChannelFeatures(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel items.
         * @param {string} channelId Channel Id.
         * @param {string} [folderId] Optional. Folder Id.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Optional. Sort Order - Ascending,Descending.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: Array<ItemFilter>, sortBy?: string, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available channels.
         * @param {string} [userId] User Id to filter by. Use System.Guid.Empty to not filter by user.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [supportsLatestItems] Optional. Filter by channels that support getting latest items.
         * @param {boolean} [supportsMediaDeletion] Optional. Filter by channels that support media deletion.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets latest channel items.
         * @param {string} [userId] Optional. User Id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [channelIds] Optional. Specify one or more channel id\&#39;s, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: Array<ItemFilter>, fields?: Array<ItemFields>, channelIds?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChannelFeatures operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelFeaturesRequest
 */
export interface ChannelsApiGetChannelFeaturesRequest {
    /**
     * Channel id.
     * @type {string}
     * @memberof ChannelsApiGetChannelFeatures
     */
    readonly channelId: string
}

/**
 * Request parameters for getChannelItems operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelItemsRequest
 */
export interface ChannelsApiGetChannelItemsRequest {
    /**
     * Channel Id.
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly channelId: string

    /**
     * Optional. Folder Id.
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly folderId?: string

    /**
     * Optional. User Id.
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly limit?: number

    /**
     * Optional. Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly sortOrder?: string

    /**
     * Optional. Specify additional filters to apply.
     * @type {Array<ItemFilter>}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly sortBy?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getChannels operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelsRequest
 */
export interface ChannelsApiGetChannelsRequest {
    /**
     * User Id to filter by. Use System.Guid.Empty to not filter by user.
     * @type {string}
     * @memberof ChannelsApiGetChannels
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ChannelsApiGetChannels
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ChannelsApiGetChannels
     */
    readonly limit?: number

    /**
     * Optional. Filter by channels that support getting latest items.
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly supportsLatestItems?: boolean

    /**
     * Optional. Filter by channels that support media deletion.
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly supportsMediaDeletion?: boolean

    /**
     * Optional. Filter by channels that are favorite.
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly isFavorite?: boolean
}

/**
 * Request parameters for getLatestChannelItems operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetLatestChannelItemsRequest
 */
export interface ChannelsApiGetLatestChannelItemsRequest {
    /**
     * Optional. User Id.
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly limit?: number

    /**
     * Optional. Specify additional filters to apply.
     * @type {Array<ItemFilter>}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Specify one or more channel id\&#39;s, comma delimited.
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly channelIds?: string
}

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * 
     * @summary Get all channel features.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getAllChannelFeatures(options?: any) {
        return ChannelsApiFp(this.configuration).getAllChannelFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel features.
     * @param {ChannelsApiGetChannelFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelFeatures(requestParameters: ChannelsApiGetChannelFeaturesRequest, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelFeatures(requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel items.
     * @param {ChannelsApiGetChannelItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelItems(requestParameters: ChannelsApiGetChannelItemsRequest, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelItems(requestParameters.channelId, requestParameters.folderId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.sortOrder, requestParameters.filters, requestParameters.sortBy, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available channels.
     * @param {ChannelsApiGetChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannels(requestParameters: ChannelsApiGetChannelsRequest = {}, options?: any) {
        return ChannelsApiFp(this.configuration).getChannels(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.supportsLatestItems, requestParameters.supportsMediaDeletion, requestParameters.isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets latest channel items.
     * @param {ChannelsApiGetLatestChannelItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getLatestChannelItems(requestParameters: ChannelsApiGetLatestChannelItemsRequest = {}, options?: any) {
        return ChannelsApiFp(this.configuration).getLatestChannelItems(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.filters, requestParameters.fields, requestParameters.channelIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection: async (collectionId: string, ids: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling addToCollection.');
            }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling addToCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (name?: string, ids?: string, parentId?: string, isLocked?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection: async (collectionId: string, ids: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling removeFromCollection.');
            }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling removeFromCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToCollection(collectionId: string, ids: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).addToCollection(collectionId, ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionCreationResult>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).createCollection(name, ids, parentId, isLocked, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromCollection(collectionId: string, ids: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).removeFromCollection(collectionId, ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds items to a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection(collectionId: string, ids: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).addToCollection(collectionId, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new collection.
         * @param {string} [name] The name of the collection.
         * @param {string} [ids] Item Ids to add to the collection.
         * @param {string} [parentId] Optional. Create the collection within a specific folder.
         * @param {boolean} [isLocked] Whether or not to lock the new collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): AxiosPromise<CollectionCreationResult> {
            return CollectionApiFp(configuration).createCollection(name, ids, parentId, isLocked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes items from a collection.
         * @param {string} collectionId The collection id.
         * @param {string} ids Item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection(collectionId: string, ids: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).removeFromCollection(collectionId, ids, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addToCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiAddToCollectionRequest
 */
export interface CollectionApiAddToCollectionRequest {
    /**
     * The collection id.
     * @type {string}
     * @memberof CollectionApiAddToCollection
     */
    readonly collectionId: string

    /**
     * Item ids, comma delimited.
     * @type {string}
     * @memberof CollectionApiAddToCollection
     */
    readonly ids: string
}

/**
 * Request parameters for createCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiCreateCollectionRequest
 */
export interface CollectionApiCreateCollectionRequest {
    /**
     * The name of the collection.
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly name?: string

    /**
     * Item Ids to add to the collection.
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly ids?: string

    /**
     * Optional. Create the collection within a specific folder.
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly parentId?: string

    /**
     * Whether or not to lock the new collection.
     * @type {boolean}
     * @memberof CollectionApiCreateCollection
     */
    readonly isLocked?: boolean
}

/**
 * Request parameters for removeFromCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiRemoveFromCollectionRequest
 */
export interface CollectionApiRemoveFromCollectionRequest {
    /**
     * The collection id.
     * @type {string}
     * @memberof CollectionApiRemoveFromCollection
     */
    readonly collectionId: string

    /**
     * Item ids, comma delimited.
     * @type {string}
     * @memberof CollectionApiRemoveFromCollection
     */
    readonly ids: string
}

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @summary Adds items to a collection.
     * @param {CollectionApiAddToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public addToCollection(requestParameters: CollectionApiAddToCollectionRequest, options?: any) {
        return CollectionApiFp(this.configuration).addToCollection(requestParameters.collectionId, requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new collection.
     * @param {CollectionApiCreateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(requestParameters: CollectionApiCreateCollectionRequest = {}, options?: any) {
        return CollectionApiFp(this.configuration).createCollection(requestParameters.name, requestParameters.ids, requestParameters.parentId, requestParameters.isLocked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes items from a collection.
     * @param {CollectionApiRemoveFromCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeFromCollection(requestParameters: CollectionApiRemoveFromCollectionRequest, options?: any) {
        return CollectionApiFp(this.configuration).removeFromCollection(requestParameters.collectionId, requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration/MetadataOptions/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration: async (serverConfiguration: ServerConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverConfiguration' is not null or undefined
            if (serverConfiguration === null || serverConfiguration === undefined) {
                throw new RequiredError('serverConfiguration','Required parameter serverConfiguration was null or undefined when calling updateConfiguration.');
            }
            const localVarPath = `/System/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof serverConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(serverConfiguration !== undefined ? serverConfiguration : {}) : (serverConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath: async (mediaEncoderPathDto: MediaEncoderPathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaEncoderPathDto' is not null or undefined
            if (mediaEncoderPathDto === null || mediaEncoderPathDto === undefined) {
                throw new RequiredError('mediaEncoderPathDto','Required parameter mediaEncoderPathDto was null or undefined when calling updateMediaEncoderPath.');
            }
            const localVarPath = `/System/MediaEncoder/Path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaEncoderPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaEncoderPathDto !== undefined ? mediaEncoderPathDto : {}) : (mediaEncoderPathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfiguration>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultMetadataOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataOptions>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getDefaultMetadataOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateConfiguration(serverConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets application configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any): AxiosPromise<ServerConfiguration> {
            return ConfigurationApiFp(configuration).getConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a default MetadataOptions object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions(options?: any): AxiosPromise<MetadataOptions> {
            return ConfigurationApiFp(configuration).getDefaultMetadataOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration(key: string, options?: any): AxiosPromise<any> {
            return ConfigurationApiFp(configuration).getNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates application configuration.
         * @param {ServerConfiguration} serverConfiguration Configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateConfiguration(serverConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the path to the media encoder.
         * @param {MediaEncoderPathDto} mediaEncoderPathDto Media encoder path form body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates named configuration.
         * @param {string} key Configuration key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration(key: string, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNamedConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiGetNamedConfigurationRequest
 */
export interface ConfigurationApiGetNamedConfigurationRequest {
    /**
     * Configuration key.
     * @type {string}
     * @memberof ConfigurationApiGetNamedConfiguration
     */
    readonly key: string
}

/**
 * Request parameters for updateConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateConfigurationRequest
 */
export interface ConfigurationApiUpdateConfigurationRequest {
    /**
     * Configuration.
     * @type {ServerConfiguration}
     * @memberof ConfigurationApiUpdateConfiguration
     */
    readonly serverConfiguration: ServerConfiguration
}

/**
 * Request parameters for updateMediaEncoderPath operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateMediaEncoderPathRequest
 */
export interface ConfigurationApiUpdateMediaEncoderPathRequest {
    /**
     * Media encoder path form body.
     * @type {MediaEncoderPathDto}
     * @memberof ConfigurationApiUpdateMediaEncoderPath
     */
    readonly mediaEncoderPathDto: MediaEncoderPathDto
}

/**
 * Request parameters for updateNamedConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateNamedConfigurationRequest
 */
export interface ConfigurationApiUpdateNamedConfigurationRequest {
    /**
     * Configuration key.
     * @type {string}
     * @memberof ConfigurationApiUpdateNamedConfiguration
     */
    readonly key: string
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary Gets application configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getConfiguration(options?: any) {
        return ConfigurationApiFp(this.configuration).getConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a default MetadataOptions object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getDefaultMetadataOptions(options?: any) {
        return ConfigurationApiFp(this.configuration).getDefaultMetadataOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a named configuration.
     * @param {ConfigurationApiGetNamedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getNamedConfiguration(requestParameters: ConfigurationApiGetNamedConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).getNamedConfiguration(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates application configuration.
     * @param {ConfigurationApiUpdateConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateConfiguration(requestParameters: ConfigurationApiUpdateConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateConfiguration(requestParameters.serverConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the path to the media encoder.
     * @param {ConfigurationApiUpdateMediaEncoderPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateMediaEncoderPath(requestParameters: ConfigurationApiUpdateMediaEncoderPathRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateMediaEncoderPath(requestParameters.mediaEncoderPathDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates named configuration.
     * @param {ConfigurationApiUpdateNamedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateNamedConfiguration(requestParameters: ConfigurationApiUpdateNamedConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateNamedConfiguration(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages: async (enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (enableInMainMenu !== undefined) {
                localVarQueryParameter['enableInMainMenu'] = enableInMainMenu;
            }

            if (pageType !== undefined) {
                localVarQueryParameter['pageType'] = pageType;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationPageInfo>>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getConfigurationPages(enableInMainMenu, pageType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardConfigurationPage(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getDashboardConfigurationPage(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the configuration pages.
         * @param {boolean} [enableInMainMenu] Whether to enable in the main menu.
         * @param {ConfigurationPageType} [pageType] The Jellyfin.Api.Models.ConfigurationPageInfo.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): AxiosPromise<Array<ConfigurationPageInfo>> {
            return DashboardApiFp(configuration).getConfigurationPages(enableInMainMenu, pageType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a dashboard configuration page.
         * @param {string} [name] The name of the page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage(name?: string, options?: any): AxiosPromise<any> {
            return DashboardApiFp(configuration).getDashboardConfigurationPage(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConfigurationPages operation in DashboardApi.
 * @export
 * @interface DashboardApiGetConfigurationPagesRequest
 */
export interface DashboardApiGetConfigurationPagesRequest {
    /**
     * Whether to enable in the main menu.
     * @type {boolean}
     * @memberof DashboardApiGetConfigurationPages
     */
    readonly enableInMainMenu?: boolean

    /**
     * The Jellyfin.Api.Models.ConfigurationPageInfo.
     * @type {ConfigurationPageType}
     * @memberof DashboardApiGetConfigurationPages
     */
    readonly pageType?: ConfigurationPageType
}

/**
 * Request parameters for getDashboardConfigurationPage operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardConfigurationPageRequest
 */
export interface DashboardApiGetDashboardConfigurationPageRequest {
    /**
     * The name of the page.
     * @type {string}
     * @memberof DashboardApiGetDashboardConfigurationPage
     */
    readonly name?: string
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Gets the configuration pages.
     * @param {DashboardApiGetConfigurationPagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getConfigurationPages(requestParameters: DashboardApiGetConfigurationPagesRequest = {}, options?: any) {
        return DashboardApiFp(this.configuration).getConfigurationPages(requestParameters.enableInMainMenu, requestParameters.pageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a dashboard configuration page.
     * @param {DashboardApiGetDashboardConfigurationPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardConfigurationPage(requestParameters: DashboardApiGetDashboardConfigurationPageRequest = {}, options?: any) {
        return DashboardApiFp(this.configuration).getDashboardConfigurationPage(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDevice.');
            }
            const localVarPath = `/Devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceInfo.');
            }
            const localVarPath = `/Devices/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (supportsSync?: boolean, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions: async (id: string, deviceOptions: DeviceOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDeviceOptions.');
            }
            // verify required parameter 'deviceOptions' is not null or undefined
            if (deviceOptions === null || deviceOptions === undefined) {
                throw new RequiredError('deviceOptions','Required parameter deviceOptions was null or undefined when calling updateDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceOptions !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceOptions !== undefined ? deviceOptions : {}) : (deviceOptions || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).deleteDevice(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInfo(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfo>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceInfo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceOptions(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceOptions>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceOptions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(supportsSync?: boolean, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoQueryResult>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDevices(supportsSync, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).updateDeviceOptions(id, deviceOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: string, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).deleteDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get info for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo(id: string, options?: any): AxiosPromise<DeviceInfo> {
            return DevicesApiFp(configuration).getDeviceInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options for a device.
         * @param {string} id Device Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions(id: string, options?: any): AxiosPromise<DeviceOptions> {
            return DevicesApiFp(configuration).getDeviceOptions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Devices.
         * @param {boolean} [supportsSync] Gets or sets a value indicating whether [supports synchronize].
         * @param {string} [userId] Gets or sets the user identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(supportsSync?: boolean, userId?: string, options?: any): AxiosPromise<DeviceInfoQueryResult> {
            return DevicesApiFp(configuration).getDevices(supportsSync, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update device options.
         * @param {string} id Device Id.
         * @param {DeviceOptions} deviceOptions Device Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).updateDeviceOptions(id, deviceOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteDevice operation in DevicesApi.
 * @export
 * @interface DevicesApiDeleteDeviceRequest
 */
export interface DevicesApiDeleteDeviceRequest {
    /**
     * Device Id.
     * @type {string}
     * @memberof DevicesApiDeleteDevice
     */
    readonly id: string
}

/**
 * Request parameters for getDeviceInfo operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDeviceInfoRequest
 */
export interface DevicesApiGetDeviceInfoRequest {
    /**
     * Device Id.
     * @type {string}
     * @memberof DevicesApiGetDeviceInfo
     */
    readonly id: string
}

/**
 * Request parameters for getDeviceOptions operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDeviceOptionsRequest
 */
export interface DevicesApiGetDeviceOptionsRequest {
    /**
     * Device Id.
     * @type {string}
     * @memberof DevicesApiGetDeviceOptions
     */
    readonly id: string
}

/**
 * Request parameters for getDevices operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDevicesRequest
 */
export interface DevicesApiGetDevicesRequest {
    /**
     * Gets or sets a value indicating whether [supports synchronize].
     * @type {boolean}
     * @memberof DevicesApiGetDevices
     */
    readonly supportsSync?: boolean

    /**
     * Gets or sets the user identifier.
     * @type {string}
     * @memberof DevicesApiGetDevices
     */
    readonly userId?: string
}

/**
 * Request parameters for updateDeviceOptions operation in DevicesApi.
 * @export
 * @interface DevicesApiUpdateDeviceOptionsRequest
 */
export interface DevicesApiUpdateDeviceOptionsRequest {
    /**
     * Device Id.
     * @type {string}
     * @memberof DevicesApiUpdateDeviceOptions
     */
    readonly id: string

    /**
     * Device Options.
     * @type {DeviceOptions}
     * @memberof DevicesApiUpdateDeviceOptions
     */
    readonly deviceOptions: DeviceOptions
}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a device.
     * @param {DevicesApiDeleteDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(requestParameters: DevicesApiDeleteDeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).deleteDevice(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get info for a device.
     * @param {DevicesApiGetDeviceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceInfo(requestParameters: DevicesApiGetDeviceInfoRequest, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceInfo(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options for a device.
     * @param {DevicesApiGetDeviceOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceOptions(requestParameters: DevicesApiGetDeviceOptionsRequest, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceOptions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Devices.
     * @param {DevicesApiGetDevicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(requestParameters: DevicesApiGetDevicesRequest = {}, options?: any) {
        return DevicesApiFp(this.configuration).getDevices(requestParameters.supportsSync, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update device options.
     * @param {DevicesApiUpdateDeviceOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceOptions(requestParameters: DevicesApiUpdateDeviceOptionsRequest, options?: any) {
        return DevicesApiFp(this.configuration).updateDeviceOptions(requestParameters.id, requestParameters.deviceOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisplayPreferencesApi - axios parameter creator
 * @export
 */
export const DisplayPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling getDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'displayPreferencesDto' is not null or undefined
            if (displayPreferencesDto === null || displayPreferencesDto === undefined) {
                throw new RequiredError('displayPreferencesDto','Required parameter displayPreferencesDto was null or undefined when calling updateDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof displayPreferencesDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(displayPreferencesDto !== undefined ? displayPreferencesDto : {}) : (displayPreferencesDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisplayPreferencesApi - functional programming interface
 * @export
 */
export const DisplayPreferencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisplayPreferencesDto>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DisplayPreferencesApi - factory interface
 * @export
 */
export const DisplayPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User id.
         * @param {string} client Client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): AxiosPromise<DisplayPreferencesDto> {
            return DisplayPreferencesApiFp(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Display Preferences.
         * @param {string} displayPreferencesId Display preferences id.
         * @param {string} userId User Id.
         * @param {string} client Client.
         * @param {DisplayPreferencesDto} displayPreferencesDto New Display Preferences object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): AxiosPromise<void> {
            return DisplayPreferencesApiFp(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDisplayPreferences operation in DisplayPreferencesApi.
 * @export
 * @interface DisplayPreferencesApiGetDisplayPreferencesRequest
 */
export interface DisplayPreferencesApiGetDisplayPreferencesRequest {
    /**
     * Display preferences id.
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly displayPreferencesId: string

    /**
     * User id.
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly userId: string

    /**
     * Client.
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly client: string
}

/**
 * Request parameters for updateDisplayPreferences operation in DisplayPreferencesApi.
 * @export
 * @interface DisplayPreferencesApiUpdateDisplayPreferencesRequest
 */
export interface DisplayPreferencesApiUpdateDisplayPreferencesRequest {
    /**
     * Display preferences id.
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly displayPreferencesId: string

    /**
     * User Id.
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly userId: string

    /**
     * Client.
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly client: string

    /**
     * New Display Preferences object.
     * @type {DisplayPreferencesDto}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly displayPreferencesDto: DisplayPreferencesDto
}

/**
 * DisplayPreferencesApi - object-oriented interface
 * @export
 * @class DisplayPreferencesApi
 * @extends {BaseAPI}
 */
export class DisplayPreferencesApi extends BaseAPI {
    /**
     * 
     * @summary Get Display Preferences.
     * @param {DisplayPreferencesApiGetDisplayPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public getDisplayPreferences(requestParameters: DisplayPreferencesApiGetDisplayPreferencesRequest, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).getDisplayPreferences(requestParameters.displayPreferencesId, requestParameters.userId, requestParameters.client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Display Preferences.
     * @param {DisplayPreferencesApiUpdateDisplayPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public updateDisplayPreferences(requestParameters: DisplayPreferencesApiUpdateDisplayPreferencesRequest, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).updateDisplayPreferences(requestParameters.displayPreferencesId, requestParameters.userId, requestParameters.client, requestParameters.displayPreferencesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaApi - axios parameter creator
 * @export
 */
export const DlnaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling deleteProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling getProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/ProfileInfos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (profileId: string, deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaApi - functional programming interface
 * @export
 */
export const DlnaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).createProfile(deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).deleteProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getDefaultProfile(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInfos(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceProfileInfo>>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfileInfos(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).updateProfile(profileId, deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaApi - factory interface
 * @export
 */
export const DlnaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates a profile.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).createProfile(deviceProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a profile.
         * @param {string} profileId Profile id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(profileId: string, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).deleteProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile(options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getDefaultProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a single profile.
         * @param {string} profileId Profile Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileId: string, options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get profile infos.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos(options?: any): AxiosPromise<Array<DeviceProfileInfo>> {
            return DlnaApiFp(configuration).getProfileInfos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a profile.
         * @param {string} profileId Profile id.
         * @param {DeviceProfile} [deviceProfile] Device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).updateProfile(profileId, deviceProfile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiCreateProfileRequest
 */
export interface DlnaApiCreateProfileRequest {
    /**
     * Device profile.
     * @type {DeviceProfile}
     * @memberof DlnaApiCreateProfile
     */
    readonly deviceProfile?: DeviceProfile
}

/**
 * Request parameters for deleteProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiDeleteProfileRequest
 */
export interface DlnaApiDeleteProfileRequest {
    /**
     * Profile id.
     * @type {string}
     * @memberof DlnaApiDeleteProfile
     */
    readonly profileId: string
}

/**
 * Request parameters for getProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiGetProfileRequest
 */
export interface DlnaApiGetProfileRequest {
    /**
     * Profile Id.
     * @type {string}
     * @memberof DlnaApiGetProfile
     */
    readonly profileId: string
}

/**
 * Request parameters for updateProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiUpdateProfileRequest
 */
export interface DlnaApiUpdateProfileRequest {
    /**
     * Profile id.
     * @type {string}
     * @memberof DlnaApiUpdateProfile
     */
    readonly profileId: string

    /**
     * Device profile.
     * @type {DeviceProfile}
     * @memberof DlnaApiUpdateProfile
     */
    readonly deviceProfile?: DeviceProfile
}

/**
 * DlnaApi - object-oriented interface
 * @export
 * @class DlnaApi
 * @extends {BaseAPI}
 */
export class DlnaApi extends BaseAPI {
    /**
     * 
     * @summary Creates a profile.
     * @param {DlnaApiCreateProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public createProfile(requestParameters: DlnaApiCreateProfileRequest = {}, options?: any) {
        return DlnaApiFp(this.configuration).createProfile(requestParameters.deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a profile.
     * @param {DlnaApiDeleteProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public deleteProfile(requestParameters: DlnaApiDeleteProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).deleteProfile(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getDefaultProfile(options?: any) {
        return DlnaApiFp(this.configuration).getDefaultProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a single profile.
     * @param {DlnaApiGetProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfile(requestParameters: DlnaApiGetProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).getProfile(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get profile infos.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfileInfos(options?: any) {
        return DlnaApiFp(this.configuration).getProfileInfos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a profile.
     * @param {DlnaApiUpdateProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public updateProfile(requestParameters: DlnaApiUpdateProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).updateProfile(requestParameters.profileId, requestParameters.deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaServerApi - axios parameter creator
 * @export
 */
export const DlnaServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager2.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/ConnectionManager`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager3.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/ConnectionManager.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory2.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/ContentDirectory`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory3.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/ContentDirectory.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml.');
            }
            const localVarPath = `/Dlna/{serverId}/description`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml2.');
            }
            const localVarPath = `/Dlna/{serverId}/description.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon: async (fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIcon.');
            }
            const localVarPath = `/Dlna/icons/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId: async (serverId: string, fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getIconId.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIconId.');
            }
            const localVarPath = `/Dlna/{serverId}/icons/{fileName}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar2.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar3: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar3.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/MediaReceiverRegistrar.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processConnectionManagerControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processContentDirectoryControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processMediaReceiverRegistrarControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaServerApi - functional programming interface
 * @export
 */
export const DlnaServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcon(fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIcon(fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIconId(serverId: string, fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIconId(serverId, fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar3(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar3(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processConnectionManagerControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processConnectionManagerControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processContentDirectoryControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processContentDirectoryControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processMediaReceiverRegistrarControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaServerApi - factory interface
 * @export
 */
export const DlnaServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getConnectionManager3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna content directory xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getContentDirectory3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getDescriptionXml(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Description Xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getDescriptionXml2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(fileName: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getIcon(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a server icon.
         * @param {string} serverId Server UUID.
         * @param {string} fileName The icon filename.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId(serverId: string, fileName: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getIconId(serverId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets Dlna media receiver registrar xml.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar3(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar3(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a connection manager control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).processConnectionManagerControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a content directory control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).processContentDirectoryControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process a media receiver registrar control request.
         * @param {string} serverId Server UUID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): AxiosPromise<any> {
            return DlnaServerApiFp(configuration).processMediaReceiverRegistrarControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConnectionManager operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetConnectionManagerRequest
 */
export interface DlnaServerApiGetConnectionManagerRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetConnectionManager
     */
    readonly serverId: string
}

/**
 * Request parameters for getConnectionManager2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetConnectionManager2Request
 */
export interface DlnaServerApiGetConnectionManager2Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetConnectionManager2
     */
    readonly serverId: string
}

/**
 * Request parameters for getConnectionManager3 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetConnectionManager3Request
 */
export interface DlnaServerApiGetConnectionManager3Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetConnectionManager3
     */
    readonly serverId: string
}

/**
 * Request parameters for getContentDirectory operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetContentDirectoryRequest
 */
export interface DlnaServerApiGetContentDirectoryRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetContentDirectory
     */
    readonly serverId: string
}

/**
 * Request parameters for getContentDirectory2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetContentDirectory2Request
 */
export interface DlnaServerApiGetContentDirectory2Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetContentDirectory2
     */
    readonly serverId: string
}

/**
 * Request parameters for getContentDirectory3 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetContentDirectory3Request
 */
export interface DlnaServerApiGetContentDirectory3Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetContentDirectory3
     */
    readonly serverId: string
}

/**
 * Request parameters for getDescriptionXml operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetDescriptionXmlRequest
 */
export interface DlnaServerApiGetDescriptionXmlRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetDescriptionXml
     */
    readonly serverId: string
}

/**
 * Request parameters for getDescriptionXml2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetDescriptionXml2Request
 */
export interface DlnaServerApiGetDescriptionXml2Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetDescriptionXml2
     */
    readonly serverId: string
}

/**
 * Request parameters for getIcon operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetIconRequest
 */
export interface DlnaServerApiGetIconRequest {
    /**
     * The icon filename.
     * @type {string}
     * @memberof DlnaServerApiGetIcon
     */
    readonly fileName: string
}

/**
 * Request parameters for getIconId operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetIconIdRequest
 */
export interface DlnaServerApiGetIconIdRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetIconId
     */
    readonly serverId: string

    /**
     * The icon filename.
     * @type {string}
     * @memberof DlnaServerApiGetIconId
     */
    readonly fileName: string
}

/**
 * Request parameters for getMediaReceiverRegistrar operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetMediaReceiverRegistrarRequest
 */
export interface DlnaServerApiGetMediaReceiverRegistrarRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetMediaReceiverRegistrar
     */
    readonly serverId: string
}

/**
 * Request parameters for getMediaReceiverRegistrar2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetMediaReceiverRegistrar2Request
 */
export interface DlnaServerApiGetMediaReceiverRegistrar2Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetMediaReceiverRegistrar2
     */
    readonly serverId: string
}

/**
 * Request parameters for getMediaReceiverRegistrar3 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetMediaReceiverRegistrar3Request
 */
export interface DlnaServerApiGetMediaReceiverRegistrar3Request {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiGetMediaReceiverRegistrar3
     */
    readonly serverId: string
}

/**
 * Request parameters for processConnectionManagerControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessConnectionManagerControlRequestRequest
 */
export interface DlnaServerApiProcessConnectionManagerControlRequestRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiProcessConnectionManagerControlRequest
     */
    readonly serverId: string
}

/**
 * Request parameters for processContentDirectoryControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessContentDirectoryControlRequestRequest
 */
export interface DlnaServerApiProcessContentDirectoryControlRequestRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiProcessContentDirectoryControlRequest
     */
    readonly serverId: string
}

/**
 * Request parameters for processMediaReceiverRegistrarControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest
 */
export interface DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest {
    /**
     * Server UUID.
     * @type {string}
     * @memberof DlnaServerApiProcessMediaReceiverRegistrarControlRequest
     */
    readonly serverId: string
}

/**
 * DlnaServerApi - object-oriented interface
 * @export
 * @class DlnaServerApi
 * @extends {BaseAPI}
 */
export class DlnaServerApi extends BaseAPI {
    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetConnectionManagerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager(requestParameters: DlnaServerApiGetConnectionManagerRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetConnectionManager2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager2(requestParameters: DlnaServerApiGetConnectionManager2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetConnectionManager3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager3(requestParameters: DlnaServerApiGetConnectionManager3Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager3(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {DlnaServerApiGetContentDirectoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory(requestParameters: DlnaServerApiGetContentDirectoryRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {DlnaServerApiGetContentDirectory2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory2(requestParameters: DlnaServerApiGetContentDirectory2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna content directory xml.
     * @param {DlnaServerApiGetContentDirectory3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory3(requestParameters: DlnaServerApiGetContentDirectory3Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory3(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Description Xml.
     * @param {DlnaServerApiGetDescriptionXmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml(requestParameters: DlnaServerApiGetDescriptionXmlRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Description Xml.
     * @param {DlnaServerApiGetDescriptionXml2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml2(requestParameters: DlnaServerApiGetDescriptionXml2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a server icon.
     * @param {DlnaServerApiGetIconRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIcon(requestParameters: DlnaServerApiGetIconRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getIcon(requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a server icon.
     * @param {DlnaServerApiGetIconIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIconId(requestParameters: DlnaServerApiGetIconIdRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getIconId(requestParameters.serverId, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetMediaReceiverRegistrarRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar(requestParameters: DlnaServerApiGetMediaReceiverRegistrarRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetMediaReceiverRegistrar2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar2(requestParameters: DlnaServerApiGetMediaReceiverRegistrar2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets Dlna media receiver registrar xml.
     * @param {DlnaServerApiGetMediaReceiverRegistrar3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar3(requestParameters: DlnaServerApiGetMediaReceiverRegistrar3Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar3(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a connection manager control request.
     * @param {DlnaServerApiProcessConnectionManagerControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processConnectionManagerControlRequest(requestParameters: DlnaServerApiProcessConnectionManagerControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processConnectionManagerControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a content directory control request.
     * @param {DlnaServerApiProcessContentDirectoryControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processContentDirectoryControlRequest(requestParameters: DlnaServerApiProcessContentDirectoryControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processContentDirectoryControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process a media receiver registrar control request.
     * @param {DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processMediaReceiverRegistrarControlRequest(requestParameters: DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processMediaReceiverRegistrarControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DynamicHlsApi - axios parameter creator
 * @export
 */
export const DynamicHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsAudioSegment.');
            }
            const localVarPath = `/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsVideoSegment.');
            }
            const localVarPath = `/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist: async (itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist: async (itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist: async (itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DynamicHlsApi - functional programming interface
 * @export
 */
export const DynamicHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsAudioPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsAudioPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsVideoPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsVideoPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DynamicHlsApi - factory interface
 * @export
 */
export const DynamicHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {number} segmentId The segment id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getVariantHlsAudioPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream using HTTP live streaming.
         * @param {string} itemId The item id.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist(itemId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).getVariantHlsVideoPlaylist(itemId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, maxStreamingBitrate?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).headMasterHlsAudioPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, maxStreamingBitrate, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video hls playlist stream.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media version id, if playing an alternate version.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {boolean} [enableAdaptiveBitrateStreaming] Enable adaptive bitrate streaming.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist(itemId: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<any> {
            return DynamicHlsApiFp(configuration).headMasterHlsVideoPlaylist(itemId, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHlsAudioSegment operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetHlsAudioSegmentRequest
 */
export interface DynamicHlsApiGetHlsAudioSegmentRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly itemId: string

    /**
     * The playlist id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly playlistId: string

    /**
     * The segment id.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentId: number

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getHlsVideoSegment operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetHlsVideoSegmentRequest
 */
export interface DynamicHlsApiGetHlsVideoSegmentRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly itemId: string

    /**
     * The playlist id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly playlistId: string

    /**
     * The segment id.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentId: number

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getMasterHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetMasterHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiGetMasterHlsAudioPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly mediaSourceId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * Enable adaptive bitrate streaming.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for getMasterHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetMasterHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiGetMasterHlsVideoPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly mediaSourceId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * Enable adaptive bitrate streaming.
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for getVariantHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetVariantHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiGetVariantHlsAudioPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getVariantHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetVariantHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiGetVariantHlsVideoPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headMasterHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiHeadMasterHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiHeadMasterHlsAudioPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly mediaSourceId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * Enable adaptive bitrate streaming.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for headMasterHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiHeadMasterHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiHeadMasterHlsVideoPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly mediaSourceId: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * Enable adaptive bitrate streaming.
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * DynamicHlsApi - object-oriented interface
 * @export
 * @class DynamicHlsApi
 * @extends {BaseAPI}
 */
export class DynamicHlsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {DynamicHlsApiGetHlsAudioSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsAudioSegment(requestParameters: DynamicHlsApiGetHlsAudioSegmentRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsAudioSegment(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {DynamicHlsApiGetHlsVideoSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsVideoSegment(requestParameters: DynamicHlsApiGetHlsVideoSegmentRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsVideoSegment(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio hls playlist stream.
     * @param {DynamicHlsApiGetMasterHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsAudioPlaylist(requestParameters: DynamicHlsApiGetMasterHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsAudioPlaylist(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video hls playlist stream.
     * @param {DynamicHlsApiGetMasterHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsVideoPlaylist(requestParameters: DynamicHlsApiGetMasterHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsVideoPlaylist(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream using HTTP live streaming.
     * @param {DynamicHlsApiGetVariantHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsAudioPlaylist(requestParameters: DynamicHlsApiGetVariantHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsAudioPlaylist(requestParameters.itemId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream using HTTP live streaming.
     * @param {DynamicHlsApiGetVariantHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsVideoPlaylist(requestParameters: DynamicHlsApiGetVariantHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsVideoPlaylist(requestParameters.itemId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio hls playlist stream.
     * @param {DynamicHlsApiHeadMasterHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsAudioPlaylist(requestParameters: DynamicHlsApiHeadMasterHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsAudioPlaylist(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video hls playlist stream.
     * @param {DynamicHlsApiHeadMasterHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsVideoPlaylist(requestParameters: DynamicHlsApiHeadMasterHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsVideoPlaylist(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/DefaultDirectoryBrowser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents: async (path: string, includeFiles?: boolean, includeDirectories?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getDirectoryContents.');
            }
            const localVarPath = `/Environment/DirectoryContents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (includeFiles !== undefined) {
                localVarQueryParameter['includeFiles'] = includeFiles;
            }

            if (includeDirectories !== undefined) {
                localVarQueryParameter['includeDirectories'] = includeDirectories;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/Drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/NetworkShares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath: async (path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getParentPath.');
            }
            const localVarPath = `/Environment/ParentPath`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath: async (validatePathDto: ValidatePathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatePathDto' is not null or undefined
            if (validatePathDto === null || validatePathDto === undefined) {
                throw new RequiredError('validatePathDto','Required parameter validatePathDto was null or undefined when calling validatePath.');
            }
            const localVarPath = `/Environment/ValidatePath`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validatePathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validatePathDto !== undefined ? validatePathDto : {}) : (validatePathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultDirectoryBrowser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultDirectoryBrowserInfoDto>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDefaultDirectoryBrowser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrives(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDrives(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkShares(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getNetworkShares(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentPath(path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getParentPath(path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePath(validatePathDto: ValidatePathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).validatePath(validatePathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get Default directory browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser(options?: any): AxiosPromise<DefaultDirectoryBrowserInfoDto> {
            return EnvironmentApiFp(configuration).getDefaultDirectoryBrowser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the contents of a given directory in the file system.
         * @param {string} path The path.
         * @param {boolean} [includeFiles] An optional filter to include or exclude files from the results. true/false.
         * @param {boolean} [includeDirectories] An optional filter to include or exclude folders from the results. true/false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available drives from the server\'s file system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDrives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets network paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getNetworkShares(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the parent path of a given path.
         * @param {string} path The path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath(path: string, options?: any): AxiosPromise<string> {
            return EnvironmentApiFp(configuration).getParentPath(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validates path.
         * @param {ValidatePathDto} validatePathDto Validate request object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath(validatePathDto: ValidatePathDto, options?: any): AxiosPromise<void> {
            return EnvironmentApiFp(configuration).validatePath(validatePathDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDirectoryContents operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiGetDirectoryContentsRequest
 */
export interface EnvironmentApiGetDirectoryContentsRequest {
    /**
     * The path.
     * @type {string}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly path: string

    /**
     * An optional filter to include or exclude files from the results. true/false.
     * @type {boolean}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly includeFiles?: boolean

    /**
     * An optional filter to include or exclude folders from the results. true/false.
     * @type {boolean}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly includeDirectories?: boolean
}

/**
 * Request parameters for getParentPath operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiGetParentPathRequest
 */
export interface EnvironmentApiGetParentPathRequest {
    /**
     * The path.
     * @type {string}
     * @memberof EnvironmentApiGetParentPath
     */
    readonly path: string
}

/**
 * Request parameters for validatePath operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiValidatePathRequest
 */
export interface EnvironmentApiValidatePathRequest {
    /**
     * Validate request object.
     * @type {ValidatePathDto}
     * @memberof EnvironmentApiValidatePath
     */
    readonly validatePathDto: ValidatePathDto
}

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @summary Get Default directory browser.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDefaultDirectoryBrowser(options?: any) {
        return EnvironmentApiFp(this.configuration).getDefaultDirectoryBrowser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the contents of a given directory in the file system.
     * @param {EnvironmentApiGetDirectoryContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDirectoryContents(requestParameters: EnvironmentApiGetDirectoryContentsRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).getDirectoryContents(requestParameters.path, requestParameters.includeFiles, requestParameters.includeDirectories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available drives from the server\'s file system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDrives(options?: any) {
        return EnvironmentApiFp(this.configuration).getDrives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets network paths.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getNetworkShares(options?: any) {
        return EnvironmentApiFp(this.configuration).getNetworkShares(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the parent path of a given path.
     * @param {EnvironmentApiGetParentPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getParentPath(requestParameters: EnvironmentApiGetParentPathRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).getParentPath(requestParameters.path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validates path.
     * @param {EnvironmentApiValidatePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public validatePath(requestParameters: EnvironmentApiValidatePathRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).validatePath(requestParameters.validatePathDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters: async (userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy: async (userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFilters>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFiltersLegacy>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isAiring] Optional. Is item airing.
         * @param {boolean} [isMovie] Optional. Is item movie.
         * @param {boolean} [isSports] Optional. Is item sports.
         * @param {boolean} [isKids] Optional. Is item kids.
         * @param {boolean} [isNews] Optional. Is item news.
         * @param {boolean} [isSeries] Optional. Is item series.
         * @param {boolean} [recursive] Optional. Search recursive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): AxiosPromise<QueryFilters> {
            return FilterApiFp(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets legacy query filters.
         * @param {string} [userId] Optional. User id.
         * @param {string} [parentId] Optional. Parent id.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): AxiosPromise<QueryFiltersLegacy> {
            return FilterApiFp(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getQueryFilters operation in FilterApi.
 * @export
 * @interface FilterApiGetQueryFiltersRequest
 */
export interface FilterApiGetQueryFiltersRequest {
    /**
     * Optional. User id.
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly userId?: string

    /**
     * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly parentId?: string

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Is item airing.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isAiring?: boolean

    /**
     * Optional. Is item movie.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isMovie?: boolean

    /**
     * Optional. Is item sports.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isSports?: boolean

    /**
     * Optional. Is item kids.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isKids?: boolean

    /**
     * Optional. Is item news.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isNews?: boolean

    /**
     * Optional. Is item series.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isSeries?: boolean

    /**
     * Optional. Search recursive.
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly recursive?: boolean
}

/**
 * Request parameters for getQueryFiltersLegacy operation in FilterApi.
 * @export
 * @interface FilterApiGetQueryFiltersLegacyRequest
 */
export interface FilterApiGetQueryFiltersLegacyRequest {
    /**
     * Optional. User id.
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly userId?: string

    /**
     * Optional. Parent id.
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly parentId?: string

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly mediaTypes?: string
}

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @summary Gets query filters.
     * @param {FilterApiGetQueryFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFilters(requestParameters: FilterApiGetQueryFiltersRequest = {}, options?: any) {
        return FilterApiFp(this.configuration).getQueryFilters(requestParameters.userId, requestParameters.parentId, requestParameters.includeItemTypes, requestParameters.isAiring, requestParameters.isMovie, requestParameters.isSports, requestParameters.isKids, requestParameters.isNews, requestParameters.isSeries, requestParameters.recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets legacy query filters.
     * @param {FilterApiGetQueryFiltersLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFiltersLegacy(requestParameters: FilterApiGetQueryFiltersLegacyRequest = {}, options?: any) {
        return FilterApiFp(this.configuration).getQueryFiltersLegacy(requestParameters.userId, requestParameters.parentId, requestParameters.includeItemTypes, requestParameters.mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getGenre.');
            }
            const localVarPath = `/Genres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres: async (startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenres(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenres(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return GenresApiFp(configuration).getGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return GenresApiFp(configuration).getGenres(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGenre operation in GenresApi.
 * @export
 * @interface GenresApiGetGenreRequest
 */
export interface GenresApiGetGenreRequest {
    /**
     * The genre name.
     * @type {string}
     * @memberof GenresApiGetGenre
     */
    readonly genreName: string

    /**
     * The user id.
     * @type {string}
     * @memberof GenresApiGetGenre
     */
    readonly userId?: string
}

/**
 * Request parameters for getGenres operation in GenresApi.
 * @export
 * @interface GenresApiGetGenresRequest
 */
export interface GenresApiGetGenresRequest {
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly limit?: number

    /**
     * The search term.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof GenresApiGetGenres
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly includeItemTypes?: string

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly isFavorite?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof GenresApiGetGenres
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * User id.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly userId?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameLessThan?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include total record count.
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @summary Gets a genre, by name.
     * @param {GenresApiGetGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenre(requestParameters: GenresApiGetGenreRequest, options?: any) {
        return GenresApiFp(this.configuration).getGenre(requestParameters.genreName, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all genres from a given item, folder, or the entire library.
     * @param {GenresApiGetGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenres(requestParameters: GenresApiGetGenresRequest = {}, options?: any) {
        return GenresApiFp(this.configuration).getGenres(requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.isFavorite, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HlsSegmentApi - axios parameter creator
 * @export
 */
export const HlsSegmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.aac`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.mp3`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy: async (itemId: string, playlistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/stream.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy: async (itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentContainer' is not null or undefined
            if (segmentContainer === null || segmentContainer === undefined) {
                throw new RequiredError('segmentContainer','Required parameter segmentContainer was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"segmentContainer"}}`, encodeURIComponent(String(segmentContainer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess: async (deviceId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Videos/ActiveEncodings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HlsSegmentApi - functional programming interface
 * @export
 */
export const HlsSegmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsPlaylistLegacy(itemId, playlistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).stopEncodingProcess(deviceId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HlsSegmentApi - factory interface
 * @export
 */
export const HlsSegmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the specified audio segment for an audio item.
         * @param {string} itemId The item id.
         * @param {string} segmentId The segment id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a hls video playlist.
         * @param {string} itemId The video id.
         * @param {string} playlistId The playlist id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsPlaylistLegacy(itemId, playlistId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a hls video segment.
         * @param {string} itemId The item id.
         * @param {string} playlistId The playlist id.
         * @param {string} segmentId The segment id.
         * @param {string} segmentContainer The segment container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): AxiosPromise<any> {
            return HlsSegmentApiFp(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stops an active encoding.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).stopEncodingProcess(deviceId, playSessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHlsAudioSegmentLegacyAac operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest
 */
export interface HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyAac
     */
    readonly itemId: string

    /**
     * The segment id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyAac
     */
    readonly segmentId: string
}

/**
 * Request parameters for getHlsAudioSegmentLegacyMp3 operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request
 */
export interface HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request {
    /**
     * The item id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyMp3
     */
    readonly itemId: string

    /**
     * The segment id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyMp3
     */
    readonly segmentId: string
}

/**
 * Request parameters for getHlsPlaylistLegacy operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsPlaylistLegacyRequest
 */
export interface HlsSegmentApiGetHlsPlaylistLegacyRequest {
    /**
     * The video id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsPlaylistLegacy
     */
    readonly itemId: string

    /**
     * The playlist id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsPlaylistLegacy
     */
    readonly playlistId: string
}

/**
 * Request parameters for getHlsVideoSegmentLegacy operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsVideoSegmentLegacyRequest
 */
export interface HlsSegmentApiGetHlsVideoSegmentLegacyRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly itemId: string

    /**
     * The playlist id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly playlistId: string

    /**
     * The segment id.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly segmentId: string

    /**
     * The segment container.
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly segmentContainer: string
}

/**
 * Request parameters for stopEncodingProcess operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiStopEncodingProcessRequest
 */
export interface HlsSegmentApiStopEncodingProcessRequest {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof HlsSegmentApiStopEncodingProcess
     */
    readonly deviceId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof HlsSegmentApiStopEncodingProcess
     */
    readonly playSessionId?: string
}

/**
 * HlsSegmentApi - object-oriented interface
 * @export
 * @class HlsSegmentApi
 * @extends {BaseAPI}
 */
export class HlsSegmentApi extends BaseAPI {
    /**
     * 
     * @summary Gets the specified audio segment for an audio item.
     * @param {HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyAac(requestParameters: HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyAac(requestParameters.itemId, requestParameters.segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the specified audio segment for an audio item.
     * @param {HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyMp3(requestParameters: HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyMp3(requestParameters.itemId, requestParameters.segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a hls video playlist.
     * @param {HlsSegmentApiGetHlsPlaylistLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsPlaylistLegacy(requestParameters: HlsSegmentApiGetHlsPlaylistLegacyRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsPlaylistLegacy(requestParameters.itemId, requestParameters.playlistId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a hls video segment.
     * @param {HlsSegmentApiGetHlsVideoSegmentLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsVideoSegmentLegacy(requestParameters: HlsSegmentApiGetHlsVideoSegmentLegacyRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsVideoSegmentLegacy(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.segmentContainer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stops an active encoding.
     * @param {HlsSegmentApiStopEncodingProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public stopEncodingProcess(requestParameters: HlsSegmentApiStopEncodingProcessRequest = {}, options?: any) {
        return HlsSegmentApiFp(this.configuration).stopEncodingProcess(requestParameters.deviceId, requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2_1.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImageInfos.');
            }
            const localVarPath = `/Items/{itemId}/Images`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage: async (name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2_2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage: async (name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage: async (name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex: async (itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling updateItemImageIndex.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/Index`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newIndex !== undefined) {
                localVarQueryParameter['newIndex'] = newIndex;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage2(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImageInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImageInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudioImage(name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudioImage(name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage2(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex The image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the user\'s image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage2(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item image infos.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos(itemId: string, options?: any): AxiosPromise<Array<ImageInfo>> {
            return ImageApiFp(configuration).getItemImageInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage(name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get artist image by name.
         * @param {string} name Artist name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headArtistImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get genre image by name.
         * @param {string} name Genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {ImageFormat} [format] Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2(itemId: string, imageType: ImageType, imageIndex: number, maxWidth?: number, maxHeight?: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: ImageFormat, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage2(itemId, imageType, imageIndex, maxWidth, maxHeight, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the item\'s image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} maxWidth The maximum image width to return.
         * @param {number} maxHeight The maximum image height to return.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} percentPlayed Optional. Percent to render for the percent played overlay.
         * @param {number} unplayedCount Optional. Unplayed count overlay to render.
         * @param {number} imageIndex Image index.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: ImageFormat, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music genre image by name.
         * @param {string} name Music genre name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headMusicGenreImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person image by name.
         * @param {string} name Person name.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage(name: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headPersonImage(name, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get studio image by name.
         * @param {string} name Studio name.
         * @param {ImageType} imageType Image type.
         * @param {string} tag Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} format Determines the output format of the image - original,gif,jpg,png.
         * @param {number} imageIndex Image index.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage(name: string, imageType: ImageType, tag: string, format: ImageFormat, imageIndex: number, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headStudioImage(name, imageType, tag, format, imageIndex, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user profile image.
         * @param {string} userId User id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Image index.
         * @param {string} [tag] Optional. Supply the cache tag from the item object to receive strong caching headers.
         * @param {ImageFormat} [format] Determines the output format of the image - original,gif,jpg,png.
         * @param {number} [maxWidth] The maximum image width to return.
         * @param {number} [maxHeight] The maximum image height to return.
         * @param {number} [percentPlayed] Optional. Percent to render for the percent played overlay.
         * @param {number} [unplayedCount] Optional. Unplayed count overlay to render.
         * @param {number} [width] The fixed image width to return.
         * @param {number} [height] The fixed image height to return.
         * @param {number} [quality] Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         * @param {boolean} [cropWhitespace] Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         * @param {boolean} [addPlayedIndicator] Optional. Add a played indicator.
         * @param {number} [blur] Optional. Blur image.
         * @param {string} [backgroundColor] Optional. Apply a background color for transparent images.
         * @param {string} [foregroundLayer] Optional. Apply a foreground layer on top of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: ImageFormat, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<any> {
            return ImageApiFp(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user image.
         * @param {string} userId User Id.
         * @param {ImageType} imageType (Unused) Image type.
         * @param {number} index (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage2(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex (Unused) Image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the index for an item image.
         * @param {string} itemId Item id.
         * @param {ImageType} imageType Image type.
         * @param {number} imageIndex Old image index.
         * @param {number} [newIndex] New image index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteItemImage operation in ImageApi.
 * @export
 * @interface ImageApiDeleteItemImageRequest
 */
export interface ImageApiDeleteItemImageRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiDeleteItemImage
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiDeleteItemImage
     */
    readonly imageType: ImageType

    /**
     * The image index.
     * @type {number}
     * @memberof ImageApiDeleteItemImage
     */
    readonly imageIndex: number
}

/**
 * Request parameters for deleteItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiDeleteItemImage2Request
 */
export interface ImageApiDeleteItemImage2Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly imageType: ImageType

    /**
     * The image index.
     * @type {number}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly imageIndex: number
}

/**
 * Request parameters for deleteUserImage operation in ImageApi.
 * @export
 * @interface ImageApiDeleteUserImageRequest
 */
export interface ImageApiDeleteUserImageRequest {
    /**
     * User Id.
     * @type {string}
     * @memberof ImageApiDeleteUserImage
     */
    readonly userId: string

    /**
     * (Unused) Image type.
     * @type {ImageType}
     * @memberof ImageApiDeleteUserImage
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiDeleteUserImage
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage
     */
    readonly itemType: string
}

/**
 * Request parameters for deleteUserImage2 operation in ImageApi.
 * @export
 * @interface ImageApiDeleteUserImage2Request
 */
export interface ImageApiDeleteUserImage2Request {
    /**
     * User Id.
     * @type {string}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly userId: string

    /**
     * (Unused) Image type.
     * @type {ImageType}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly itemType: string
}

/**
 * Request parameters for getArtistImage operation in ImageApi.
 * @export
 * @interface ImageApiGetArtistImageRequest
 */
export interface ImageApiGetArtistImageRequest {
    /**
     * Artist name.
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetArtistImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetArtistImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetArtistImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetArtistImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiGetGenreImageRequest
 */
export interface ImageApiGetGenreImageRequest {
    /**
     * Genre name.
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetGenreImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetGenreImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImageRequest
 */
export interface ImageApiGetItemImageRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetItemImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly maxHeight?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly quality?: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly tag?: string

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetItemImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
     * @type {ImageFormat}
     * @memberof ImageApiGetItemImage
     */
    readonly format?: ImageFormat

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetItemImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly unplayedCount?: number

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImage2Request
 */
export interface ImageApiGetItemImage2Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetItemImage2
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly maxHeight?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly quality?: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly tag?: string

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetItemImage2
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
     * @type {ImageFormat}
     * @memberof ImageApiGetItemImage2
     */
    readonly format?: ImageFormat

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetItemImage2
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly unplayedCount?: number

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage2_1 operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImage20Request
 */
export interface ImageApiGetItemImage20Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetItemImage20
     */
    readonly imageType: ImageType

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly maxWidth: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly maxHeight: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly tag: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetItemImage20
     */
    readonly format: ImageFormat

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly percentPlayed: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly unplayedCount: number

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly imageIndex: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetItemImage20
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetItemImage20
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImageInfos operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImageInfosRequest
 */
export interface ImageApiGetItemImageInfosRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiGetItemImageInfos
     */
    readonly itemId: string
}

/**
 * Request parameters for getMusicGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiGetMusicGenreImageRequest
 */
export interface ImageApiGetMusicGenreImageRequest {
    /**
     * Music genre name.
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getPersonImage operation in ImageApi.
 * @export
 * @interface ImageApiGetPersonImageRequest
 */
export interface ImageApiGetPersonImageRequest {
    /**
     * Person name.
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetPersonImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetPersonImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetPersonImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetPersonImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getStudioImage operation in ImageApi.
 * @export
 * @interface ImageApiGetStudioImageRequest
 */
export interface ImageApiGetStudioImageRequest {
    /**
     * Studio name.
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetStudioImage
     */
    readonly imageType: ImageType

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly tag: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetStudioImage
     */
    readonly format: ImageFormat

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetStudioImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetStudioImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getUserImage operation in ImageApi.
 * @export
 * @interface ImageApiGetUserImageRequest
 */
export interface ImageApiGetUserImageRequest {
    /**
     * User id.
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly userId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiGetUserImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiGetUserImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiGetUserImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiGetUserImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headArtistImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadArtistImageRequest
 */
export interface ImageApiHeadArtistImageRequest {
    /**
     * Artist name.
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadArtistImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadArtistImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadArtistImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadArtistImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadGenreImageRequest
 */
export interface ImageApiHeadGenreImageRequest {
    /**
     * Genre name.
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadGenreImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadGenreImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImageRequest
 */
export interface ImageApiHeadItemImageRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly maxHeight?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly quality?: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly tag?: string

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
     * @type {ImageFormat}
     * @memberof ImageApiHeadItemImage
     */
    readonly format?: ImageFormat

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly unplayedCount?: number

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImage2Request
 */
export interface ImageApiHeadItemImage2Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage2
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly maxHeight?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly quality?: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly tag?: string

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage2
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
     * @type {ImageFormat}
     * @memberof ImageApiHeadItemImage2
     */
    readonly format?: ImageFormat

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage2
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly unplayedCount?: number

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage2_2 operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImage20Request
 */
export interface ImageApiHeadItemImage20Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage20
     */
    readonly imageType: ImageType

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly maxWidth: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly maxHeight: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly tag: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadItemImage20
     */
    readonly format: ImageFormat

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly percentPlayed: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly unplayedCount: number

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly imageIndex: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage20
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadItemImage20
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headMusicGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadMusicGenreImageRequest
 */
export interface ImageApiHeadMusicGenreImageRequest {
    /**
     * Music genre name.
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headPersonImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadPersonImageRequest
 */
export interface ImageApiHeadPersonImageRequest {
    /**
     * Person name.
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadPersonImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadPersonImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadPersonImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadPersonImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headStudioImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadStudioImageRequest
 */
export interface ImageApiHeadStudioImageRequest {
    /**
     * Studio name.
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly name: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadStudioImage
     */
    readonly imageType: ImageType

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly tag: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadStudioImage
     */
    readonly format: ImageFormat

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly imageIndex: number

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadStudioImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadStudioImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headUserImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadUserImageRequest
 */
export interface ImageApiHeadUserImageRequest {
    /**
     * User id.
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly userId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiHeadUserImage
     */
    readonly imageType: ImageType

    /**
     * Image index.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly imageIndex: number

    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly tag?: string

    /**
     * Determines the output format of the image - original,gif,jpg,png.
     * @type {ImageFormat}
     * @memberof ImageApiHeadUserImage
     */
    readonly format?: ImageFormat

    /**
     * The maximum image width to return.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly maxWidth?: number

    /**
     * The maximum image height to return.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly maxHeight?: number

    /**
     * Optional. Percent to render for the percent played overlay.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly percentPlayed?: number

    /**
     * Optional. Unplayed count overlay to render.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly unplayedCount?: number

    /**
     * The fixed image width to return.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly width?: number

    /**
     * The fixed image height to return.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly height?: number

    /**
     * Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly quality?: number

    /**
     * Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @type {boolean}
     * @memberof ImageApiHeadUserImage
     */
    readonly cropWhitespace?: boolean

    /**
     * Optional. Add a played indicator.
     * @type {boolean}
     * @memberof ImageApiHeadUserImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * Optional. Blur image.
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly blur?: number

    /**
     * Optional. Apply a background color for transparent images.
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly backgroundColor?: string

    /**
     * Optional. Apply a foreground layer on top of the image.
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for postUserImage operation in ImageApi.
 * @export
 * @interface ImageApiPostUserImageRequest
 */
export interface ImageApiPostUserImageRequest {
    /**
     * User Id.
     * @type {string}
     * @memberof ImageApiPostUserImage
     */
    readonly userId: string

    /**
     * (Unused) Image type.
     * @type {ImageType}
     * @memberof ImageApiPostUserImage
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiPostUserImage
     */
    readonly index: number
}

/**
 * Request parameters for postUserImage2 operation in ImageApi.
 * @export
 * @interface ImageApiPostUserImage2Request
 */
export interface ImageApiPostUserImage2Request {
    /**
     * User Id.
     * @type {string}
     * @memberof ImageApiPostUserImage2
     */
    readonly userId: string

    /**
     * (Unused) Image type.
     * @type {ImageType}
     * @memberof ImageApiPostUserImage2
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiPostUserImage2
     */
    readonly index: number
}

/**
 * Request parameters for setItemImage operation in ImageApi.
 * @export
 * @interface ImageApiSetItemImageRequest
 */
export interface ImageApiSetItemImageRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiSetItemImage
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiSetItemImage
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiSetItemImage
     */
    readonly imageIndex: number
}

/**
 * Request parameters for setItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiSetItemImage2Request
 */
export interface ImageApiSetItemImage2Request {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiSetItemImage2
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiSetItemImage2
     */
    readonly imageType: ImageType

    /**
     * (Unused) Image index.
     * @type {number}
     * @memberof ImageApiSetItemImage2
     */
    readonly imageIndex: number
}

/**
 * Request parameters for updateItemImageIndex operation in ImageApi.
 * @export
 * @interface ImageApiUpdateItemImageIndexRequest
 */
export interface ImageApiUpdateItemImageIndexRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly itemId: string

    /**
     * Image type.
     * @type {ImageType}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly imageType: ImageType

    /**
     * Old image index.
     * @type {number}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly imageIndex: number

    /**
     * New image index.
     * @type {number}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly newIndex?: number
}

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @summary Delete an item\'s image.
     * @param {ImageApiDeleteItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage(requestParameters: ImageApiDeleteItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an item\'s image.
     * @param {ImageApiDeleteItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage2(requestParameters: ImageApiDeleteItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the user\'s image.
     * @param {ImageApiDeleteUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage(requestParameters: ImageApiDeleteUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.index, requestParameters.itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the user\'s image.
     * @param {ImageApiDeleteUserImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage2(requestParameters: ImageApiDeleteUserImage2Request, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage2(requestParameters.userId, requestParameters.imageType, requestParameters.index, requestParameters.itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get artist image by name.
     * @param {ImageApiGetArtistImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getArtistImage(requestParameters: ImageApiGetArtistImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getArtistImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get genre image by name.
     * @param {ImageApiGetGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getGenreImage(requestParameters: ImageApiGetGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiGetItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage(requestParameters: ImageApiGetItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiGetItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2(requestParameters: ImageApiGetItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiGetItemImage20Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2_1(requestParameters: ImageApiGetItemImage20Request, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2_1(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.tag, requestParameters.format, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item image infos.
     * @param {ImageApiGetItemImageInfosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImageInfos(requestParameters: ImageApiGetItemImageInfosRequest, options?: any) {
        return ImageApiFp(this.configuration).getItemImageInfos(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music genre image by name.
     * @param {ImageApiGetMusicGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getMusicGenreImage(requestParameters: ImageApiGetMusicGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getMusicGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person image by name.
     * @param {ImageApiGetPersonImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getPersonImage(requestParameters: ImageApiGetPersonImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getPersonImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get studio image by name.
     * @param {ImageApiGetStudioImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getStudioImage(requestParameters: ImageApiGetStudioImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getStudioImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile image.
     * @param {ImageApiGetUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getUserImage(requestParameters: ImageApiGetUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get artist image by name.
     * @param {ImageApiHeadArtistImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headArtistImage(requestParameters: ImageApiHeadArtistImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headArtistImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get genre image by name.
     * @param {ImageApiHeadGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headGenreImage(requestParameters: ImageApiHeadGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiHeadItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage(requestParameters: ImageApiHeadItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiHeadItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2(requestParameters: ImageApiHeadItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the item\'s image.
     * @param {ImageApiHeadItemImage20Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2_2(requestParameters: ImageApiHeadItemImage20Request, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2_2(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.tag, requestParameters.format, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music genre image by name.
     * @param {ImageApiHeadMusicGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headMusicGenreImage(requestParameters: ImageApiHeadMusicGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headMusicGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person image by name.
     * @param {ImageApiHeadPersonImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headPersonImage(requestParameters: ImageApiHeadPersonImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headPersonImage(requestParameters.name, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get studio image by name.
     * @param {ImageApiHeadStudioImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headStudioImage(requestParameters: ImageApiHeadStudioImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headStudioImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.imageIndex, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user profile image.
     * @param {ImageApiHeadUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headUserImage(requestParameters: ImageApiHeadUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user image.
     * @param {ImageApiPostUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage(requestParameters: ImageApiPostUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).postUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user image.
     * @param {ImageApiPostUserImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage2(requestParameters: ImageApiPostUserImage2Request, options?: any) {
        return ImageApiFp(this.configuration).postUserImage2(requestParameters.userId, requestParameters.imageType, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set item image.
     * @param {ImageApiSetItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage(requestParameters: ImageApiSetItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).setItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set item image.
     * @param {ImageApiSetItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage2(requestParameters: ImageApiSetItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).setItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the index for an item image.
     * @param {ImageApiUpdateItemImageIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public updateItemImageIndex(requestParameters: ImageApiUpdateItemImageIndexRequest, options?: any) {
        return ImageApiFp(this.configuration).updateItemImageIndex(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.newIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageByNameApi - axios parameter creator
 * @export
 */
export const ImageByNameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage: async (name: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGeneralImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGeneralImage.');
            }
            const localVarPath = `/Images/General/{name}/{type}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/General`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getMediaInfoImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMediaInfoImage.');
            }
            const localVarPath = `/Images/MediaInfo/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/MediaInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getRatingImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRatingImage.');
            }
            const localVarPath = `/Images/Ratings/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/Ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageByNameApi - functional programming interface
 * @export
 */
export const ImageByNameApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImage(name: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImage(name, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageByNameApi - factory interface
 * @export
 */
export const ImageByNameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get General Image.
         * @param {string} name The name of the image.
         * @param {string} type Image Type (primary, backdrop, logo, etc).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage(name: string, type: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getGeneralImage(name, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getGeneralImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get media info image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getMediaInfoImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all media info images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getMediaInfoImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get rating image.
         * @param {string} theme The theme to get the image from.
         * @param {string} name The name of the image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getRatingImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all general images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getRatingImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGeneralImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetGeneralImageRequest
 */
export interface ImageByNameApiGetGeneralImageRequest {
    /**
     * The name of the image.
     * @type {string}
     * @memberof ImageByNameApiGetGeneralImage
     */
    readonly name: string

    /**
     * Image Type (primary, backdrop, logo, etc).
     * @type {string}
     * @memberof ImageByNameApiGetGeneralImage
     */
    readonly type: string
}

/**
 * Request parameters for getMediaInfoImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetMediaInfoImageRequest
 */
export interface ImageByNameApiGetMediaInfoImageRequest {
    /**
     * The theme to get the image from.
     * @type {string}
     * @memberof ImageByNameApiGetMediaInfoImage
     */
    readonly theme: string

    /**
     * The name of the image.
     * @type {string}
     * @memberof ImageByNameApiGetMediaInfoImage
     */
    readonly name: string
}

/**
 * Request parameters for getRatingImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetRatingImageRequest
 */
export interface ImageByNameApiGetRatingImageRequest {
    /**
     * The theme to get the image from.
     * @type {string}
     * @memberof ImageByNameApiGetRatingImage
     */
    readonly theme: string

    /**
     * The name of the image.
     * @type {string}
     * @memberof ImageByNameApiGetRatingImage
     */
    readonly name: string
}

/**
 * ImageByNameApi - object-oriented interface
 * @export
 * @class ImageByNameApi
 * @extends {BaseAPI}
 */
export class ImageByNameApi extends BaseAPI {
    /**
     * 
     * @summary Get General Image.
     * @param {ImageByNameApiGetGeneralImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImage(requestParameters: ImageByNameApiGetGeneralImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImage(requestParameters.name, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all general images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get media info image.
     * @param {ImageByNameApiGetMediaInfoImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImage(requestParameters: ImageByNameApiGetMediaInfoImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImage(requestParameters.theme, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all media info images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get rating image.
     * @param {ImageByNameApiGetRatingImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImage(requestParameters: ImageByNameApiGetRatingImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImage(requestParameters.theme, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all general images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImages(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstantMixApi - axios parameter creator
 * @export
 */
export const InstantMixApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromAlbum.');
            }
            const localVarPath = `/Albums/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromArtists.');
            }
            const localVarPath = `/Artists/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromItem.');
            }
            const localVarPath = `/Items/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre: async (name: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getInstantMixFromMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{name}/InstantMix`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromMusicGenres.');
            }
            const localVarPath = `/MusicGenres/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromPlaylist.');
            }
            const localVarPath = `/Playlists/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong: async (id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromSong.');
            }
            const localVarPath = `/Songs/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstantMixApi - functional programming interface
 * @export
 */
export const InstantMixApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstantMixApi - factory interface
 * @export
 */
export const InstantMixApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} name The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an instant playlist based on a given song.
         * @param {string} id The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInstantMixFromAlbum operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromAlbumRequest
 */
export interface InstantMixApiGetInstantMixFromAlbumRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromArtists operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromArtistsRequest
 */
export interface InstantMixApiGetInstantMixFromArtistsRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromItem operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromItemRequest
 */
export interface InstantMixApiGetInstantMixFromItemRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromMusicGenre operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromMusicGenreRequest
 */
export interface InstantMixApiGetInstantMixFromMusicGenreRequest {
    /**
     * The genre name.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly name: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromMusicGenres operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromMusicGenresRequest
 */
export interface InstantMixApiGetInstantMixFromMusicGenresRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromPlaylist operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromPlaylistRequest
 */
export interface InstantMixApiGetInstantMixFromPlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for getInstantMixFromSong operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromSongRequest
 */
export interface InstantMixApiGetInstantMixFromSongRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly id: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * InstantMixApi - object-oriented interface
 * @export
 * @class InstantMixApi
 * @extends {BaseAPI}
 */
export class InstantMixApi extends BaseAPI {
    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromAlbum(requestParameters: InstantMixApiGetInstantMixFromAlbumRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromAlbum(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromArtists(requestParameters: InstantMixApiGetInstantMixFromArtistsRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromArtists(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromItem(requestParameters: InstantMixApiGetInstantMixFromItemRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromItem(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromMusicGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenre(requestParameters: InstantMixApiGetInstantMixFromMusicGenreRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenre(requestParameters.name, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromMusicGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenres(requestParameters: InstantMixApiGetInstantMixFromMusicGenresRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenres(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromPlaylist(requestParameters: InstantMixApiGetInstantMixFromPlaylistRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromPlaylist(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an instant playlist based on a given song.
     * @param {InstantMixApiGetInstantMixFromSongRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromSong(requestParameters: InstantMixApiGetInstantMixFromSongRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromSong(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemLookupApi - axios parameter creator
 * @export
 */
export const ItemLookupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria: async (itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling applySearchCriteria.');
            }
            // verify required parameter 'remoteSearchResult' is not null or undefined
            if (remoteSearchResult === null || remoteSearchResult === undefined) {
                throw new RequiredError('remoteSearchResult','Required parameter remoteSearchResult was null or undefined when calling applySearchCriteria.');
            }
            const localVarPath = `/Items/RemoteSearch/Apply/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remoteSearchResult !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remoteSearchResult !== undefined ? remoteSearchResult : {}) : (remoteSearchResult || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults: async (bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookInfoRemoteSearchQuery' is not null or undefined
            if (bookInfoRemoteSearchQuery === null || bookInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('bookInfoRemoteSearchQuery','Required parameter bookInfoRemoteSearchQuery was null or undefined when calling getBookRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Book`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bookInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bookInfoRemoteSearchQuery !== undefined ? bookInfoRemoteSearchQuery : {}) : (bookInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults: async (boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxSetInfoRemoteSearchQuery' is not null or undefined
            if (boxSetInfoRemoteSearchQuery === null || boxSetInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('boxSetInfoRemoteSearchQuery','Required parameter boxSetInfoRemoteSearchQuery was null or undefined when calling getBoxSetRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/BoxSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof boxSetInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(boxSetInfoRemoteSearchQuery !== undefined ? boxSetInfoRemoteSearchQuery : {}) : (boxSetInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getExternalIdInfos.');
            }
            const localVarPath = `/Items/{itemId}/ExternalIdInfos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults: async (movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieInfoRemoteSearchQuery' is not null or undefined
            if (movieInfoRemoteSearchQuery === null || movieInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('movieInfoRemoteSearchQuery','Required parameter movieInfoRemoteSearchQuery was null or undefined when calling getMovieRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Movie`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof movieInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(movieInfoRemoteSearchQuery !== undefined ? movieInfoRemoteSearchQuery : {}) : (movieInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults: async (albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumInfoRemoteSearchQuery' is not null or undefined
            if (albumInfoRemoteSearchQuery === null || albumInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('albumInfoRemoteSearchQuery','Required parameter albumInfoRemoteSearchQuery was null or undefined when calling getMusicAlbumRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicAlbum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof albumInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(albumInfoRemoteSearchQuery !== undefined ? albumInfoRemoteSearchQuery : {}) : (albumInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults: async (artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artistInfoRemoteSearchQuery' is not null or undefined
            if (artistInfoRemoteSearchQuery === null || artistInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('artistInfoRemoteSearchQuery','Required parameter artistInfoRemoteSearchQuery was null or undefined when calling getMusicArtistRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicArtist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof artistInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(artistInfoRemoteSearchQuery !== undefined ? artistInfoRemoteSearchQuery : {}) : (artistInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults: async (musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'musicVideoInfoRemoteSearchQuery' is not null or undefined
            if (musicVideoInfoRemoteSearchQuery === null || musicVideoInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('musicVideoInfoRemoteSearchQuery','Required parameter musicVideoInfoRemoteSearchQuery was null or undefined when calling getMusicVideoRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicVideo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof musicVideoInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(musicVideoInfoRemoteSearchQuery !== undefined ? musicVideoInfoRemoteSearchQuery : {}) : (musicVideoInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults: async (personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personLookupInfoRemoteSearchQuery' is not null or undefined
            if (personLookupInfoRemoteSearchQuery === null || personLookupInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('personLookupInfoRemoteSearchQuery','Required parameter personLookupInfoRemoteSearchQuery was null or undefined when calling getPersonRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof personLookupInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(personLookupInfoRemoteSearchQuery !== undefined ? personLookupInfoRemoteSearchQuery : {}) : (personLookupInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage: async (imageUrl: string, providerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteSearchImage.');
            }
            // verify required parameter 'providerName' is not null or undefined
            if (providerName === null || providerName === undefined) {
                throw new RequiredError('providerName','Required parameter providerName was null or undefined when calling getRemoteSearchImage.');
            }
            const localVarPath = `/Items/RemoteSearch/Image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults: async (seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesInfoRemoteSearchQuery' is not null or undefined
            if (seriesInfoRemoteSearchQuery === null || seriesInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('seriesInfoRemoteSearchQuery','Required parameter seriesInfoRemoteSearchQuery was null or undefined when calling getSeriesRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesInfoRemoteSearchQuery !== undefined ? seriesInfoRemoteSearchQuery : {}) : (seriesInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults: async (trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trailerInfoRemoteSearchQuery' is not null or undefined
            if (trailerInfoRemoteSearchQuery === null || trailerInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('trailerInfoRemoteSearchQuery','Required parameter trailerInfoRemoteSearchQuery was null or undefined when calling getTrailerRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Trailer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof trailerInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(trailerInfoRemoteSearchQuery !== undefined ? trailerInfoRemoteSearchQuery : {}) : (trailerInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemLookupApi - functional programming interface
 * @export
 */
export const ItemLookupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applySearchCriteria(itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).applySearchCriteria(itemId, remoteSearchResult, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalIdInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdInfo>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getExternalIdInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getRemoteSearchImage(imageUrl, providerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemLookupApi - factory interface
 * @export
 */
export const ItemLookupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Applies search criteria to an item and refreshes metadata.
         * @param {string} itemId Item id.
         * @param {RemoteSearchResult} remoteSearchResult The remote search result.
         * @param {boolean} [replaceAllImages] Optional. Whether or not to replace all images. Default: True.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria(itemId: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemLookupApiFp(configuration).applySearchCriteria(itemId, remoteSearchResult, replaceAllImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get book remote search.
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get box set remote search.
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the item\'s external id info.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos(itemId: string, options?: any): AxiosPromise<Array<ExternalIdInfo>> {
            return ItemLookupApiFp(configuration).getExternalIdInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get movie remote search.
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music album remote search.
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music artist remote search.
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get music video remote search.
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get person remote search.
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {string} providerName The provider name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): AxiosPromise<any> {
            return ItemLookupApiFp(configuration).getRemoteSearchImage(imageUrl, providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get series remote search.
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trailer remote search.
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery Remote search query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applySearchCriteria operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiApplySearchCriteriaRequest
 */
export interface ItemLookupApiApplySearchCriteriaRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly itemId: string

    /**
     * The remote search result.
     * @type {RemoteSearchResult}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly remoteSearchResult: RemoteSearchResult

    /**
     * Optional. Whether or not to replace all images. Default: True.
     * @type {boolean}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly replaceAllImages?: boolean
}

/**
 * Request parameters for getBookRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetBookRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetBookRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {BookInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetBookRemoteSearchResults
     */
    readonly bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery
}

/**
 * Request parameters for getBoxSetRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetBoxSetRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetBoxSetRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {BoxSetInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetBoxSetRemoteSearchResults
     */
    readonly boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery
}

/**
 * Request parameters for getExternalIdInfos operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetExternalIdInfosRequest
 */
export interface ItemLookupApiGetExternalIdInfosRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ItemLookupApiGetExternalIdInfos
     */
    readonly itemId: string
}

/**
 * Request parameters for getMovieRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMovieRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMovieRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {MovieInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMovieRemoteSearchResults
     */
    readonly movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicAlbumRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {AlbumInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicAlbumRemoteSearchResults
     */
    readonly albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicArtistRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicArtistRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicArtistRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {ArtistInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicArtistRemoteSearchResults
     */
    readonly artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicVideoRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicVideoRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicVideoRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {MusicVideoInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicVideoRemoteSearchResults
     */
    readonly musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery
}

/**
 * Request parameters for getPersonRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetPersonRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetPersonRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {PersonLookupInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetPersonRemoteSearchResults
     */
    readonly personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery
}

/**
 * Request parameters for getRemoteSearchImage operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetRemoteSearchImageRequest
 */
export interface ItemLookupApiGetRemoteSearchImageRequest {
    /**
     * The image url.
     * @type {string}
     * @memberof ItemLookupApiGetRemoteSearchImage
     */
    readonly imageUrl: string

    /**
     * The provider name.
     * @type {string}
     * @memberof ItemLookupApiGetRemoteSearchImage
     */
    readonly providerName: string
}

/**
 * Request parameters for getSeriesRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetSeriesRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetSeriesRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {SeriesInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetSeriesRemoteSearchResults
     */
    readonly seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery
}

/**
 * Request parameters for getTrailerRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetTrailerRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetTrailerRemoteSearchResultsRequest {
    /**
     * Remote search query.
     * @type {TrailerInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetTrailerRemoteSearchResults
     */
    readonly trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery
}

/**
 * ItemLookupApi - object-oriented interface
 * @export
 * @class ItemLookupApi
 * @extends {BaseAPI}
 */
export class ItemLookupApi extends BaseAPI {
    /**
     * 
     * @summary Applies search criteria to an item and refreshes metadata.
     * @param {ItemLookupApiApplySearchCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public applySearchCriteria(requestParameters: ItemLookupApiApplySearchCriteriaRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).applySearchCriteria(requestParameters.itemId, requestParameters.remoteSearchResult, requestParameters.replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get book remote search.
     * @param {ItemLookupApiGetBookRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBookRemoteSearchResults(requestParameters: ItemLookupApiGetBookRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getBookRemoteSearchResults(requestParameters.bookInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get box set remote search.
     * @param {ItemLookupApiGetBoxSetRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBoxSetRemoteSearchResults(requestParameters: ItemLookupApiGetBoxSetRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getBoxSetRemoteSearchResults(requestParameters.boxSetInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the item\'s external id info.
     * @param {ItemLookupApiGetExternalIdInfosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getExternalIdInfos(requestParameters: ItemLookupApiGetExternalIdInfosRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getExternalIdInfos(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get movie remote search.
     * @param {ItemLookupApiGetMovieRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMovieRemoteSearchResults(requestParameters: ItemLookupApiGetMovieRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMovieRemoteSearchResults(requestParameters.movieInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music album remote search.
     * @param {ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicAlbumRemoteSearchResults(requestParameters: ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicAlbumRemoteSearchResults(requestParameters.albumInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music artist remote search.
     * @param {ItemLookupApiGetMusicArtistRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicArtistRemoteSearchResults(requestParameters: ItemLookupApiGetMusicArtistRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicArtistRemoteSearchResults(requestParameters.artistInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get music video remote search.
     * @param {ItemLookupApiGetMusicVideoRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicVideoRemoteSearchResults(requestParameters: ItemLookupApiGetMusicVideoRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicVideoRemoteSearchResults(requestParameters.musicVideoInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get person remote search.
     * @param {ItemLookupApiGetPersonRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getPersonRemoteSearchResults(requestParameters: ItemLookupApiGetPersonRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getPersonRemoteSearchResults(requestParameters.personLookupInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a remote image.
     * @param {ItemLookupApiGetRemoteSearchImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getRemoteSearchImage(requestParameters: ItemLookupApiGetRemoteSearchImageRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getRemoteSearchImage(requestParameters.imageUrl, requestParameters.providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get series remote search.
     * @param {ItemLookupApiGetSeriesRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getSeriesRemoteSearchResults(requestParameters: ItemLookupApiGetSeriesRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getSeriesRemoteSearchResults(requestParameters.seriesInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trailer remote search.
     * @param {ItemLookupApiGetTrailerRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getTrailerRemoteSearchResults(requestParameters: ItemLookupApiGetTrailerRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getTrailerRemoteSearchResults(requestParameters.trailerInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemRefreshApi - axios parameter creator
 * @export
 */
export const ItemRefreshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling post.');
            }
            const localVarPath = `/Items/{itemId}/Refresh`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (metadataRefreshMode !== undefined) {
                localVarQueryParameter['metadataRefreshMode'] = metadataRefreshMode;
            }

            if (imageRefreshMode !== undefined) {
                localVarQueryParameter['imageRefreshMode'] = imageRefreshMode;
            }

            if (replaceAllMetadata !== undefined) {
                localVarQueryParameter['replaceAllMetadata'] = replaceAllMetadata;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemRefreshApi - functional programming interface
 * @export
 */
export const ItemRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemRefreshApiAxiosParamCreator(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemRefreshApi - factory interface
 * @export
 */
export const ItemRefreshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Refreshes metadata for an item.
         * @param {string} itemId Item id.
         * @param {MetadataRefreshMode} [metadataRefreshMode] (Optional) Specifies the metadata refresh mode.
         * @param {MetadataRefreshMode} [imageRefreshMode] (Optional) Specifies the image refresh mode.
         * @param {boolean} [replaceAllMetadata] (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
         * @param {boolean} [replaceAllImages] (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemRefreshApiFp(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for post operation in ItemRefreshApi.
 * @export
 * @interface ItemRefreshApiPostRequest
 */
export interface ItemRefreshApiPostRequest {
    /**
     * Item id.
     * @type {string}
     * @memberof ItemRefreshApiPost
     */
    readonly itemId: string

    /**
     * (Optional) Specifies the metadata refresh mode.
     * @type {MetadataRefreshMode}
     * @memberof ItemRefreshApiPost
     */
    readonly metadataRefreshMode?: MetadataRefreshMode

    /**
     * (Optional) Specifies the image refresh mode.
     * @type {MetadataRefreshMode}
     * @memberof ItemRefreshApiPost
     */
    readonly imageRefreshMode?: MetadataRefreshMode

    /**
     * (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh.
     * @type {boolean}
     * @memberof ItemRefreshApiPost
     */
    readonly replaceAllMetadata?: boolean

    /**
     * (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh.
     * @type {boolean}
     * @memberof ItemRefreshApiPost
     */
    readonly replaceAllImages?: boolean
}

/**
 * ItemRefreshApi - object-oriented interface
 * @export
 * @class ItemRefreshApi
 * @extends {BaseAPI}
 */
export class ItemRefreshApi extends BaseAPI {
    /**
     * 
     * @summary Refreshes metadata for an item.
     * @param {ItemRefreshApiPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemRefreshApi
     */
    public post(requestParameters: ItemRefreshApiPostRequest, options?: any) {
        return ItemRefreshApiFp(this.configuration).post(requestParameters.itemId, requestParameters.metadataRefreshMode, requestParameters.imageRefreshMode, requestParameters.replaceAllMetadata, requestParameters.replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemUpdateApi - axios parameter creator
 * @export
 */
export const ItemUpdateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMetadataEditorInfo.');
            }
            const localVarPath = `/Items/{itemId}/MetadataEditor`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (itemId: string, baseItemDto: BaseItemDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'baseItemDto' is not null or undefined
            if (baseItemDto === null || baseItemDto === undefined) {
                throw new RequiredError('baseItemDto','Required parameter baseItemDto was null or undefined when calling updateItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof baseItemDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(baseItemDto !== undefined ? baseItemDto : {}) : (baseItemDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType: async (itemId: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemContentType.');
            }
            const localVarPath = `/Items/{itemId}/ContentType`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemUpdateApi - functional programming interface
 * @export
 */
export const ItemUpdateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataEditorInfo(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataEditorInfo>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).getMetadataEditorInfo(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItem(itemId, baseItemDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemContentType(itemId: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItemContentType(itemId, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemUpdateApi - factory interface
 * @export
 */
export const ItemUpdateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets metadata editor info for an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo(itemId: string, options?: any): AxiosPromise<MetadataEditorInfo> {
            return ItemUpdateApiFp(configuration).getMetadataEditorInfo(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item.
         * @param {string} itemId The item id.
         * @param {BaseItemDto} baseItemDto The new item properties.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItem(itemId, baseItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item\'s content type.
         * @param {string} itemId The item id.
         * @param {string} [contentType] The content type of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType(itemId: string, contentType?: string, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItemContentType(itemId, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadataEditorInfo operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiGetMetadataEditorInfoRequest
 */
export interface ItemUpdateApiGetMetadataEditorInfoRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof ItemUpdateApiGetMetadataEditorInfo
     */
    readonly itemId: string
}

/**
 * Request parameters for updateItem operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiUpdateItemRequest
 */
export interface ItemUpdateApiUpdateItemRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof ItemUpdateApiUpdateItem
     */
    readonly itemId: string

    /**
     * The new item properties.
     * @type {BaseItemDto}
     * @memberof ItemUpdateApiUpdateItem
     */
    readonly baseItemDto: BaseItemDto
}

/**
 * Request parameters for updateItemContentType operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiUpdateItemContentTypeRequest
 */
export interface ItemUpdateApiUpdateItemContentTypeRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof ItemUpdateApiUpdateItemContentType
     */
    readonly itemId: string

    /**
     * The content type of the item.
     * @type {string}
     * @memberof ItemUpdateApiUpdateItemContentType
     */
    readonly contentType?: string
}

/**
 * ItemUpdateApi - object-oriented interface
 * @export
 * @class ItemUpdateApi
 * @extends {BaseAPI}
 */
export class ItemUpdateApi extends BaseAPI {
    /**
     * 
     * @summary Gets metadata editor info for an item.
     * @param {ItemUpdateApiGetMetadataEditorInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public getMetadataEditorInfo(requestParameters: ItemUpdateApiGetMetadataEditorInfoRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).getMetadataEditorInfo(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item.
     * @param {ItemUpdateApiUpdateItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItem(requestParameters: ItemUpdateApiUpdateItemRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItem(requestParameters.itemId, requestParameters.baseItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item\'s content type.
     * @param {ItemUpdateApiUpdateItemContentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItemContentType(requestParameters: ItemUpdateApiUpdateItemContentTypeRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItemContentType(requestParameters.itemId, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems.');
            }
            const localVarPath = `/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems2.');
            }
            const localVarPath = `/Users/{uId}/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems: async (userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getResumeItems.');
            }
            const localVarPath = `/Users/{userId}/Items/Resume`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} uId The user id supplied in the /Users/{uid}/Items.
         * @param {string} [userId] The user id supplied as query parameter.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets items based on a query.
         * @param {string} userId The user id.
         * @param {number} [startIndex] The start index.
         * @param {number} [limit] The item limit.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getItems operation in ItemsApi.
 * @export
 * @interface ItemsApiGetItemsRequest
 */
export interface ItemsApiGetItemsRequest {
    /**
     * The user id supplied in the /Users/{uid}/Items.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly uId: string

    /**
     * The user id supplied as query parameter.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly userId?: string

    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly maxOfficialRating?: string

    /**
     * Optional filter by items with theme songs.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasThemeSong?: boolean

    /**
     * Optional filter by items with theme videos.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasThemeVideo?: boolean

    /**
     * Optional filter by items with subtitles.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasSubtitles?: boolean

    /**
     * Optional filter by items with special features.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasSpecialFeature?: boolean

    /**
     * Optional filter by items with trailers.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTrailer?: boolean

    /**
     * Optional. Return items that are siblings of a supplied item.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly adjacentTo?: string

    /**
     * Optional filter by parent index number.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly parentIndexNumber?: number

    /**
     * Optional filter by items that have or do not have a parental rating.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasParentalRating?: boolean

    /**
     * Optional filter by items that are HD or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isHd?: boolean

    /**
     * Optional filter by items that are 4K or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly is4K?: boolean

    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly locationTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @type {Array<LocationType>}
     * @memberof ItemsApiGetItems
     */
    readonly excludeLocationTypes?: Array<LocationType>

    /**
     * Optional filter by items that are missing episodes or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isMissing?: boolean

    /**
     * Optional filter by items that are unaired episodes or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isUnaired?: boolean

    /**
     * Optional filter by minimum community rating.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minCommunityRating?: number

    /**
     * Optional filter by minimum critic rating.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minCriticRating?: number

    /**
     * Optional. The minimum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minPremiereDate?: string

    /**
     * Optional. The minimum last saved date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minDateLastSaved?: string

    /**
     * Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minDateLastSavedForUser?: string

    /**
     * Optional. The maximum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly maxPremiereDate?: string

    /**
     * Optional filter by items that have an overview or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasOverview?: boolean

    /**
     * Optional filter by items that have an imdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasImdbId?: boolean

    /**
     * Optional filter by items that have a tmdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTmdbId?: boolean

    /**
     * Optional filter by items that have a tvdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTvdbId?: boolean

    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeItemIds?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly limit?: number

    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly recursive?: boolean

    /**
     * Optional. Filter based on a search term.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly searchTerm?: string

    /**
     * Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly sortOrder?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @type {Array<ItemFields>}
     * @memberof ItemsApiGetItems
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @type {Array<ItemFilter>}
     * @memberof ItemsApiGetItems
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isFavorite?: boolean

    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly mediaTypes?: string

    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @type {Array<ImageType>}
     * @memberof ItemsApiGetItems
     */
    readonly imageTypes?: Array<ImageType>

    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly sortBy?: string

    /**
     * Optional filter by items that are played, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isPlayed?: boolean

    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly genres?: string

    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly officialRatings?: string

    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly tags?: string

    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly years?: string

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof ItemsApiGetItems
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly person?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly personIds?: string

    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly studios?: string

    /**
     * Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly artists?: string

    /**
     * Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly artistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albumArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly contributingArtistIds?: string

    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albums?: string

    /**
     * Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albumIds?: string

    /**
     * Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly ids?: string

    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly videoTypes?: string

    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minOfficialRating?: string

    /**
     * Optional filter by items that are locked.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isLocked?: boolean

    /**
     * Optional filter by items that are placeholders.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isPlaceHolder?: boolean

    /**
     * Optional filter by items that have official ratings.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasOfficialRating?: boolean

    /**
     * Whether or not to hide items behind their boxsets.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * Optional. Filter by the minimum width of the item.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minWidth?: number

    /**
     * Optional. Filter by the minimum height of the item.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minHeight?: number

    /**
     * Optional. Filter by the maximum width of the item.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly maxWidth?: number

    /**
     * Optional. Filter by the maximum height of the item.
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly maxHeight?: number

    /**
     * Optional filter by items that are 3D, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly is3D?: boolean

    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly seriesStatus?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameLessThan?: string

    /**
     * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly studioIds?: string

    /**
     * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly genreIds?: string

    /**
     * Optional. Enable the total record count.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableImages?: boolean
}

/**
 * Request parameters for getItems2 operation in ItemsApi.
 * @export
 * @interface ItemsApiGetItems2Request
 */
export interface ItemsApiGetItems2Request {
    /**
     * The user id supplied in the /Users/{uid}/Items.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly uId: string

    /**
     * The user id supplied as query parameter.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly userId?: string

    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly maxOfficialRating?: string

    /**
     * Optional filter by items with theme songs.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasThemeSong?: boolean

    /**
     * Optional filter by items with theme videos.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasThemeVideo?: boolean

    /**
     * Optional filter by items with subtitles.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasSubtitles?: boolean

    /**
     * Optional filter by items with special features.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasSpecialFeature?: boolean

    /**
     * Optional filter by items with trailers.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTrailer?: boolean

    /**
     * Optional. Return items that are siblings of a supplied item.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly adjacentTo?: string

    /**
     * Optional filter by parent index number.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly parentIndexNumber?: number

    /**
     * Optional filter by items that have or do not have a parental rating.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasParentalRating?: boolean

    /**
     * Optional filter by items that are HD or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isHd?: boolean

    /**
     * Optional filter by items that are 4K or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly is4K?: boolean

    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly locationTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @type {Array<LocationType>}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeLocationTypes?: Array<LocationType>

    /**
     * Optional filter by items that are missing episodes or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isMissing?: boolean

    /**
     * Optional filter by items that are unaired episodes or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isUnaired?: boolean

    /**
     * Optional filter by minimum community rating.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minCommunityRating?: number

    /**
     * Optional filter by minimum critic rating.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minCriticRating?: number

    /**
     * Optional. The minimum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minPremiereDate?: string

    /**
     * Optional. The minimum last saved date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minDateLastSaved?: string

    /**
     * Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minDateLastSavedForUser?: string

    /**
     * Optional. The maximum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly maxPremiereDate?: string

    /**
     * Optional filter by items that have an overview or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasOverview?: boolean

    /**
     * Optional filter by items that have an imdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasImdbId?: boolean

    /**
     * Optional filter by items that have a tmdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTmdbId?: boolean

    /**
     * Optional filter by items that have a tvdb id or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTvdbId?: boolean

    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeItemIds?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly limit?: number

    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly recursive?: boolean

    /**
     * Optional. Filter based on a search term.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly searchTerm?: string

    /**
     * Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly sortOrder?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @type {Array<ItemFields>}
     * @memberof ItemsApiGetItems2
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @type {Array<ItemFilter>}
     * @memberof ItemsApiGetItems2
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isFavorite?: boolean

    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly mediaTypes?: string

    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @type {Array<ImageType>}
     * @memberof ItemsApiGetItems2
     */
    readonly imageTypes?: Array<ImageType>

    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly sortBy?: string

    /**
     * Optional filter by items that are played, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isPlayed?: boolean

    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly genres?: string

    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly officialRatings?: string

    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly tags?: string

    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly years?: string

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof ItemsApiGetItems2
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly person?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly personIds?: string

    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly studios?: string

    /**
     * Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly artists?: string

    /**
     * Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly artistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albumArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly contributingArtistIds?: string

    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albums?: string

    /**
     * Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albumIds?: string

    /**
     * Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly ids?: string

    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly videoTypes?: string

    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minOfficialRating?: string

    /**
     * Optional filter by items that are locked.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isLocked?: boolean

    /**
     * Optional filter by items that are placeholders.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isPlaceHolder?: boolean

    /**
     * Optional filter by items that have official ratings.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasOfficialRating?: boolean

    /**
     * Whether or not to hide items behind their boxsets.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * Optional. Filter by the minimum width of the item.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minWidth?: number

    /**
     * Optional. Filter by the minimum height of the item.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minHeight?: number

    /**
     * Optional. Filter by the maximum width of the item.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly maxWidth?: number

    /**
     * Optional. Filter by the maximum height of the item.
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly maxHeight?: number

    /**
     * Optional filter by items that are 3D, or not.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly is3D?: boolean

    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly seriesStatus?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameLessThan?: string

    /**
     * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly studioIds?: string

    /**
     * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly genreIds?: string

    /**
     * Optional. Enable the total record count.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableImages?: boolean
}

/**
 * Request parameters for getResumeItems operation in ItemsApi.
 * @export
 * @interface ItemsApiGetResumeItemsRequest
 */
export interface ItemsApiGetResumeItemsRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly userId: string

    /**
     * The start index.
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly startIndex?: number

    /**
     * The item limit.
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly limit?: number

    /**
     * The search term.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @type {Array<ItemFields>}
     * @memberof ItemsApiGetResumeItems
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly mediaTypes?: string

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Enable the total record count.
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableImages?: boolean
}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @summary Gets items based on a query.
     * @param {ItemsApiGetItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems(requestParameters: ItemsApiGetItemsRequest, options?: any) {
        return ItemsApiFp(this.configuration).getItems(requestParameters.uId, requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets items based on a query.
     * @param {ItemsApiGetItems2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems2(requestParameters: ItemsApiGetItems2Request, options?: any) {
        return ItemsApiFp(this.configuration).getItems2(requestParameters.uId, requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets items based on a query.
     * @param {ItemsApiGetResumeItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getResumeItems(requestParameters: ItemsApiGetResumeItemsRequest, options?: any) {
        return ItemsApiFp(this.configuration).getResumeItems(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.mediaTypes, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (ids?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAncestors.');
            }
            const localVarPath = `/Items/{itemId}/Ancestors`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getCriticReviews.');
            }
            const localVarPath = `/Items/{itemId}/CriticReviews`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getDownload.');
            }
            const localVarPath = `/Items/{itemId}/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getFile.');
            }
            const localVarPath = `/Items/{itemId}/File`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts: async (userId?: string, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo: async (libraryContentType?: string, isNewLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Libraries/AvailableOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (libraryContentType !== undefined) {
                localVarQueryParameter['libraryContentType'] = libraryContentType;
            }

            if (isNewLibrary !== undefined) {
                localVarQueryParameter['isNewLibrary'] = isNewLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders: async (isHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/MediaFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/PhysicalPaths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems.');
            }
            const localVarPath = `/Albums/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_1: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems_1.');
            }
            const localVarPath = `/Artists/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems_2.');
            }
            const localVarPath = `/Items/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_3: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems_3.');
            }
            const localVarPath = `/Movies/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_4: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems_4.');
            }
            const localVarPath = `/Shows/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_5: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems_5.');
            }
            const localVarPath = `/Trailers/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeMedia.');
            }
            const localVarPath = `/Items/{itemId}/ThemeMedia`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeSongs.');
            }
            const localVarPath = `/Items/{itemId}/ThemeSongs`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeVideos.');
            }
            const localVarPath = `/Items/{itemId}/ThemeVideos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies: async (tmdbId?: string, imdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }

            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia: async (mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaUpdateInfoDto' is not null or undefined
            if (mediaUpdateInfoDto === null || mediaUpdateInfoDto === undefined) {
                throw new RequiredError('mediaUpdateInfoDto','Required parameter mediaUpdateInfoDto was null or undefined when calling postUpdatedMedia.');
            }
            const localVarPath = `/Library/Media/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaUpdateInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaUpdateInfoDto !== undefined ? mediaUpdateInfoDto : {}) : (mediaUpdateInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies: async (tmdbId?: string, imdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Movies/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tmdbId !== undefined) {
                localVarQueryParameter['tmdbId'] = tmdbId;
            }

            if (imdbId !== undefined) {
                localVarQueryParameter['imdbId'] = imdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItem(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(ids?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItems(ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAncestors(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getAncestors(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCriticReviews(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getCriticReviews(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getDownload(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getFile(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCounts(userId?: string, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCounts>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getItemCounts(userId, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryOptionsResultDto>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFolders(isHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getMediaFolders(isHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalPaths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getPhysicalPaths(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems_1(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems_1(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems_2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems_2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems_3(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems_3(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems_4(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems_4(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems_5(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems_5(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeMedia(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeSongs(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeVideos(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedMovies(tmdbId?: string, imdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMedia(mediaUpdateInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMovies(tmdbId?: string, imdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLibrary(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).refreshLibrary(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes an item from the library and filesystem.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes items from the library and filesystem.
         * @param {string} [ids] The item ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(ids?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItems(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all parents of an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors(itemId: string, userId?: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return LibraryApiFp(configuration).getAncestors(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets critic review for an item.
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews(itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getCriticReviews(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads item media.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(itemId: string, options?: any): AxiosPromise<any> {
            return LibraryApiFp(configuration).getDownload(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the original file of an item.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(itemId: string, options?: any): AxiosPromise<any> {
            return LibraryApiFp(configuration).getFile(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get item counts.
         * @param {string} [userId] Optional. Get counts from a specific user\&#39;s library.
         * @param {boolean} [isFavorite] Optional. Get counts of favorite items.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts(userId?: string, isFavorite?: boolean, options?: any): AxiosPromise<ItemCounts> {
            return LibraryApiFp(configuration).getItemCounts(userId, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the library options info.
         * @param {string} [libraryContentType] Library content type.
         * @param {boolean} [isNewLibrary] Whether this is a new library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): AxiosPromise<LibraryOptionsResultDto> {
            return LibraryApiFp(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all user media folders.
         * @param {boolean} [isHidden] Optional. Filter by folders that are marked hidden, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders(isHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getMediaFolders(isHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of physical paths from virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths(options?: any): AxiosPromise<Array<string>> {
            return LibraryApiFp(configuration).getPhysicalPaths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_1(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems_1(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems_2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_3(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems_3(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_4(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems_4(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets similar items.
         * @param {string} itemId The item id.
         * @param {string} [excludeArtistIds] Exclude artist ids.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems_5(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: Array<ItemFields>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems_5(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme songs and videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<AllThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeMedia(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme songs for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeSongs(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get theme videos for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {boolean} [inheritFromParent] Optional. Determines whether or not parent items should be searched for theme media.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeVideos(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies(tmdbId?: string, imdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto A list of updated media paths.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMedia(mediaUpdateInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new movies have been added by an external source.
         * @param {string} [tmdbId] The tmdbId.
         * @param {string} [imdbId] The imdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies(tmdbId?: string, imdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that new episodes of a series have been added by an external source.
         * @param {string} [tvdbId] The tvdbId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Starts a library scan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary(options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).refreshLibrary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteItem operation in LibraryApi.
 * @export
 * @interface LibraryApiDeleteItemRequest
 */
export interface LibraryApiDeleteItemRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiDeleteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for deleteItems operation in LibraryApi.
 * @export
 * @interface LibraryApiDeleteItemsRequest
 */
export interface LibraryApiDeleteItemsRequest {
    /**
     * The item ids.
     * @type {string}
     * @memberof LibraryApiDeleteItems
     */
    readonly ids?: string
}

/**
 * Request parameters for getAncestors operation in LibraryApi.
 * @export
 * @interface LibraryApiGetAncestorsRequest
 */
export interface LibraryApiGetAncestorsRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetAncestors
     */
    readonly itemId: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetAncestors
     */
    readonly userId?: string
}

/**
 * Request parameters for getCriticReviews operation in LibraryApi.
 * @export
 * @interface LibraryApiGetCriticReviewsRequest
 */
export interface LibraryApiGetCriticReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetCriticReviews
     */
    readonly itemId: string
}

/**
 * Request parameters for getDownload operation in LibraryApi.
 * @export
 * @interface LibraryApiGetDownloadRequest
 */
export interface LibraryApiGetDownloadRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetDownload
     */
    readonly itemId: string
}

/**
 * Request parameters for getFile operation in LibraryApi.
 * @export
 * @interface LibraryApiGetFileRequest
 */
export interface LibraryApiGetFileRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetFile
     */
    readonly itemId: string
}

/**
 * Request parameters for getItemCounts operation in LibraryApi.
 * @export
 * @interface LibraryApiGetItemCountsRequest
 */
export interface LibraryApiGetItemCountsRequest {
    /**
     * Optional. Get counts from a specific user\&#39;s library.
     * @type {string}
     * @memberof LibraryApiGetItemCounts
     */
    readonly userId?: string

    /**
     * Optional. Get counts of favorite items.
     * @type {boolean}
     * @memberof LibraryApiGetItemCounts
     */
    readonly isFavorite?: boolean
}

/**
 * Request parameters for getLibraryOptionsInfo operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryOptionsInfoRequest
 */
export interface LibraryApiGetLibraryOptionsInfoRequest {
    /**
     * Library content type.
     * @type {string}
     * @memberof LibraryApiGetLibraryOptionsInfo
     */
    readonly libraryContentType?: string

    /**
     * Whether this is a new library.
     * @type {boolean}
     * @memberof LibraryApiGetLibraryOptionsInfo
     */
    readonly isNewLibrary?: boolean
}

/**
 * Request parameters for getMediaFolders operation in LibraryApi.
 * @export
 * @interface LibraryApiGetMediaFoldersRequest
 */
export interface LibraryApiGetMediaFoldersRequest {
    /**
     * Optional. Filter by folders that are marked hidden, or not.
     * @type {boolean}
     * @memberof LibraryApiGetMediaFolders
     */
    readonly isHidden?: boolean
}

/**
 * Request parameters for getSimilarItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItemsRequest
 */
export interface LibraryApiGetSimilarItemsRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getSimilarItems_1 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItems0Request
 */
export interface LibraryApiGetSimilarItems0Request {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems0
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems0
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems0
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems0
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems0
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getSimilarItems_2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItems1Request
 */
export interface LibraryApiGetSimilarItems1Request {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems1
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems1
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems1
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems1
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems1
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getSimilarItems_3 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItems2Request
 */
export interface LibraryApiGetSimilarItems2Request {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems2
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems2
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems2
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems2
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems2
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getSimilarItems_4 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItems3Request
 */
export interface LibraryApiGetSimilarItems3Request {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems3
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems3
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems3
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems3
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems3
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getSimilarItems_5 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItems4Request
 */
export interface LibraryApiGetSimilarItems4Request {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems4
     */
    readonly itemId: string

    /**
     * Exclude artist ids.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems4
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetSimilarItems4
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LibraryApiGetSimilarItems4
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof LibraryApiGetSimilarItems4
     */
    readonly fields?: Array<ItemFields>
}

/**
 * Request parameters for getThemeMedia operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeMediaRequest
 */
export interface LibraryApiGetThemeMediaRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly itemId: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly userId?: string

    /**
     * Optional. Determines whether or not parent items should be searched for theme media.
     * @type {boolean}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for getThemeSongs operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeSongsRequest
 */
export interface LibraryApiGetThemeSongsRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly itemId: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly userId?: string

    /**
     * Optional. Determines whether or not parent items should be searched for theme media.
     * @type {boolean}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for getThemeVideos operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeVideosRequest
 */
export interface LibraryApiGetThemeVideosRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly itemId: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly userId?: string

    /**
     * Optional. Determines whether or not parent items should be searched for theme media.
     * @type {boolean}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for postAddedMovies operation in LibraryApi.
 * @export
 * @interface LibraryApiPostAddedMoviesRequest
 */
export interface LibraryApiPostAddedMoviesRequest {
    /**
     * The tmdbId.
     * @type {string}
     * @memberof LibraryApiPostAddedMovies
     */
    readonly tmdbId?: string

    /**
     * The imdbId.
     * @type {string}
     * @memberof LibraryApiPostAddedMovies
     */
    readonly imdbId?: string
}

/**
 * Request parameters for postAddedSeries operation in LibraryApi.
 * @export
 * @interface LibraryApiPostAddedSeriesRequest
 */
export interface LibraryApiPostAddedSeriesRequest {
    /**
     * The tvdbId.
     * @type {string}
     * @memberof LibraryApiPostAddedSeries
     */
    readonly tvdbId?: string
}

/**
 * Request parameters for postUpdatedMedia operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedMediaRequest
 */
export interface LibraryApiPostUpdatedMediaRequest {
    /**
     * A list of updated media paths.
     * @type {Array<MediaUpdateInfoDto>}
     * @memberof LibraryApiPostUpdatedMedia
     */
    readonly mediaUpdateInfoDto: Array<MediaUpdateInfoDto>
}

/**
 * Request parameters for postUpdatedMovies operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedMoviesRequest
 */
export interface LibraryApiPostUpdatedMoviesRequest {
    /**
     * The tmdbId.
     * @type {string}
     * @memberof LibraryApiPostUpdatedMovies
     */
    readonly tmdbId?: string

    /**
     * The imdbId.
     * @type {string}
     * @memberof LibraryApiPostUpdatedMovies
     */
    readonly imdbId?: string
}

/**
 * Request parameters for postUpdatedSeries operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedSeriesRequest
 */
export interface LibraryApiPostUpdatedSeriesRequest {
    /**
     * The tvdbId.
     * @type {string}
     * @memberof LibraryApiPostUpdatedSeries
     */
    readonly tvdbId?: string
}

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an item from the library and filesystem.
     * @param {LibraryApiDeleteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItem(requestParameters: LibraryApiDeleteItemRequest, options?: any) {
        return LibraryApiFp(this.configuration).deleteItem(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes items from the library and filesystem.
     * @param {LibraryApiDeleteItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItems(requestParameters: LibraryApiDeleteItemsRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).deleteItems(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all parents of an item.
     * @param {LibraryApiGetAncestorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getAncestors(requestParameters: LibraryApiGetAncestorsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getAncestors(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets critic review for an item.
     * @param {LibraryApiGetCriticReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getCriticReviews(requestParameters: LibraryApiGetCriticReviewsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getCriticReviews(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads item media.
     * @param {LibraryApiGetDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getDownload(requestParameters: LibraryApiGetDownloadRequest, options?: any) {
        return LibraryApiFp(this.configuration).getDownload(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the original file of an item.
     * @param {LibraryApiGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getFile(requestParameters: LibraryApiGetFileRequest, options?: any) {
        return LibraryApiFp(this.configuration).getFile(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get item counts.
     * @param {LibraryApiGetItemCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getItemCounts(requestParameters: LibraryApiGetItemCountsRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getItemCounts(requestParameters.userId, requestParameters.isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the library options info.
     * @param {LibraryApiGetLibraryOptionsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryOptionsInfo(requestParameters: LibraryApiGetLibraryOptionsInfoRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getLibraryOptionsInfo(requestParameters.libraryContentType, requestParameters.isNewLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all user media folders.
     * @param {LibraryApiGetMediaFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getMediaFolders(requestParameters: LibraryApiGetMediaFoldersRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getMediaFolders(requestParameters.isHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of physical paths from virtual folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getPhysicalPaths(options?: any) {
        return LibraryApiFp(this.configuration).getPhysicalPaths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems(requestParameters: LibraryApiGetSimilarItemsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItems0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems_1(requestParameters: LibraryApiGetSimilarItems0Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems_1(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItems1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems_2(requestParameters: LibraryApiGetSimilarItems1Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems_2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItems2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems_3(requestParameters: LibraryApiGetSimilarItems2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems_3(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItems3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems_4(requestParameters: LibraryApiGetSimilarItems3Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems_4(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets similar items.
     * @param {LibraryApiGetSimilarItems4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems_5(requestParameters: LibraryApiGetSimilarItems4Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems_5(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme songs and videos for an item.
     * @param {LibraryApiGetThemeMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeMedia(requestParameters: LibraryApiGetThemeMediaRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeMedia(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme songs for an item.
     * @param {LibraryApiGetThemeSongsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeSongs(requestParameters: LibraryApiGetThemeSongsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeSongs(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get theme videos for an item.
     * @param {LibraryApiGetThemeVideosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeVideos(requestParameters: LibraryApiGetThemeVideosRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeVideos(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostAddedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedMovies(requestParameters: LibraryApiPostAddedMoviesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postAddedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {LibraryApiPostAddedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedSeries(requestParameters: LibraryApiPostAddedSeriesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postAddedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostUpdatedMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMedia(requestParameters: LibraryApiPostUpdatedMediaRequest, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMedia(requestParameters.mediaUpdateInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new movies have been added by an external source.
     * @param {LibraryApiPostUpdatedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMovies(requestParameters: LibraryApiPostUpdatedMoviesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that new episodes of a series have been added by an external source.
     * @param {LibraryApiPostUpdatedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedSeries(requestParameters: LibraryApiPostUpdatedSeriesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Starts a library scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public refreshLibrary(options?: any) {
        return LibraryApiFp(this.configuration).refreshLibrary(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryStructureApi - axios parameter creator
 * @export
 */
export const LibraryStructureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath: async (mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaPathDto' is not null or undefined
            if (mediaPathDto === null || mediaPathDto === undefined) {
                throw new RequiredError('mediaPathDto','Required parameter mediaPathDto was null or undefined when calling addMediaPath.');
            }
            const localVarPath = `/Library/VirtualFolders/Paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathDto !== undefined ? mediaPathDto : {}) : (mediaPathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder: async (name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (collectionType !== undefined) {
                localVarQueryParameter['collectionType'] = collectionType;
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof addVirtualFolderDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addVirtualFolderDto !== undefined ? addVirtualFolderDto : {}) : (addVirtualFolderDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath: async (name?: string, path?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder: async (name?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder: async (name?: string, newName?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (newName !== undefined) {
                localVarQueryParameter['newName'] = newName;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions: async (updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/LibraryOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateLibraryOptionsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateLibraryOptionsDto !== undefined ? updateLibraryOptionsDto : {}) : (updateLibraryOptionsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath: async (name?: string, mediaPathInfo?: MediaPathInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths/Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathInfo !== undefined ? mediaPathInfo : {}) : (mediaPathInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryStructureApi - functional programming interface
 * @export
 */
export const LibraryStructureApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addMediaPath(mediaPathDto, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualFolders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualFolderInfo>>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).getVirtualFolders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeMediaPath(name, path, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeVirtualFolder(name, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).renameVirtualFolder(name, newName, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateLibraryOptions(updateLibraryOptionsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateMediaPath(name, mediaPathInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryStructureApi - factory interface
 * @export
 */
export const LibraryStructureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a media path to a library.
         * @param {MediaPathDto} mediaPathDto The media path dto.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addMediaPath(mediaPathDto, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [collectionType] The type of the collection.
         * @param {Array<string>} [paths] The paths of the virtual folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] The library options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all virtual folders.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders(options?: any): AxiosPromise<Array<VirtualFolderInfo>> {
            return LibraryStructureApiFp(configuration).getVirtualFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a media path.
         * @param {string} [name] The name of the library.
         * @param {string} [path] The path to remove.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeMediaPath(name, path, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a virtual folder.
         * @param {string} [name] The name of the folder.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeVirtualFolder(name, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renames a virtual folder.
         * @param {string} [name] The name of the virtual folder.
         * @param {string} [newName] The new name.
         * @param {boolean} [refreshLibrary] Whether to refresh the library.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).renameVirtualFolder(name, newName, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update library options.
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] The library name and options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateLibraryOptions(updateLibraryOptionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a media path.
         * @param {string} [name] The name of the library.
         * @param {MediaPathInfo} [mediaPathInfo] The path info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateMediaPath(name, mediaPathInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiAddMediaPathRequest
 */
export interface LibraryStructureApiAddMediaPathRequest {
    /**
     * The media path dto.
     * @type {MediaPathDto}
     * @memberof LibraryStructureApiAddMediaPath
     */
    readonly mediaPathDto: MediaPathDto

    /**
     * Whether to refresh the library.
     * @type {boolean}
     * @memberof LibraryStructureApiAddMediaPath
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for addVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiAddVirtualFolderRequest
 */
export interface LibraryStructureApiAddVirtualFolderRequest {
    /**
     * The name of the virtual folder.
     * @type {string}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly name?: string

    /**
     * The type of the collection.
     * @type {string}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly collectionType?: string

    /**
     * The paths of the virtual folder.
     * @type {Array<string>}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly paths?: Array<string>

    /**
     * Whether to refresh the library.
     * @type {boolean}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly refreshLibrary?: boolean

    /**
     * The library options.
     * @type {AddVirtualFolderDto}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly addVirtualFolderDto?: AddVirtualFolderDto
}

/**
 * Request parameters for removeMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRemoveMediaPathRequest
 */
export interface LibraryStructureApiRemoveMediaPathRequest {
    /**
     * The name of the library.
     * @type {string}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly name?: string

    /**
     * The path to remove.
     * @type {string}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly path?: string

    /**
     * Whether to refresh the library.
     * @type {boolean}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for removeVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRemoveVirtualFolderRequest
 */
export interface LibraryStructureApiRemoveVirtualFolderRequest {
    /**
     * The name of the folder.
     * @type {string}
     * @memberof LibraryStructureApiRemoveVirtualFolder
     */
    readonly name?: string

    /**
     * Whether to refresh the library.
     * @type {boolean}
     * @memberof LibraryStructureApiRemoveVirtualFolder
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for renameVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRenameVirtualFolderRequest
 */
export interface LibraryStructureApiRenameVirtualFolderRequest {
    /**
     * The name of the virtual folder.
     * @type {string}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly name?: string

    /**
     * The new name.
     * @type {string}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly newName?: string

    /**
     * Whether to refresh the library.
     * @type {boolean}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for updateLibraryOptions operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiUpdateLibraryOptionsRequest
 */
export interface LibraryStructureApiUpdateLibraryOptionsRequest {
    /**
     * The library name and options.
     * @type {UpdateLibraryOptionsDto}
     * @memberof LibraryStructureApiUpdateLibraryOptions
     */
    readonly updateLibraryOptionsDto?: UpdateLibraryOptionsDto
}

/**
 * Request parameters for updateMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiUpdateMediaPathRequest
 */
export interface LibraryStructureApiUpdateMediaPathRequest {
    /**
     * The name of the library.
     * @type {string}
     * @memberof LibraryStructureApiUpdateMediaPath
     */
    readonly name?: string

    /**
     * The path info.
     * @type {MediaPathInfo}
     * @memberof LibraryStructureApiUpdateMediaPath
     */
    readonly mediaPathInfo?: MediaPathInfo
}

/**
 * LibraryStructureApi - object-oriented interface
 * @export
 * @class LibraryStructureApi
 * @extends {BaseAPI}
 */
export class LibraryStructureApi extends BaseAPI {
    /**
     * 
     * @summary Add a media path to a library.
     * @param {LibraryStructureApiAddMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addMediaPath(requestParameters: LibraryStructureApiAddMediaPathRequest, options?: any) {
        return LibraryStructureApiFp(this.configuration).addMediaPath(requestParameters.mediaPathDto, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a virtual folder.
     * @param {LibraryStructureApiAddVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addVirtualFolder(requestParameters: LibraryStructureApiAddVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).addVirtualFolder(requestParameters.name, requestParameters.collectionType, requestParameters.paths, requestParameters.refreshLibrary, requestParameters.addVirtualFolderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all virtual folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public getVirtualFolders(options?: any) {
        return LibraryStructureApiFp(this.configuration).getVirtualFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a media path.
     * @param {LibraryStructureApiRemoveMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeMediaPath(requestParameters: LibraryStructureApiRemoveMediaPathRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeMediaPath(requestParameters.name, requestParameters.path, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a virtual folder.
     * @param {LibraryStructureApiRemoveVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeVirtualFolder(requestParameters: LibraryStructureApiRemoveVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeVirtualFolder(requestParameters.name, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renames a virtual folder.
     * @param {LibraryStructureApiRenameVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public renameVirtualFolder(requestParameters: LibraryStructureApiRenameVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).renameVirtualFolder(requestParameters.name, requestParameters.newName, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update library options.
     * @param {LibraryStructureApiUpdateLibraryOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateLibraryOptions(requestParameters: LibraryStructureApiUpdateLibraryOptionsRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateLibraryOptions(requestParameters.updateLibraryOptionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a media path.
     * @param {LibraryStructureApiUpdateMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateMediaPath(requestParameters: LibraryStructureApiUpdateMediaPathRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateMediaPath(requestParameters.name, requestParameters.mediaPathInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiveTvApi - axios parameter creator
 * @export
 */
export const LiveTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider: async (pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (validateListings !== undefined) {
                localVarQueryParameter['validateListings'] = validateListings;
            }

            if (validateLogin !== undefined) {
                localVarQueryParameter['validateLogin'] = validateLogin;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof listingsProviderInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(listingsProviderInfo !== undefined ? listingsProviderInfo : {}) : (listingsProviderInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost: async (tunerHostInfo?: TunerHostInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tunerHostInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tunerHostInfo !== undefined ? tunerHostInfo : {}) : (tunerHostInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer: async (seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling deleteRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners: async (newDevicesOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannel.');
            }
            const localVarPath = `/LiveTv/Channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions: async (providerId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer: async (programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups: async (id?: string, type?: string, location?: string, country?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getLiveRecordingFile.');
            }
            const localVarPath = `/LiveTv/LiveRecordings/{recordingId}/stream`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile: async (streamId: string, container: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling getLiveStreamFile.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getLiveStreamFile.');
            }
            const localVarPath = `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels: async (type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['isLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['isDisliked'] = isDisliked;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['enableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['addCurrentProgram'] = addCurrentProgram;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms: async (channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['minStartDate'] = (minStartDate as any instanceof Date) ?
                    (minStartDate as any).toISOString() :
                    minStartDate;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['maxStartDate'] = (maxStartDate as any instanceof Date) ?
                    (maxStartDate as any).toISOString() :
                    maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['minEndDate'] = (minEndDate as any instanceof Date) ?
                    (minEndDate as any).toISOString() :
                    minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['maxEndDate'] = (maxEndDate as any instanceof Date) ?
                    (maxEndDate as any).toISOString() :
                    maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (librarySeriesId !== undefined) {
                localVarQueryParameter['librarySeriesId'] = librarySeriesId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            if (programId === null || programId === undefined) {
                throw new RequiredError('programId','Required parameter programId was null or undefined when calling getProgram.');
            }
            const localVarPath = `/LiveTv/Programs/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms: async (getProgramsDto?: GetProgramsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof getProgramsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(getProgramsDto !== undefined ? getProgramsDto : {}) : (getProgramsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms: async (userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: string, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording: async (recordingId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getRecordingGroup.');
            }
            const localVarPath = `/LiveTv/Recordings/Groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings: async (channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isLibraryItem !== undefined) {
                localVarQueryParameter['isLibraryItem'] = isLibraryItem;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries: async (channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers: async (sortBy?: string, sortOrder?: SortOrder, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers: async (channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['isScheduled'] = isScheduled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner: async (tunerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunerId' is not null or undefined
            if (tunerId === null || tunerId === undefined) {
                throw new RequiredError('tunerId','Required parameter tunerId was null or undefined when calling resetTuner.');
            }
            const localVarPath = `/LiveTv/Tuners/{tunerId}/Reset`
                .replace(`{${"tunerId"}}`, encodeURIComponent(String(tunerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping: async (providerId?: string, tunerChannelId?: string, providerChannelId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }

            if (tunerChannelId !== undefined) {
                localVarQueryParameter['tunerChannelId'] = tunerChannelId;
            }

            if (providerChannelId !== undefined) {
                localVarQueryParameter['providerChannelId'] = providerChannelId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer: async (timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (timerId: string, timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvApi - functional programming interface
 * @export
 */
export const LiveTvApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerHostInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addTunerHost(tunerHostInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createSeriesTimer(seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createTimer(timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListingProvider(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteListingProvider(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteRecording(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunerHost(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteTunerHost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTuners(newDevicesOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).discoverTuners(newDevicesOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannel(channelId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMappingOptions(providerId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMappingOptionsDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannelMappingOptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultListingProvider(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultListingProvider(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTimer(programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultTimer(programId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuideInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuideInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getGuideInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLineups(id, type, location, country, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveRecordingFile(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveRecordingFile(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveStreamFile(streamId: string, container: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveStreamFile(streamId, container, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getProgram(programId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrograms(getProgramsDto?: GetProgramsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getPrograms(getProgramsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: string, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecording(recordingId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecording(recordingId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingFolders(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingFolders(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroups(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroups(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulesDirectCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSchedulesDirectCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimers(sortBy, sortOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTunerHostTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTunerHostTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuner(tunerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).resetTuner(tunerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerChannelMapping>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateTimer(timerId, timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LiveTvApi - factory interface
 * @export
 */
export const LiveTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds a listings provider.
         * @param {string} [pw] Password.
         * @param {boolean} [validateListings] Validate listings.
         * @param {boolean} [validateLogin] Validate login.
         * @param {ListingsProviderInfo} [listingsProviderInfo] New listings info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a tuner host.
         * @param {TunerHostInfo} [tunerHostInfo] New tuner host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): AxiosPromise<TunerHostInfo> {
            return LiveTvApiFp(configuration).addTunerHost(tunerHostInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a live tv timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv series timer.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createSeriesTimer(seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a live tv timer.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createTimer(timerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete listing provider.
         * @param {string} [id] Listing provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteListingProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(recordingId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteRecording(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a tuner host.
         * @param {string} [id] Tuner host id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteTunerHost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Discover tuners.
         * @param {boolean} [newDevicesOnly] Only discover new tuners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>> {
            return LiveTvApiFp(configuration).discoverTuners(newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel.
         * @param {string} channelId Channel id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getChannel(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get channel mapping options.
         * @param {string} [providerId] Provider id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions(providerId?: string, options?: any): AxiosPromise<ChannelMappingOptionsDto> {
            return LiveTvApiFp(configuration).getChannelMappingOptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets default listings provider info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider(options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).getDefaultListingProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the default values for a new timer.
         * @param {string} [programId] Optional. To attach default values based on a program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer(programId?: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getDefaultTimer(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get guid info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo(options?: any): AxiosPromise<GuideInfo> {
            return LiveTvApiFp(configuration).getGuideInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available lineups.
         * @param {string} [id] Provider id.
         * @param {string} [type] Provider type.
         * @param {string} [location] Location.
         * @param {string} [country] Country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getLineups(id, type, location, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording stream.
         * @param {string} recordingId Recording id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile(recordingId: string, options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getLiveRecordingFile(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv channel stream.
         * @param {string} streamId Stream id.
         * @param {string} container Container type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile(streamId: string, container: string, options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getLiveStreamFile(streamId, container, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv channels.
         * @param {ChannelType} [type] Optional. Filter by channel type.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isFavorite] Optional. Filter by channels that are favorites, or not.
         * @param {boolean} [isLiked] Optional. Filter by channels that are liked, or not.
         * @param {boolean} [isDisliked] Optional. Filter by channels that are disliked, or not.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] \&quot;Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Key to sort by.
         * @param {SortOrder} [sortOrder] Optional. Sort order.
         * @param {boolean} [enableFavoriteSorting] Optional. Incorporate favorite and like status into channel sorting.
         * @param {boolean} [addCurrentProgram] Optional. Adds current program info to each channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo(options?: any): AxiosPromise<LiveTvInfo> {
            return LiveTvApiFp(configuration).getLiveTvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {string} [channelIds] The channels to return guide information for.
         * @param {string} [userId] Optional. Filter by user id.
         * @param {string} [minStartDate] Optional. The minimum premiere start date.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {string} [maxStartDate] Optional. The maximum premiere start date.
         * @param {string} [minEndDate] Optional. The minimum premiere end date.
         * @param {string} [maxEndDate] Optional. The maximum premiere end date.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [genres] The genres to return guide information for.
         * @param {string} [genreIds] The genre ids to return guide information for.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [seriesTimerId] Optional. Filter by series timer id.
         * @param {string} [librarySeriesId] Optional. Filter by library series id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: Array<ItemFields>, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv program.
         * @param {string} programId Program id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(programId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getProgram(programId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available live tv epgs.
         * @param {GetProgramsDto} [getProgramsDto] Request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms(getProgramsDto?: GetProgramsDto, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getPrograms(getProgramsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recommended live tv epgs.
         * @param {string} [userId] Optional. filter by user id.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [isAiring] Optional. Filter by programs that are currently airing, or not.
         * @param {boolean} [hasAired] Optional. Filter by programs that have completed airing, or not.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [genreIds] The genres to return guide information for.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {boolean} [enableTotalRecordCount] Retrieve total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, genreIds?: string, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv recording.
         * @param {string} recordingId Recording id.
         * @param {string} [userId] Optional. Attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording(recordingId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getRecording(recordingId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets recording folders.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingFolders(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recording group.
         * @param {string} groupId Group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup(groupId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getRecordingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording groups.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingGroups(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recordings.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [isMovie] Optional. Filter for movies.
         * @param {boolean} [isSeries] Optional. Filter for series.
         * @param {boolean} [isKids] Optional. Filter for kids.
         * @param {boolean} [isSports] Optional. Filter for sports.
         * @param {boolean} [isNews] Optional. Filter for news.
         * @param {boolean} [isLibraryItem] Optional. Filter for is library item.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv recording series.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [userId] Optional. Filter by user and attach user data.
         * @param {string} [groupId] Optional. Filter by recording group.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {RecordingStatus} [status] Optional. Filter by recording status.
         * @param {boolean} [isInProgress] Optional. Filter by recordings that are in progress, or not.
         * @param {string} [seriesTimerId] Optional. Filter by recordings belonging to a series timer.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Optional. Return total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, fields?: Array<ItemFields>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries(options?: any): AxiosPromise<any> {
            return LiveTvApiFp(configuration).getSchedulesDirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer(timerId: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live tv series timers.
         * @param {string} [sortBy] Optional. Sort by SortName or Priority.
         * @param {SortOrder} [sortOrder] Optional. Sort in Ascending or Descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): AxiosPromise<SeriesTimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getSeriesTimers(sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a timer.
         * @param {string} timerId Timer id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(timerId: string, options?: any): AxiosPromise<TimerInfoDto> {
            return LiveTvApiFp(configuration).getTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the live tv timers.
         * @param {string} [channelId] Optional. Filter by channel id.
         * @param {string} [seriesTimerId] Optional. Filter by timers belonging to a series timer.
         * @param {boolean} [isActive] Optional. Filter by timers that are active.
         * @param {boolean} [isScheduled] Optional. Filter by timers that are scheduled.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): AxiosPromise<TimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tuner host types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes(options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getTunerHostTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resets a tv tuner.
         * @param {string} tunerId Tuner id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner(tunerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).resetTuner(tunerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set channel mappings.
         * @param {string} [providerId] Provider id.
         * @param {string} [tunerChannelId] Tuner channel id.
         * @param {string} [providerChannelId] Provider channel id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): AxiosPromise<TunerChannelMapping> {
            return LiveTvApiFp(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv series timer.
         * @param {string} timerId Timer id.
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] New series timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a live tv timer.
         * @param {string} timerId Timer id.
         * @param {TimerInfoDto} [timerInfoDto] New timer info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateTimer(timerId, timerInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddListingProviderRequest
 */
export interface LiveTvApiAddListingProviderRequest {
    /**
     * Password.
     * @type {string}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly pw?: string

    /**
     * Validate listings.
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateListings?: boolean

    /**
     * Validate login.
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateLogin?: boolean

    /**
     * New listings info.
     * @type {ListingsProviderInfo}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly listingsProviderInfo?: ListingsProviderInfo
}

/**
 * Request parameters for addTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddTunerHostRequest
 */
export interface LiveTvApiAddTunerHostRequest {
    /**
     * New tuner host.
     * @type {TunerHostInfo}
     * @memberof LiveTvApiAddTunerHost
     */
    readonly tunerHostInfo?: TunerHostInfo
}

/**
 * Request parameters for cancelSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelSeriesTimerRequest
 */
export interface LiveTvApiCancelSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiCancelSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for cancelTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelTimerRequest
 */
export interface LiveTvApiCancelTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiCancelTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for createSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateSeriesTimerRequest
 */
export interface LiveTvApiCreateSeriesTimerRequest {
    /**
     * New series timer info.
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiCreateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for createTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateTimerRequest
 */
export interface LiveTvApiCreateTimerRequest {
    /**
     * New timer info.
     * @type {TimerInfoDto}
     * @memberof LiveTvApiCreateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * Request parameters for deleteListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteListingProviderRequest
 */
export interface LiveTvApiDeleteListingProviderRequest {
    /**
     * Listing provider id.
     * @type {string}
     * @memberof LiveTvApiDeleteListingProvider
     */
    readonly id?: string
}

/**
 * Request parameters for deleteRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteRecordingRequest
 */
export interface LiveTvApiDeleteRecordingRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiDeleteRecording
     */
    readonly recordingId: string
}

/**
 * Request parameters for deleteTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteTunerHostRequest
 */
export interface LiveTvApiDeleteTunerHostRequest {
    /**
     * Tuner host id.
     * @type {string}
     * @memberof LiveTvApiDeleteTunerHost
     */
    readonly id?: string
}

/**
 * Request parameters for discoverTuners operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDiscoverTunersRequest
 */
export interface LiveTvApiDiscoverTunersRequest {
    /**
     * Only discover new tuners.
     * @type {boolean}
     * @memberof LiveTvApiDiscoverTuners
     */
    readonly newDevicesOnly?: boolean
}

/**
 * Request parameters for getChannel operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelRequest
 */
export interface LiveTvApiGetChannelRequest {
    /**
     * Channel id.
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly channelId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly userId?: string
}

/**
 * Request parameters for getChannelMappingOptions operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelMappingOptionsRequest
 */
export interface LiveTvApiGetChannelMappingOptionsRequest {
    /**
     * Provider id.
     * @type {string}
     * @memberof LiveTvApiGetChannelMappingOptions
     */
    readonly providerId?: string
}

/**
 * Request parameters for getDefaultTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetDefaultTimerRequest
 */
export interface LiveTvApiGetDefaultTimerRequest {
    /**
     * Optional. To attach default values based on a program.
     * @type {string}
     * @memberof LiveTvApiGetDefaultTimer
     */
    readonly programId?: string
}

/**
 * Request parameters for getLineups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLineupsRequest
 */
export interface LiveTvApiGetLineupsRequest {
    /**
     * Provider id.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly id?: string

    /**
     * Provider type.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly type?: string

    /**
     * Location.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly location?: string

    /**
     * Country.
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly country?: string
}

/**
 * Request parameters for getLiveRecordingFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveRecordingFileRequest
 */
export interface LiveTvApiGetLiveRecordingFileRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiGetLiveRecordingFile
     */
    readonly recordingId: string
}

/**
 * Request parameters for getLiveStreamFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveStreamFileRequest
 */
export interface LiveTvApiGetLiveStreamFileRequest {
    /**
     * Stream id.
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly streamId: string

    /**
     * Container type.
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly container: string
}

/**
 * Request parameters for getLiveTvChannels operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvChannelsRequest
 */
export interface LiveTvApiGetLiveTvChannelsRequest {
    /**
     * Optional. Filter by channel type.
     * @type {ChannelType}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly type?: ChannelType

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly startIndex?: number

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSports?: boolean

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly limit?: number

    /**
     * Optional. Filter by channels that are favorites, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isFavorite?: boolean

    /**
     * Optional. Filter by channels that are liked, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isLiked?: boolean

    /**
     * Optional. Filter by channels that are disliked, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isDisliked?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly imageTypeLimit?: number

    /**
     * \&quot;Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Key to sort by.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortBy?: string

    /**
     * Optional. Sort order.
     * @type {SortOrder}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortOrder?: SortOrder

    /**
     * Optional. Incorporate favorite and like status into channel sorting.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableFavoriteSorting?: boolean

    /**
     * Optional. Adds current program info to each channel.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly addCurrentProgram?: boolean
}

/**
 * Request parameters for getLiveTvPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvProgramsRequest
 */
export interface LiveTvApiGetLiveTvProgramsRequest {
    /**
     * The channels to return guide information for.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly channelIds?: string

    /**
     * Optional. Filter by user id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly userId?: string

    /**
     * Optional. The minimum premiere start date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minStartDate?: string

    /**
     * Optional. Filter by programs that have completed airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly hasAired?: boolean

    /**
     * Optional. Filter by programs that are currently airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isAiring?: boolean

    /**
     * Optional. The maximum premiere start date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxStartDate?: string

    /**
     * Optional. The minimum premiere end date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minEndDate?: string

    /**
     * Optional. The maximum premiere end date.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxEndDate?: string

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSports?: boolean

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly limit?: number

    /**
     * Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortBy?: string

    /**
     * Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortOrder?: string

    /**
     * The genres to return guide information for.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genres?: string

    /**
     * The genre ids to return guide information for.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genreIds?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Filter by series timer id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Filter by library series id.
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly librarySeriesId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly fields?: Array<ItemFields>

    /**
     * Retrieve total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getProgram operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramRequest
 */
export interface LiveTvApiGetProgramRequest {
    /**
     * Program id.
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly programId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly userId?: string
}

/**
 * Request parameters for getPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramsRequest
 */
export interface LiveTvApiGetProgramsRequest {
    /**
     * Request body.
     * @type {GetProgramsDto}
     * @memberof LiveTvApiGetPrograms
     */
    readonly getProgramsDto?: GetProgramsDto
}

/**
 * Request parameters for getRecommendedPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecommendedProgramsRequest
 */
export interface LiveTvApiGetRecommendedProgramsRequest {
    /**
     * Optional. filter by user id.
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly userId?: string

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly limit?: number

    /**
     * Optional. Filter by programs that are currently airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isAiring?: boolean

    /**
     * Optional. Filter by programs that have completed airing, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly hasAired?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSports?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * The genres to return guide information for.
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly genreIds?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableUserData?: boolean

    /**
     * Retrieve total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingRequest
 */
export interface LiveTvApiGetRecordingRequest {
    /**
     * Recording id.
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly recordingId: string

    /**
     * Optional. Attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingFolders operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingFoldersRequest
 */
export interface LiveTvApiGetRecordingFoldersRequest {
    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingFolders
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingGroup operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupRequest
 */
export interface LiveTvApiGetRecordingGroupRequest {
    /**
     * Group id.
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for getRecordingGroups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupsRequest
 */
export interface LiveTvApiGetRecordingGroupsRequest {
    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroups
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordings operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsRequest
 */
export interface LiveTvApiGetRecordingsRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly channelId?: string

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly limit?: number

    /**
     * Optional. Filter by recording status.
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordings
     */
    readonly status?: RecordingStatus

    /**
     * Optional. Filter by recordings that are in progress, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isInProgress?: boolean

    /**
     * Optional. Filter by recordings belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecordings
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Filter for movies.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isMovie?: boolean

    /**
     * Optional. Filter for series.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSeries?: boolean

    /**
     * Optional. Filter for kids.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isKids?: boolean

    /**
     * Optional. Filter for sports.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSports?: boolean

    /**
     * Optional. Filter for news.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isNews?: boolean

    /**
     * Optional. Filter for is library item.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isLibraryItem?: boolean

    /**
     * Optional. Return total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecordingsSeries operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsSeriesRequest
 */
export interface LiveTvApiGetRecordingsSeriesRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly channelId?: string

    /**
     * Optional. Filter by user and attach user data.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly userId?: string

    /**
     * Optional. Filter by recording group.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly groupId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly limit?: number

    /**
     * Optional. Filter by recording status.
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly status?: RecordingStatus

    /**
     * Optional. Filter by recordings that are in progress, or not.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly isInProgress?: boolean

    /**
     * Optional. Filter by recordings belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Return total record count.
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimerRequest
 */
export interface LiveTvApiGetSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getSeriesTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimersRequest
 */
export interface LiveTvApiGetSeriesTimersRequest {
    /**
     * Optional. Sort by SortName or Priority.
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortBy?: string

    /**
     * Optional. Sort in Ascending or Descending order.
     * @type {SortOrder}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortOrder?: SortOrder
}

/**
 * Request parameters for getTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimerRequest
 */
export interface LiveTvApiGetTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiGetTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimersRequest
 */
export interface LiveTvApiGetTimersRequest {
    /**
     * Optional. Filter by channel id.
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly channelId?: string

    /**
     * Optional. Filter by timers belonging to a series timer.
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly seriesTimerId?: string

    /**
     * Optional. Filter by timers that are active.
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isActive?: boolean

    /**
     * Optional. Filter by timers that are scheduled.
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isScheduled?: boolean
}

/**
 * Request parameters for resetTuner operation in LiveTvApi.
 * @export
 * @interface LiveTvApiResetTunerRequest
 */
export interface LiveTvApiResetTunerRequest {
    /**
     * Tuner id.
     * @type {string}
     * @memberof LiveTvApiResetTuner
     */
    readonly tunerId: string
}

/**
 * Request parameters for setChannelMapping operation in LiveTvApi.
 * @export
 * @interface LiveTvApiSetChannelMappingRequest
 */
export interface LiveTvApiSetChannelMappingRequest {
    /**
     * Provider id.
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly providerId?: string

    /**
     * Tuner channel id.
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly tunerChannelId?: string

    /**
     * Provider channel id.
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly providerChannelId?: string
}

/**
 * Request parameters for updateSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateSeriesTimerRequest
 */
export interface LiveTvApiUpdateSeriesTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly timerId: string

    /**
     * New series timer info.
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for updateTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateTimerRequest
 */
export interface LiveTvApiUpdateTimerRequest {
    /**
     * Timer id.
     * @type {string}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerId: string

    /**
     * New timer info.
     * @type {TimerInfoDto}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * LiveTvApi - object-oriented interface
 * @export
 * @class LiveTvApi
 * @extends {BaseAPI}
 */
export class LiveTvApi extends BaseAPI {
    /**
     * 
     * @summary Adds a listings provider.
     * @param {LiveTvApiAddListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addListingProvider(requestParameters: LiveTvApiAddListingProviderRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).addListingProvider(requestParameters.pw, requestParameters.validateListings, requestParameters.validateLogin, requestParameters.listingsProviderInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a tuner host.
     * @param {LiveTvApiAddTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addTunerHost(requestParameters: LiveTvApiAddTunerHostRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).addTunerHost(requestParameters.tunerHostInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv series timer.
     * @param {LiveTvApiCancelSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelSeriesTimer(requestParameters: LiveTvApiCancelSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).cancelSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a live tv timer.
     * @param {LiveTvApiCancelTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelTimer(requestParameters: LiveTvApiCancelTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).cancelTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv series timer.
     * @param {LiveTvApiCreateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createSeriesTimer(requestParameters: LiveTvApiCreateSeriesTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).createSeriesTimer(requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a live tv timer.
     * @param {LiveTvApiCreateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createTimer(requestParameters: LiveTvApiCreateTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).createTimer(requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete listing provider.
     * @param {LiveTvApiDeleteListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteListingProvider(requestParameters: LiveTvApiDeleteListingProviderRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).deleteListingProvider(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a live tv recording.
     * @param {LiveTvApiDeleteRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteRecording(requestParameters: LiveTvApiDeleteRecordingRequest, options?: any) {
        return LiveTvApiFp(this.configuration).deleteRecording(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a tuner host.
     * @param {LiveTvApiDeleteTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteTunerHost(requestParameters: LiveTvApiDeleteTunerHostRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).deleteTunerHost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Discover tuners.
     * @param {LiveTvApiDiscoverTunersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discoverTuners(requestParameters: LiveTvApiDiscoverTunersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).discoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel.
     * @param {LiveTvApiGetChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannel(requestParameters: LiveTvApiGetChannelRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getChannel(requestParameters.channelId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get channel mapping options.
     * @param {LiveTvApiGetChannelMappingOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannelMappingOptions(requestParameters: LiveTvApiGetChannelMappingOptionsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getChannelMappingOptions(requestParameters.providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets default listings provider info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultListingProvider(options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultListingProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the default values for a new timer.
     * @param {LiveTvApiGetDefaultTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultTimer(requestParameters: LiveTvApiGetDefaultTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultTimer(requestParameters.programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get guid info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getGuideInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getGuideInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available lineups.
     * @param {LiveTvApiGetLineupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLineups(requestParameters: LiveTvApiGetLineupsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLineups(requestParameters.id, requestParameters.type, requestParameters.location, requestParameters.country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording stream.
     * @param {LiveTvApiGetLiveRecordingFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveRecordingFile(requestParameters: LiveTvApiGetLiveRecordingFileRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveRecordingFile(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv channel stream.
     * @param {LiveTvApiGetLiveStreamFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveStreamFile(requestParameters: LiveTvApiGetLiveStreamFileRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveStreamFile(requestParameters.streamId, requestParameters.container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv channels.
     * @param {LiveTvApiGetLiveTvChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvChannels(requestParameters: LiveTvApiGetLiveTvChannelsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvChannels(requestParameters.type, requestParameters.userId, requestParameters.startIndex, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.limit, requestParameters.isFavorite, requestParameters.isLiked, requestParameters.isDisliked, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.enableFavoriteSorting, requestParameters.addCurrentProgram, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {LiveTvApiGetLiveTvProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvPrograms(requestParameters: LiveTvApiGetLiveTvProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvPrograms(requestParameters.channelIds, requestParameters.userId, requestParameters.minStartDate, requestParameters.hasAired, requestParameters.isAiring, requestParameters.maxStartDate, requestParameters.minEndDate, requestParameters.maxEndDate, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.startIndex, requestParameters.limit, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.genres, requestParameters.genreIds, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.seriesTimerId, requestParameters.librarySeriesId, requestParameters.fields, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv program.
     * @param {LiveTvApiGetProgramRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getProgram(requestParameters: LiveTvApiGetProgramRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getProgram(requestParameters.programId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available live tv epgs.
     * @param {LiveTvApiGetProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getPrograms(requestParameters: LiveTvApiGetProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getPrograms(requestParameters.getProgramsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recommended live tv epgs.
     * @param {LiveTvApiGetRecommendedProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecommendedPrograms(requestParameters: LiveTvApiGetRecommendedProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecommendedPrograms(requestParameters.userId, requestParameters.limit, requestParameters.isAiring, requestParameters.hasAired, requestParameters.isSeries, requestParameters.isMovie, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.genreIds, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv recording.
     * @param {LiveTvApiGetRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecording(requestParameters: LiveTvApiGetRecordingRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getRecording(requestParameters.recordingId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets recording folders.
     * @param {LiveTvApiGetRecordingFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingFolders(requestParameters: LiveTvApiGetRecordingFoldersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingFolders(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recording group.
     * @param {LiveTvApiGetRecordingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroup(requestParameters: LiveTvApiGetRecordingGroupRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording groups.
     * @param {LiveTvApiGetRecordingGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroups(requestParameters: LiveTvApiGetRecordingGroupsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroups(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recordings.
     * @param {LiveTvApiGetRecordingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordings(requestParameters: LiveTvApiGetRecordingsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordings(requestParameters.channelId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isKids, requestParameters.isSports, requestParameters.isNews, requestParameters.isLibraryItem, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv recording series.
     * @param {LiveTvApiGetRecordingsSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingsSeries(requestParameters: LiveTvApiGetRecordingsSeriesRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingsSeries(requestParameters.channelId, requestParameters.userId, requestParameters.groupId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSchedulesDirectCountries(options?: any) {
        return LiveTvApiFp(this.configuration).getSchedulesDirectCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a live tv series timer.
     * @param {LiveTvApiGetSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimer(requestParameters: LiveTvApiGetSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live tv series timers.
     * @param {LiveTvApiGetSeriesTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimers(requestParameters: LiveTvApiGetSeriesTimersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimers(requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a timer.
     * @param {LiveTvApiGetTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimer(requestParameters: LiveTvApiGetTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the live tv timers.
     * @param {LiveTvApiGetTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimers(requestParameters: LiveTvApiGetTimersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getTimers(requestParameters.channelId, requestParameters.seriesTimerId, requestParameters.isActive, requestParameters.isScheduled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tuner host types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTunerHostTypes(options?: any) {
        return LiveTvApiFp(this.configuration).getTunerHostTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resets a tv tuner.
     * @param {LiveTvApiResetTunerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public resetTuner(requestParameters: LiveTvApiResetTunerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).resetTuner(requestParameters.tunerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set channel mappings.
     * @param {LiveTvApiSetChannelMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public setChannelMapping(requestParameters: LiveTvApiSetChannelMappingRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).setChannelMapping(requestParameters.providerId, requestParameters.tunerChannelId, requestParameters.providerChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv series timer.
     * @param {LiveTvApiUpdateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateSeriesTimer(requestParameters: LiveTvApiUpdateSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).updateSeriesTimer(requestParameters.timerId, requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a live tv timer.
     * @param {LiveTvApiUpdateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateTimer(requestParameters: LiveTvApiUpdateTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).updateTimer(requestParameters.timerId, requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LocalizationApi - axios parameter creator
 * @export
 */
export const LocalizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Cultures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/ParentalRatings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalizationApi - functional programming interface
 * @export
 */
export const LocalizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCultures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CultureDto>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCultures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalizationOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocalizationOption>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getLocalizationOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentalRatings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParentalRating>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getParentalRatings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LocalizationApi - factory interface
 * @export
 */
export const LocalizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets known countries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(options?: any): AxiosPromise<Array<CountryInfo>> {
            return LocalizationApiFp(configuration).getCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets known cultures.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures(options?: any): AxiosPromise<Array<CultureDto>> {
            return LocalizationApiFp(configuration).getCultures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets localization options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions(options?: any): AxiosPromise<Array<LocalizationOption>> {
            return LocalizationApiFp(configuration).getLocalizationOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets known parental ratings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings(options?: any): AxiosPromise<Array<ParentalRating>> {
            return LocalizationApiFp(configuration).getParentalRatings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalizationApi - object-oriented interface
 * @export
 * @class LocalizationApi
 * @extends {BaseAPI}
 */
export class LocalizationApi extends BaseAPI {
    /**
     * 
     * @summary Gets known countries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCountries(options?: any) {
        return LocalizationApiFp(this.configuration).getCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets known cultures.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCultures(options?: any) {
        return LocalizationApiFp(this.configuration).getCultures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets localization options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getLocalizationOptions(options?: any) {
        return LocalizationApiFp(this.configuration).getLocalizationOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets known parental ratings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getParentalRatings(options?: any) {
        return LocalizationApiFp(this.configuration).getParentalRatings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaInfoApi - axios parameter creator
 * @export
 */
export const MediaInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream: async (liveStreamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveStreamId' is not null or undefined
            if (liveStreamId === null || liveStreamId === undefined) {
                throw new RequiredError('liveStreamId','Required parameter liveStreamId was null or undefined when calling closeLiveStream.');
            }
            const localVarPath = `/LiveStreams/Close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes: async (size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Playback/BitrateTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo: async (itemId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPlaybackInfo.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo: async (itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPostedPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (autoOpenLiveStream !== undefined) {
                localVarQueryParameter['autoOpenLiveStream'] = autoOpenLiveStream;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }

            if (enableTranscoding !== undefined) {
                localVarQueryParameter['enableTranscoding'] = enableTranscoding;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfileDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfileDto !== undefined ? deviceProfileDto : {}) : (deviceProfileDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream: async (openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveStreams/Open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (openToken !== undefined) {
                localVarQueryParameter['openToken'] = openToken;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof openLiveStreamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(openLiveStreamDto !== undefined ? openLiveStreamDto : {}) : (openLiveStreamDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaInfoApi - functional programming interface
 * @export
 */
export const MediaInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeLiveStream(liveStreamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).closeLiveStream(liveStreamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBitrateTestBytes(size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getBitrateTestBytes(size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybackInfo(itemId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPlaybackInfo(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveStreamResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MediaInfoApi - factory interface
 * @export
 */
export const MediaInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Closes a media source.
         * @param {string} liveStreamId The livestream id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream(liveStreamId: string, options?: any): AxiosPromise<void> {
            return MediaInfoApiFp(configuration).closeLiveStream(liveStreamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tests the network with a request with the size of the bitrate.
         * @param {number} [size] The bitrate. Defaults to 102400.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes(size?: number, options?: any): AxiosPromise<any> {
            return MediaInfoApiFp(configuration).getBitrateTestBytes(size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo(itemId: string, userId: string, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPlaybackInfo(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets live playback media info for an item.
         * @param {string} itemId The item id.
         * @param {string} [userId] The user id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [mediaSourceId] The media source id.
         * @param {string} [liveStreamId] The livestream id.
         * @param {boolean} [autoOpenLiveStream] Whether to auto open the livestream.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {boolean} [enableTranscoding] Whether to enable transcoding. Default: true.
         * @param {boolean} [allowVideoStreamCopy] Whether to allow to copy the video stream. Default: true.
         * @param {boolean} [allowAudioStreamCopy] Whether to allow to copy the audio stream. Default: true.
         * @param {DeviceProfileDto} [deviceProfileDto] The device profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Opens a media source.
         * @param {string} [openToken] The open token.
         * @param {string} [userId] The user id.
         * @param {string} [playSessionId] The play session id.
         * @param {number} [maxStreamingBitrate] The maximum streaming bitrate.
         * @param {number} [startTimeTicks] The start time in ticks.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [maxAudioChannels] The maximum number of audio channels.
         * @param {string} [itemId] The item id.
         * @param {boolean} [enableDirectPlay] Whether to enable direct play. Default: true.
         * @param {boolean} [enableDirectStream] Whether to enable direct stream. Default: true.
         * @param {OpenLiveStreamDto} [openLiveStreamDto] The open live stream dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): AxiosPromise<LiveStreamResponse> {
            return MediaInfoApiFp(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for closeLiveStream operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiCloseLiveStreamRequest
 */
export interface MediaInfoApiCloseLiveStreamRequest {
    /**
     * The livestream id.
     * @type {string}
     * @memberof MediaInfoApiCloseLiveStream
     */
    readonly liveStreamId: string
}

/**
 * Request parameters for getBitrateTestBytes operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetBitrateTestBytesRequest
 */
export interface MediaInfoApiGetBitrateTestBytesRequest {
    /**
     * The bitrate. Defaults to 102400.
     * @type {number}
     * @memberof MediaInfoApiGetBitrateTestBytes
     */
    readonly size?: number
}

/**
 * Request parameters for getPlaybackInfo operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetPlaybackInfoRequest
 */
export interface MediaInfoApiGetPlaybackInfoRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof MediaInfoApiGetPlaybackInfo
     */
    readonly itemId: string

    /**
     * The user id.
     * @type {string}
     * @memberof MediaInfoApiGetPlaybackInfo
     */
    readonly userId: string
}

/**
 * Request parameters for getPostedPlaybackInfo operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetPostedPlaybackInfoRequest
 */
export interface MediaInfoApiGetPostedPlaybackInfoRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly itemId: string

    /**
     * The user id.
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly userId?: string

    /**
     * The maximum streaming bitrate.
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly maxStreamingBitrate?: number

    /**
     * The start time in ticks.
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly startTimeTicks?: number

    /**
     * The audio stream index.
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly audioStreamIndex?: number

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly subtitleStreamIndex?: number

    /**
     * The maximum number of audio channels.
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly maxAudioChannels?: number

    /**
     * The media source id.
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly mediaSourceId?: string

    /**
     * The livestream id.
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly liveStreamId?: string

    /**
     * Whether to auto open the livestream.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly autoOpenLiveStream?: boolean

    /**
     * Whether to enable direct play. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableDirectPlay?: boolean

    /**
     * Whether to enable direct stream. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableDirectStream?: boolean

    /**
     * Whether to enable transcoding. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableTranscoding?: boolean

    /**
     * Whether to allow to copy the video stream. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether to allow to copy the audio stream. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * The device profile.
     * @type {DeviceProfileDto}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly deviceProfileDto?: DeviceProfileDto
}

/**
 * Request parameters for openLiveStream operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiOpenLiveStreamRequest
 */
export interface MediaInfoApiOpenLiveStreamRequest {
    /**
     * The open token.
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly openToken?: string

    /**
     * The user id.
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly userId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly playSessionId?: string

    /**
     * The maximum streaming bitrate.
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * The start time in ticks.
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly startTimeTicks?: number

    /**
     * The audio stream index.
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly audioStreamIndex?: number

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * The maximum number of audio channels.
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly maxAudioChannels?: number

    /**
     * The item id.
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly itemId?: string

    /**
     * Whether to enable direct play. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly enableDirectPlay?: boolean

    /**
     * Whether to enable direct stream. Default: true.
     * @type {boolean}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly enableDirectStream?: boolean

    /**
     * The open live stream dto.
     * @type {OpenLiveStreamDto}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly openLiveStreamDto?: OpenLiveStreamDto
}

/**
 * MediaInfoApi - object-oriented interface
 * @export
 * @class MediaInfoApi
 * @extends {BaseAPI}
 */
export class MediaInfoApi extends BaseAPI {
    /**
     * 
     * @summary Closes a media source.
     * @param {MediaInfoApiCloseLiveStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public closeLiveStream(requestParameters: MediaInfoApiCloseLiveStreamRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).closeLiveStream(requestParameters.liveStreamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tests the network with a request with the size of the bitrate.
     * @param {MediaInfoApiGetBitrateTestBytesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getBitrateTestBytes(requestParameters: MediaInfoApiGetBitrateTestBytesRequest = {}, options?: any) {
        return MediaInfoApiFp(this.configuration).getBitrateTestBytes(requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live playback media info for an item.
     * @param {MediaInfoApiGetPlaybackInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPlaybackInfo(requestParameters: MediaInfoApiGetPlaybackInfoRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).getPlaybackInfo(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets live playback media info for an item.
     * @param {MediaInfoApiGetPostedPlaybackInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPostedPlaybackInfo(requestParameters: MediaInfoApiGetPostedPlaybackInfoRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).getPostedPlaybackInfo(requestParameters.itemId, requestParameters.userId, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.maxAudioChannels, requestParameters.mediaSourceId, requestParameters.liveStreamId, requestParameters.autoOpenLiveStream, requestParameters.enableDirectPlay, requestParameters.enableDirectStream, requestParameters.enableTranscoding, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.deviceProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Opens a media source.
     * @param {MediaInfoApiOpenLiveStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public openLiveStream(requestParameters: MediaInfoApiOpenLiveStreamRequest = {}, options?: any) {
        return MediaInfoApiFp(this.configuration).openLiveStream(requestParameters.openToken, requestParameters.userId, requestParameters.playSessionId, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.maxAudioChannels, requestParameters.itemId, requestParameters.enableDirectPlay, requestParameters.enableDirectStream, requestParameters.openLiveStreamDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MoviesApi - axios parameter creator
 * @export
 */
export const MoviesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations: async (userId?: string, parentId?: string, fields?: Array<ItemFields>, categoryLimit?: number, itemLimit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Movies/Recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (categoryLimit !== undefined) {
                localVarQueryParameter['categoryLimit'] = categoryLimit;
            }

            if (itemLimit !== undefined) {
                localVarQueryParameter['itemLimit'] = itemLimit;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoviesApi - functional programming interface
 * @export
 */
export const MoviesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRecommendations(userId?: string, parentId?: string, fields?: Array<ItemFields>, categoryLimit?: number, itemLimit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecommendationDto>>> {
            const localVarAxiosArgs = await MoviesApiAxiosParamCreator(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MoviesApi - factory interface
 * @export
 */
export const MoviesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets movie recommendations.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. The fields to return.
         * @param {number} [categoryLimit] The max number of categories to return.
         * @param {number} [itemLimit] The max number of items to return per category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations(userId?: string, parentId?: string, fields?: Array<ItemFields>, categoryLimit?: number, itemLimit?: number, options?: any): AxiosPromise<Array<RecommendationDto>> {
            return MoviesApiFp(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMovieRecommendations operation in MoviesApi.
 * @export
 * @interface MoviesApiGetMovieRecommendationsRequest
 */
export interface MoviesApiGetMovieRecommendationsRequest {
    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly userId?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly parentId?: string

    /**
     * Optional. The fields to return.
     * @type {Array<ItemFields>}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly fields?: Array<ItemFields>

    /**
     * The max number of categories to return.
     * @type {number}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly categoryLimit?: number

    /**
     * The max number of items to return per category.
     * @type {number}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly itemLimit?: number
}

/**
 * MoviesApi - object-oriented interface
 * @export
 * @class MoviesApi
 * @extends {BaseAPI}
 */
export class MoviesApi extends BaseAPI {
    /**
     * 
     * @summary Gets movie recommendations.
     * @param {MoviesApiGetMovieRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoviesApi
     */
    public getMovieRecommendations(requestParameters: MoviesApiGetMovieRecommendationsRequest = {}, options?: any) {
        return MoviesApiFp(this.configuration).getMovieRecommendations(requestParameters.userId, requestParameters.parentId, requestParameters.fields, requestParameters.categoryLimit, requestParameters.itemLimit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MusicGenresApi - axios parameter creator
 * @export
 */
export const MusicGenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres: async (startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/MusicGenres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicGenresApi - functional programming interface
 * @export
 */
export const MusicGenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenres(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenres(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MusicGenresApi - factory interface
 * @export
 */
export const MusicGenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a music genre, by name.
         * @param {string} genreName The genre name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return MusicGenresApiFp(configuration).getMusicGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all music genres from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Optional. Include total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return MusicGenresApiFp(configuration).getMusicGenres(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMusicGenre operation in MusicGenresApi.
 * @export
 * @interface MusicGenresApiGetMusicGenreRequest
 */
export interface MusicGenresApiGetMusicGenreRequest {
    /**
     * The genre name.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenre
     */
    readonly genreName: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenre
     */
    readonly userId?: string
}

/**
 * Request parameters for getMusicGenres operation in MusicGenresApi.
 * @export
 * @interface MusicGenresApiGetMusicGenresRequest
 */
export interface MusicGenresApiGetMusicGenresRequest {
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly limit?: number

    /**
     * The search term.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly includeItemTypes?: string

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly isFavorite?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * User id.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly userId?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameLessThan?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include total record count.
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * MusicGenresApi - object-oriented interface
 * @export
 * @class MusicGenresApi
 * @extends {BaseAPI}
 */
export class MusicGenresApi extends BaseAPI {
    /**
     * 
     * @summary Gets a music genre, by name.
     * @param {MusicGenresApiGetMusicGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenre(requestParameters: MusicGenresApiGetMusicGenreRequest, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenre(requestParameters.genreName, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all music genres from a given item, folder, or the entire library.
     * @param {MusicGenresApiGetMusicGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenres(requestParameters: MusicGenresApiGetMusicGenresRequest = {}, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenres(requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.isFavorite, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification: async (url?: string, level?: NotificationLevel, name?: string, description?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotifications.');
            }
            const localVarPath = `/Notifications/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotificationsSummary.');
            }
            const localVarPath = `/Notifications/{userId}/Summary`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setRead.');
            }
            const localVarPath = `/Notifications/{userId}/Read`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setUnread.');
            }
            const localVarPath = `/Notifications/{userId}/Unread`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).createAdminNotification(url, level, name, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationServices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationServices(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTypeInfo>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResultDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotifications(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsSummary(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsSummaryDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationsSummary(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRead(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setRead(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUnread(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setUnread(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Sends a notification to all admins.
         * @param {string} [url] The URL of the notification.
         * @param {NotificationLevel} [level] The level of the notification.
         * @param {string} [name] The name of the notification.
         * @param {string} [description] The description of the notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).createAdminNotification(url, level, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets notification services.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices(options?: any): AxiosPromise<Array<NameIdPair>> {
            return NotificationsApiFp(configuration).getNotificationServices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets notification types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes(options?: any): AxiosPromise<Array<NotificationTypeInfo>> {
            return NotificationsApiFp(configuration).getNotificationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s notifications.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(userId: string, options?: any): AxiosPromise<NotificationResultDto> {
            return NotificationsApiFp(configuration).getNotifications(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user\'s notification summary.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary(userId: string, options?: any): AxiosPromise<NotificationsSummaryDto> {
            return NotificationsApiFp(configuration).getNotificationsSummary(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets notifications as read.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setRead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets notifications as unread.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setUnread(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdminNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiCreateAdminNotificationRequest
 */
export interface NotificationsApiCreateAdminNotificationRequest {
    /**
     * The URL of the notification.
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly url?: string

    /**
     * The level of the notification.
     * @type {NotificationLevel}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly level?: NotificationLevel

    /**
     * The name of the notification.
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly name?: string

    /**
     * The description of the notification.
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly description?: string
}

/**
 * Request parameters for getNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetNotificationsRequest
 */
export interface NotificationsApiGetNotificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiGetNotifications
     */
    readonly userId: string
}

/**
 * Request parameters for getNotificationsSummary operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetNotificationsSummaryRequest
 */
export interface NotificationsApiGetNotificationsSummaryRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiGetNotificationsSummary
     */
    readonly userId: string
}

/**
 * Request parameters for setRead operation in NotificationsApi.
 * @export
 * @interface NotificationsApiSetReadRequest
 */
export interface NotificationsApiSetReadRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiSetRead
     */
    readonly userId: string
}

/**
 * Request parameters for setUnread operation in NotificationsApi.
 * @export
 * @interface NotificationsApiSetUnreadRequest
 */
export interface NotificationsApiSetUnreadRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiSetUnread
     */
    readonly userId: string
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Sends a notification to all admins.
     * @param {NotificationsApiCreateAdminNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createAdminNotification(requestParameters: NotificationsApiCreateAdminNotificationRequest = {}, options?: any) {
        return NotificationsApiFp(this.configuration).createAdminNotification(requestParameters.url, requestParameters.level, requestParameters.name, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets notification services.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationServices(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets notification types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationTypes(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s notifications.
     * @param {NotificationsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(requestParameters: NotificationsApiGetNotificationsRequest, options?: any) {
        return NotificationsApiFp(this.configuration).getNotifications(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user\'s notification summary.
     * @param {NotificationsApiGetNotificationsSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationsSummary(requestParameters: NotificationsApiGetNotificationsSummaryRequest, options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationsSummary(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets notifications as read.
     * @param {NotificationsApiSetReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setRead(requestParameters: NotificationsApiSetReadRequest, options?: any) {
        return NotificationsApiFp(this.configuration).setRead(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets notifications as unread.
     * @param {NotificationsApiSetUnreadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setUnread(requestParameters: NotificationsApiSetUnreadRequest, options?: any) {
        return NotificationsApiFp(this.configuration).setUnread(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PackageApi - axios parameter creator
 * @export
 */
export const PackageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation: async (packageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling cancelPackageInstallation.');
            }
            const localVarPath = `/Packages/Installing/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo: async (name: string, assemblyGuid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageInfo.');
            }
            const localVarPath = `/Packages/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {string} [repositoryUrl] Optional. Specify the repository to install from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage: async (name: string, assemblyGuid?: string, version?: string, repositoryUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling installPackage.');
            }
            const localVarPath = `/Packages/Installed/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (repositoryUrl !== undefined) {
                localVarQueryParameter['repositoryUrl'] = repositoryUrl;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories: async (repositoryInfo?: Array<RepositoryInfo>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof repositoryInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(repositoryInfo !== undefined ? repositoryInfo : {}) : (repositoryInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPackageInstallation(packageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).cancelPackageInstallation(packageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackageInfo(name: string, assemblyGuid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageInfo>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackageInfo(name, assemblyGuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackageInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getRepositories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {string} [repositoryUrl] Optional. Specify the repository to install from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installPackage(name: string, assemblyGuid?: string, version?: string, repositoryUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).installPackage(name, assemblyGuid, version, repositoryUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).setRepositories(repositoryInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Cancels a package installation.
         * @param {string} packageId Installation Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation(packageId: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).cancelPackageInstallation(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a package by name or assembly GUID.
         * @param {string} name The name of the package.
         * @param {string} [assemblyGuid] The GUID of the associated assembly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo(name: string, assemblyGuid?: string, options?: any): AxiosPromise<PackageInfo> {
            return PackageApiFp(configuration).getPackageInfo(name, assemblyGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options?: any): AxiosPromise<Array<PackageInfo>> {
            return PackageApiFp(configuration).getPackages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories(options?: any): AxiosPromise<Array<RepositoryInfo>> {
            return PackageApiFp(configuration).getRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Installs a package.
         * @param {string} name Package name.
         * @param {string} [assemblyGuid] GUID of the associated assembly.
         * @param {string} [version] Optional version. Defaults to latest version.
         * @param {string} [repositoryUrl] Optional. Specify the repository to install from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage(name: string, assemblyGuid?: string, version?: string, repositoryUrl?: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).installPackage(name, assemblyGuid, version, repositoryUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the enabled and existing package repositories.
         * @param {Array<RepositoryInfo>} [repositoryInfo] The list of package repositories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).setRepositories(repositoryInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelPackageInstallation operation in PackageApi.
 * @export
 * @interface PackageApiCancelPackageInstallationRequest
 */
export interface PackageApiCancelPackageInstallationRequest {
    /**
     * Installation Id.
     * @type {string}
     * @memberof PackageApiCancelPackageInstallation
     */
    readonly packageId: string
}

/**
 * Request parameters for getPackageInfo operation in PackageApi.
 * @export
 * @interface PackageApiGetPackageInfoRequest
 */
export interface PackageApiGetPackageInfoRequest {
    /**
     * The name of the package.
     * @type {string}
     * @memberof PackageApiGetPackageInfo
     */
    readonly name: string

    /**
     * The GUID of the associated assembly.
     * @type {string}
     * @memberof PackageApiGetPackageInfo
     */
    readonly assemblyGuid?: string
}

/**
 * Request parameters for installPackage operation in PackageApi.
 * @export
 * @interface PackageApiInstallPackageRequest
 */
export interface PackageApiInstallPackageRequest {
    /**
     * Package name.
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly name: string

    /**
     * GUID of the associated assembly.
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly assemblyGuid?: string

    /**
     * Optional version. Defaults to latest version.
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly version?: string

    /**
     * Optional. Specify the repository to install from.
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly repositoryUrl?: string
}

/**
 * Request parameters for setRepositories operation in PackageApi.
 * @export
 * @interface PackageApiSetRepositoriesRequest
 */
export interface PackageApiSetRepositoriesRequest {
    /**
     * The list of package repositories.
     * @type {Array<RepositoryInfo>}
     * @memberof PackageApiSetRepositories
     */
    readonly repositoryInfo?: Array<RepositoryInfo>
}

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a package installation.
     * @param {PackageApiCancelPackageInstallationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public cancelPackageInstallation(requestParameters: PackageApiCancelPackageInstallationRequest, options?: any) {
        return PackageApiFp(this.configuration).cancelPackageInstallation(requestParameters.packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a package by name or assembly GUID.
     * @param {PackageApiGetPackageInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackageInfo(requestParameters: PackageApiGetPackageInfoRequest, options?: any) {
        return PackageApiFp(this.configuration).getPackageInfo(requestParameters.name, requestParameters.assemblyGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackages(options?: any) {
        return PackageApiFp(this.configuration).getPackages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all package repositories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRepositories(options?: any) {
        return PackageApiFp(this.configuration).getRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Installs a package.
     * @param {PackageApiInstallPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public installPackage(requestParameters: PackageApiInstallPackageRequest, options?: any) {
        return PackageApiFp(this.configuration).installPackage(requestParameters.name, requestParameters.assemblyGuid, requestParameters.version, requestParameters.repositoryUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the enabled and existing package repositories.
     * @param {PackageApiSetRepositoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public setRepositories(requestParameters: PackageApiSetRepositoriesRequest = {}, options?: any) {
        return PackageApiFp(this.configuration).setRepositories(requestParameters.repositoryInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPerson.');
            }
            const localVarPath = `/Persons/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all persons.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not. userId is required.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludePersonTypes] Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [personTypes] Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [appearsInItemId] Optional. If specified, person results will be filtered on items related to said persons.
         * @param {string} [userId] User id.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons: async (limit?: number, searchTerm?: string, fields?: Array<ItemFields>, filters?: Array<ItemFilter>, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludePersonTypes?: string, personTypes?: string, appearsInItemId?: string, userId?: string, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (excludePersonTypes !== undefined) {
                localVarQueryParameter['excludePersonTypes'] = excludePersonTypes;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (appearsInItemId !== undefined) {
                localVarQueryParameter['appearsInItemId'] = appearsInItemId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPerson(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all persons.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not. userId is required.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludePersonTypes] Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [personTypes] Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [appearsInItemId] Optional. If specified, person results will be filtered on items related to said persons.
         * @param {string} [userId] User id.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersons(limit?: number, searchTerm?: string, fields?: Array<ItemFields>, filters?: Array<ItemFilter>, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludePersonTypes?: string, personTypes?: string, appearsInItemId?: string, userId?: string, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPersons(limit, searchTerm, fields, filters, isFavorite, enableUserData, imageTypeLimit, enableImageTypes, excludePersonTypes, personTypes, appearsInItemId, userId, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get person by name.
         * @param {string} name Person name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return PersonsApiFp(configuration).getPerson(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all persons.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] The search term.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not. userId is required.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [excludePersonTypes] Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [personTypes] Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
         * @param {string} [appearsInItemId] Optional. If specified, person results will be filtered on items related to said persons.
         * @param {string} [userId] User id.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(limit?: number, searchTerm?: string, fields?: Array<ItemFields>, filters?: Array<ItemFilter>, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, excludePersonTypes?: string, personTypes?: string, appearsInItemId?: string, userId?: string, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PersonsApiFp(configuration).getPersons(limit, searchTerm, fields, filters, isFavorite, enableUserData, imageTypeLimit, enableImageTypes, excludePersonTypes, personTypes, appearsInItemId, userId, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonRequest
 */
export interface PersonsApiGetPersonRequest {
    /**
     * Person name.
     * @type {string}
     * @memberof PersonsApiGetPerson
     */
    readonly name: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof PersonsApiGetPerson
     */
    readonly userId?: string
}

/**
 * Request parameters for getPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsRequest
 */
export interface PersonsApiGetPersonsRequest {
    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly limit?: number

    /**
     * The search term.
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly searchTerm?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof PersonsApiGetPersons
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Specify additional filters to apply.
     * @type {Array<ItemFilter>}
     * @memberof PersonsApiGetPersons
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not. userId is required.
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly isFavorite?: boolean

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof PersonsApiGetPersons
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly excludePersonTypes?: string

    /**
     * Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, person results will be filtered on items related to said persons.
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly appearsInItemId?: string

    /**
     * User id.
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly userId?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly enableImages?: boolean
}

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * 
     * @summary Get person by name.
     * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(requestParameters: PersonsApiGetPersonRequest, options?: any) {
        return PersonsApiFp(this.configuration).getPerson(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all persons.
     * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, options?: any) {
        return PersonsApiFp(this.configuration).getPersons(requestParameters.limit, requestParameters.searchTerm, requestParameters.fields, requestParameters.filters, requestParameters.isFavorite, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.excludePersonTypes, requestParameters.personTypes, requestParameters.appearsInItemId, requestParameters.userId, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist: async (playlistId: string, ids?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling addToPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (createPlaylistDto: CreatePlaylistDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistDto' is not null or undefined
            if (createPlaylistDto === null || createPlaylistDto === undefined) {
                throw new RequiredError('createPlaylistDto','Required parameter createPlaylistDto was null or undefined when calling createPlaylist.');
            }
            const localVarPath = `/Playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPlaylistDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPlaylistDto !== undefined ? createPlaylistDto : {}) : (createPlaylistDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems: async (playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaylistItems.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem: async (playlistId: string, itemId: string, newIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'newIndex' is not null or undefined
            if (newIndex === null || newIndex === undefined) {
                throw new RequiredError('newIndex','Required parameter newIndex was null or undefined when calling moveItem.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"newIndex"}}`, encodeURIComponent(String(newIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist: async (playlistId: string, entryIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling removeFromPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (entryIds !== undefined) {
                localVarQueryParameter['entryIds'] = entryIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).addToPlaylist(playlistId, ids, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistCreationResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).createPlaylist(createPlaylistDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistItems(playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).moveItem(playlistId, itemId, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).removeFromPlaylist(playlistId, entryIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds items to a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [ids] Item id, comma delimited.
         * @param {string} [userId] The userId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).addToPlaylist(playlistId, ids, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new playlist.
         * @param {CreatePlaylistDto} createPlaylistDto The create playlist payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): AxiosPromise<PlaylistCreationResult> {
            return PlaylistsApiFp(configuration).createPlaylist(createPlaylistDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the original items of a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} userId User id.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems(playlistId: string, userId: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PlaylistsApiFp(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Moves a playlist item.
         * @param {string} playlistId The playlist id.
         * @param {string} itemId The item id.
         * @param {number} newIndex The new index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).moveItem(playlistId, itemId, newIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes items from a playlist.
         * @param {string} playlistId The playlist id.
         * @param {string} [entryIds] The item ids, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).removeFromPlaylist(playlistId, entryIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addToPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiAddToPlaylistRequest
 */
export interface PlaylistsApiAddToPlaylistRequest {
    /**
     * The playlist id.
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly playlistId: string

    /**
     * Item id, comma delimited.
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly ids?: string

    /**
     * The userId.
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly userId?: string
}

/**
 * Request parameters for createPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiCreatePlaylistRequest
 */
export interface PlaylistsApiCreatePlaylistRequest {
    /**
     * The create playlist payload.
     * @type {CreatePlaylistDto}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly createPlaylistDto: CreatePlaylistDto
}

/**
 * Request parameters for getPlaylistItems operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistItemsRequest
 */
export interface PlaylistsApiGetPlaylistItemsRequest {
    /**
     * The playlist id.
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly playlistId: string

    /**
     * User id.
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly userId: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableImages?: boolean

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableImageTypes?: Array<ImageType>
}

/**
 * Request parameters for moveItem operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiMoveItemRequest
 */
export interface PlaylistsApiMoveItemRequest {
    /**
     * The playlist id.
     * @type {string}
     * @memberof PlaylistsApiMoveItem
     */
    readonly playlistId: string

    /**
     * The item id.
     * @type {string}
     * @memberof PlaylistsApiMoveItem
     */
    readonly itemId: string

    /**
     * The new index.
     * @type {number}
     * @memberof PlaylistsApiMoveItem
     */
    readonly newIndex: number
}

/**
 * Request parameters for removeFromPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiRemoveFromPlaylistRequest
 */
export interface PlaylistsApiRemoveFromPlaylistRequest {
    /**
     * The playlist id.
     * @type {string}
     * @memberof PlaylistsApiRemoveFromPlaylist
     */
    readonly playlistId: string

    /**
     * The item ids, comma delimited.
     * @type {string}
     * @memberof PlaylistsApiRemoveFromPlaylist
     */
    readonly entryIds?: string
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @summary Adds items to a playlist.
     * @param {PlaylistsApiAddToPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public addToPlaylist(requestParameters: PlaylistsApiAddToPlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).addToPlaylist(requestParameters.playlistId, requestParameters.ids, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new playlist.
     * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(requestParameters: PlaylistsApiCreatePlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).createPlaylist(requestParameters.createPlaylistDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the original items of a playlist.
     * @param {PlaylistsApiGetPlaylistItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylistItems(requestParameters: PlaylistsApiGetPlaylistItemsRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).getPlaylistItems(requestParameters.playlistId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Moves a playlist item.
     * @param {PlaylistsApiMoveItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public moveItem(requestParameters: PlaylistsApiMoveItemRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).moveItem(requestParameters.playlistId, requestParameters.itemId, requestParameters.newIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes items from a playlist.
     * @param {PlaylistsApiRemoveFromPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public removeFromPlaylist(requestParameters: PlaylistsApiRemoveFromPlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).removeFromPlaylist(requestParameters.playlistId, requestParameters.entryIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaystateApi - axios parameter creator
 * @export
 */
export const PlaystateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem: async (userId: string, itemId: string, datePlayed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markPlayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markPlayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (datePlayed !== undefined) {
                localVarQueryParameter['datePlayed'] = (datePlayed as any instanceof Date) ?
                    (datePlayed as any).toISOString() :
                    datePlayed;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markUnplayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markUnplayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress: async (userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackProgress.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackProgress.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}/Progress`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (volumeLevel !== undefined) {
                localVarQueryParameter['volumeLevel'] = volumeLevel;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (repeatMode !== undefined) {
                localVarQueryParameter['repeatMode'] = repeatMode;
            }

            if (isPaused !== undefined) {
                localVarQueryParameter['isPaused'] = isPaused;
            }

            if (isMuted !== undefined) {
                localVarQueryParameter['isMuted'] = isMuted;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart: async (userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStart.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStart.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (canSeek !== undefined) {
                localVarQueryParameter['canSeek'] = canSeek;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped: async (userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStopped.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStopped.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (nextMediaType !== undefined) {
                localVarQueryParameter['nextMediaType'] = nextMediaType;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession: async (playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress: async (playbackProgressInfo?: PlaybackProgressInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackProgressInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackProgressInfo !== undefined ? playbackProgressInfo : {}) : (playbackProgressInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart: async (playbackStartInfo?: PlaybackStartInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStartInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStartInfo !== undefined ? playbackStartInfo : {}) : (playbackStartInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped: async (playbackStopInfo?: PlaybackStopInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Stopped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStopInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStopInfo !== undefined ? playbackStopInfo : {}) : (playbackStopInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaystateApi - functional programming interface
 * @export
 */
export const PlaystateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markPlayedItem(userId, itemId, datePlayed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUnplayedItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markUnplayedItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingPlaybackSession(playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).pingPlaybackSession(playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackProgress(playbackProgressInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStart(playbackStartInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStopped(playbackStopInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaystateApi - factory interface
 * @export
 */
export const PlaystateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Marks an item as played for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [datePlayed] Optional. The date the item was played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markPlayedItem(userId, itemId, datePlayed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks an item as unplayed for user.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markUnplayedItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports a user\'s playback progress.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [positionTicks] Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {number} [volumeLevel] Scale of 0-100.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {RepeatMode} [repeatMode] The repeat mode.
         * @param {boolean} [isPaused] Indicates if the player is paused.
         * @param {boolean} [isMuted] Indicates if the player is muted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a user has begun playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {number} [audioStreamIndex] The audio stream index.
         * @param {number} [subtitleStreamIndex] The subtitle stream index.
         * @param {PlayMethod} [playMethod] The play method.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {boolean} [canSeek] Indicates if the client can seek.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a user has stopped playing an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {string} [mediaSourceId] The id of the MediaSource.
         * @param {string} [nextMediaType] The next media type that will play.
         * @param {number} [positionTicks] Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
         * @param {string} [liveStreamId] The live stream id.
         * @param {string} [playSessionId] The play session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings a playback session.
         * @param {string} [playSessionId] Playback session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession(playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).pingPlaybackSession(playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback progress within a session.
         * @param {PlaybackProgressInfo} [playbackProgressInfo] The playback progress info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackProgress(playbackProgressInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback has started within a session.
         * @param {PlaybackStartInfo} [playbackStartInfo] The playback start info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStart(playbackStartInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports playback has stopped within a session.
         * @param {PlaybackStopInfo} [playbackStopInfo] The playback stop info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStopped(playbackStopInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for markPlayedItem operation in PlaystateApi.
 * @export
 * @interface PlaystateApiMarkPlayedItemRequest
 */
export interface PlaystateApiMarkPlayedItemRequest {
    /**
     * User id.
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly itemId: string

    /**
     * Optional. The date the item was played.
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly datePlayed?: string
}

/**
 * Request parameters for markUnplayedItem operation in PlaystateApi.
 * @export
 * @interface PlaystateApiMarkUnplayedItemRequest
 */
export interface PlaystateApiMarkUnplayedItemRequest {
    /**
     * User id.
     * @type {string}
     * @memberof PlaystateApiMarkUnplayedItem
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof PlaystateApiMarkUnplayedItem
     */
    readonly itemId: string
}

/**
 * Request parameters for onPlaybackProgress operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackProgressRequest
 */
export interface PlaystateApiOnPlaybackProgressRequest {
    /**
     * User id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly itemId: string

    /**
     * The id of the MediaSource.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly mediaSourceId?: string

    /**
     * Optional. The current position, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly positionTicks?: number

    /**
     * The audio stream index.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly audioStreamIndex?: number

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly subtitleStreamIndex?: number

    /**
     * Scale of 0-100.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly volumeLevel?: number

    /**
     * The play method.
     * @type {PlayMethod}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly playMethod?: PlayMethod

    /**
     * The live stream id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly liveStreamId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly playSessionId?: string

    /**
     * The repeat mode.
     * @type {RepeatMode}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly repeatMode?: RepeatMode

    /**
     * Indicates if the player is paused.
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly isPaused?: boolean

    /**
     * Indicates if the player is muted.
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly isMuted?: boolean
}

/**
 * Request parameters for onPlaybackStart operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackStartRequest
 */
export interface PlaystateApiOnPlaybackStartRequest {
    /**
     * User id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly itemId: string

    /**
     * The id of the MediaSource.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly mediaSourceId?: string

    /**
     * The audio stream index.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly audioStreamIndex?: number

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly subtitleStreamIndex?: number

    /**
     * The play method.
     * @type {PlayMethod}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly playMethod?: PlayMethod

    /**
     * The live stream id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly liveStreamId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly playSessionId?: string

    /**
     * Indicates if the client can seek.
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly canSeek?: boolean
}

/**
 * Request parameters for onPlaybackStopped operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackStoppedRequest
 */
export interface PlaystateApiOnPlaybackStoppedRequest {
    /**
     * User id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly itemId: string

    /**
     * The id of the MediaSource.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly mediaSourceId?: string

    /**
     * The next media type that will play.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly nextMediaType?: string

    /**
     * Optional. The position, in ticks, where playback stopped. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly positionTicks?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly liveStreamId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly playSessionId?: string
}

/**
 * Request parameters for pingPlaybackSession operation in PlaystateApi.
 * @export
 * @interface PlaystateApiPingPlaybackSessionRequest
 */
export interface PlaystateApiPingPlaybackSessionRequest {
    /**
     * Playback session id.
     * @type {string}
     * @memberof PlaystateApiPingPlaybackSession
     */
    readonly playSessionId?: string
}

/**
 * Request parameters for reportPlaybackProgress operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackProgressRequest
 */
export interface PlaystateApiReportPlaybackProgressRequest {
    /**
     * The playback progress info.
     * @type {PlaybackProgressInfo}
     * @memberof PlaystateApiReportPlaybackProgress
     */
    readonly playbackProgressInfo?: PlaybackProgressInfo
}

/**
 * Request parameters for reportPlaybackStart operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackStartRequest
 */
export interface PlaystateApiReportPlaybackStartRequest {
    /**
     * The playback start info.
     * @type {PlaybackStartInfo}
     * @memberof PlaystateApiReportPlaybackStart
     */
    readonly playbackStartInfo?: PlaybackStartInfo
}

/**
 * Request parameters for reportPlaybackStopped operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackStoppedRequest
 */
export interface PlaystateApiReportPlaybackStoppedRequest {
    /**
     * The playback stop info.
     * @type {PlaybackStopInfo}
     * @memberof PlaystateApiReportPlaybackStopped
     */
    readonly playbackStopInfo?: PlaybackStopInfo
}

/**
 * PlaystateApi - object-oriented interface
 * @export
 * @class PlaystateApi
 * @extends {BaseAPI}
 */
export class PlaystateApi extends BaseAPI {
    /**
     * 
     * @summary Marks an item as played for user.
     * @param {PlaystateApiMarkPlayedItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markPlayedItem(requestParameters: PlaystateApiMarkPlayedItemRequest, options?: any) {
        return PlaystateApiFp(this.configuration).markPlayedItem(requestParameters.userId, requestParameters.itemId, requestParameters.datePlayed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks an item as unplayed for user.
     * @param {PlaystateApiMarkUnplayedItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markUnplayedItem(requestParameters: PlaystateApiMarkUnplayedItemRequest, options?: any) {
        return PlaystateApiFp(this.configuration).markUnplayedItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports a user\'s playback progress.
     * @param {PlaystateApiOnPlaybackProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackProgress(requestParameters: PlaystateApiOnPlaybackProgressRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackProgress(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.positionTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.volumeLevel, requestParameters.playMethod, requestParameters.liveStreamId, requestParameters.playSessionId, requestParameters.repeatMode, requestParameters.isPaused, requestParameters.isMuted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a user has begun playing an item.
     * @param {PlaystateApiOnPlaybackStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStart(requestParameters: PlaystateApiOnPlaybackStartRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStart(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.playMethod, requestParameters.liveStreamId, requestParameters.playSessionId, requestParameters.canSeek, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a user has stopped playing an item.
     * @param {PlaystateApiOnPlaybackStoppedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStopped(requestParameters: PlaystateApiOnPlaybackStoppedRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStopped(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.nextMediaType, requestParameters.positionTicks, requestParameters.liveStreamId, requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings a playback session.
     * @param {PlaystateApiPingPlaybackSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public pingPlaybackSession(requestParameters: PlaystateApiPingPlaybackSessionRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).pingPlaybackSession(requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback progress within a session.
     * @param {PlaystateApiReportPlaybackProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackProgress(requestParameters: PlaystateApiReportPlaybackProgressRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackProgress(requestParameters.playbackProgressInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback has started within a session.
     * @param {PlaystateApiReportPlaybackStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStart(requestParameters: PlaystateApiReportPlaybackStartRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStart(requestParameters.playbackStartInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports playback has stopped within a session.
     * @param {PlaystateApiReportPlaybackStoppedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStopped(requestParameters: PlaystateApiReportPlaybackStoppedRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStopped(requestParameters.playbackStopInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling getPluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins/SecurityInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistration.');
            }
            const localVarPath = `/Plugins/Registrations/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistrationStatus.');
            }
            const localVarPath = `/Plugins/RegistrationRecords/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling uninstallPlugin.');
            }
            const localVarPath = `/Plugins/{pluginId}`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling updatePluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo: async (pluginSecurityInfo: PluginSecurityInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginSecurityInfo' is not null or undefined
            if (pluginSecurityInfo === null || pluginSecurityInfo === undefined) {
                throw new RequiredError('pluginSecurityInfo','Required parameter pluginSecurityInfo was null or undefined when calling updatePluginSecurityInfo.');
            }
            const localVarPath = `/Plugins/SecurityInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pluginSecurityInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pluginSecurityInfo !== undefined ? pluginSecurityInfo : {}) : (pluginSecurityInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginSecurityInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginSecurityInfo>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginSecurityInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlugins(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPlugins(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistration(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistration(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationStatus(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MBRegistrationRecord>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistrationStatus(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallPlugin(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).uninstallPlugin(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginId: string, options?: any): AxiosPromise<object> {
            return PluginsApiFp(configuration).getPluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo(options?: any): AxiosPromise<PluginSecurityInfo> {
            return PluginsApiFp(configuration).getPluginSecurityInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of currently installed plugins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(options?: any): AxiosPromise<Array<PluginInfo>> {
            return PluginsApiFp(configuration).getPlugins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration(name: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).getRegistration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets registration status for a feature.
         * @param {string} name Feature name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus(name: string, options?: any): AxiosPromise<MBRegistrationRecord> {
            return PluginsApiFp(configuration).getRegistrationStatus(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstalls a plugin.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).uninstallPlugin(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts plugin configuration as JSON body.
         * @summary Updates plugin configuration.
         * @param {string} pluginId Plugin id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates plugin security info.
         * @param {PluginSecurityInfo} pluginSecurityInfo Plugin security info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPluginConfiguration operation in PluginsApi.
 * @export
 * @interface PluginsApiGetPluginConfigurationRequest
 */
export interface PluginsApiGetPluginConfigurationRequest {
    /**
     * Plugin id.
     * @type {string}
     * @memberof PluginsApiGetPluginConfiguration
     */
    readonly pluginId: string
}

/**
 * Request parameters for getRegistration operation in PluginsApi.
 * @export
 * @interface PluginsApiGetRegistrationRequest
 */
export interface PluginsApiGetRegistrationRequest {
    /**
     * Feature name.
     * @type {string}
     * @memberof PluginsApiGetRegistration
     */
    readonly name: string
}

/**
 * Request parameters for getRegistrationStatus operation in PluginsApi.
 * @export
 * @interface PluginsApiGetRegistrationStatusRequest
 */
export interface PluginsApiGetRegistrationStatusRequest {
    /**
     * Feature name.
     * @type {string}
     * @memberof PluginsApiGetRegistrationStatus
     */
    readonly name: string
}

/**
 * Request parameters for uninstallPlugin operation in PluginsApi.
 * @export
 * @interface PluginsApiUninstallPluginRequest
 */
export interface PluginsApiUninstallPluginRequest {
    /**
     * Plugin id.
     * @type {string}
     * @memberof PluginsApiUninstallPlugin
     */
    readonly pluginId: string
}

/**
 * Request parameters for updatePluginConfiguration operation in PluginsApi.
 * @export
 * @interface PluginsApiUpdatePluginConfigurationRequest
 */
export interface PluginsApiUpdatePluginConfigurationRequest {
    /**
     * Plugin id.
     * @type {string}
     * @memberof PluginsApiUpdatePluginConfiguration
     */
    readonly pluginId: string
}

/**
 * Request parameters for updatePluginSecurityInfo operation in PluginsApi.
 * @export
 * @interface PluginsApiUpdatePluginSecurityInfoRequest
 */
export interface PluginsApiUpdatePluginSecurityInfoRequest {
    /**
     * Plugin security info.
     * @type {PluginSecurityInfo}
     * @memberof PluginsApiUpdatePluginSecurityInfo
     */
    readonly pluginSecurityInfo: PluginSecurityInfo
}

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     * 
     * @summary Gets plugin configuration.
     * @param {PluginsApiGetPluginConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginConfiguration(requestParameters: PluginsApiGetPluginConfigurationRequest, options?: any) {
        return PluginsApiFp(this.configuration).getPluginConfiguration(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get plugin security info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginSecurityInfo(options?: any) {
        return PluginsApiFp(this.configuration).getPluginSecurityInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of currently installed plugins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPlugins(options?: any) {
        return PluginsApiFp(this.configuration).getPlugins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets registration status for a feature.
     * @param {PluginsApiGetRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistration(requestParameters: PluginsApiGetRegistrationRequest, options?: any) {
        return PluginsApiFp(this.configuration).getRegistration(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets registration status for a feature.
     * @param {PluginsApiGetRegistrationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistrationStatus(requestParameters: PluginsApiGetRegistrationStatusRequest, options?: any) {
        return PluginsApiFp(this.configuration).getRegistrationStatus(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstalls a plugin.
     * @param {PluginsApiUninstallPluginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public uninstallPlugin(requestParameters: PluginsApiUninstallPluginRequest, options?: any) {
        return PluginsApiFp(this.configuration).uninstallPlugin(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts plugin configuration as JSON body.
     * @summary Updates plugin configuration.
     * @param {PluginsApiUpdatePluginConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginConfiguration(requestParameters: PluginsApiUpdatePluginConfigurationRequest, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginConfiguration(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates plugin security info.
     * @param {PluginsApiUpdatePluginSecurityInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginSecurityInfo(requestParameters: PluginsApiUpdatePluginSecurityInfoRequest, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginSecurityInfo(requestParameters.pluginSecurityInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuickConnectApi - axios parameter creator
 * @export
 */
export const QuickConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling authorize.');
            }
            const localVarPath = `/QuickConnect/Authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available: async (status?: QuickConnectState, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect: async (secret: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling connect.');
            }
            const localVarPath = `/QuickConnect/Connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Deauthorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuickConnectApi - functional programming interface
 * @export
 */
export const QuickConnectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).activate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).authorize(code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async available(status?: QuickConnectState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).available(status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect(secret: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).connect(secret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deauthorize(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).deauthorize(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectState>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).initiate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QuickConnectApi - factory interface
 * @export
 */
export const QuickConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Temporarily activates quick connect for five minutes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).activate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authorizes a pending quick connect request.
         * @param {string} code Quick connect code to authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(code: string, options?: any): AxiosPromise<boolean> {
            return QuickConnectApiFp(configuration).authorize(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enables or disables quick connect.
         * @param {QuickConnectState} [status] New MediaBrowser.Model.QuickConnect.QuickConnectState.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available(status?: QuickConnectState, options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).available(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attempts to retrieve authentication information.
         * @param {string} secret Secret previously returned from the Initiate endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect(secret: string, options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).connect(secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deauthorize all quick connect devices for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize(options?: any): AxiosPromise<number> {
            return QuickConnectApiFp(configuration).deauthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the current quick connect state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<QuickConnectState> {
            return QuickConnectApiFp(configuration).getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate a new quick connect request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate(options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).initiate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorize operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiAuthorizeRequest
 */
export interface QuickConnectApiAuthorizeRequest {
    /**
     * Quick connect code to authorize.
     * @type {string}
     * @memberof QuickConnectApiAuthorize
     */
    readonly code: string
}

/**
 * Request parameters for available operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiAvailableRequest
 */
export interface QuickConnectApiAvailableRequest {
    /**
     * New MediaBrowser.Model.QuickConnect.QuickConnectState.
     * @type {QuickConnectState}
     * @memberof QuickConnectApiAvailable
     */
    readonly status?: QuickConnectState
}

/**
 * Request parameters for connect operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiConnectRequest
 */
export interface QuickConnectApiConnectRequest {
    /**
     * Secret previously returned from the Initiate endpoint.
     * @type {string}
     * @memberof QuickConnectApiConnect
     */
    readonly secret: string
}

/**
 * QuickConnectApi - object-oriented interface
 * @export
 * @class QuickConnectApi
 * @extends {BaseAPI}
 */
export class QuickConnectApi extends BaseAPI {
    /**
     * 
     * @summary Temporarily activates quick connect for five minutes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public activate(options?: any) {
        return QuickConnectApiFp(this.configuration).activate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authorizes a pending quick connect request.
     * @param {QuickConnectApiAuthorizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public authorize(requestParameters: QuickConnectApiAuthorizeRequest, options?: any) {
        return QuickConnectApiFp(this.configuration).authorize(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enables or disables quick connect.
     * @param {QuickConnectApiAvailableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public available(requestParameters: QuickConnectApiAvailableRequest = {}, options?: any) {
        return QuickConnectApiFp(this.configuration).available(requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attempts to retrieve authentication information.
     * @param {QuickConnectApiConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public connect(requestParameters: QuickConnectApiConnectRequest, options?: any) {
        return QuickConnectApiFp(this.configuration).connect(requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deauthorize all quick connect devices for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public deauthorize(options?: any) {
        return QuickConnectApiFp(this.configuration).deauthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the current quick connect state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public getStatus(options?: any) {
        return QuickConnectApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate a new quick connect request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public initiate(options?: any) {
        return QuickConnectApiFp(this.configuration).initiate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteImageApi - axios parameter creator
 * @export
 */
export const RemoteImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage: async (itemId: string, type: ImageType, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling downloadRemoteImage.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage: async (imageUrl: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteImage.');
            }
            const localVarPath = `/Images/Remote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImageProviders.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Providers`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages: async (itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImages.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }

            if (includeAllLanguages !== undefined) {
                localVarQueryParameter['includeAllLanguages'] = includeAllLanguages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteImageApi - functional programming interface
 * @export
 */
export const RemoteImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).downloadRemoteImage(itemId, type, imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImage(imageUrl: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImage(imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImageProviders(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageProviderInfo>>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImageProviders(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteImageResult>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemoteImageApi - factory interface
 * @export
 */
export const RemoteImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Downloads a remote image for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} type The image type.
         * @param {string} [imageUrl] The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): AxiosPromise<void> {
            return RemoteImageApiFp(configuration).downloadRemoteImage(itemId, type, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a remote image.
         * @param {string} imageUrl The image url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage(imageUrl: string, options?: any): AxiosPromise<any> {
            return RemoteImageApiFp(configuration).getRemoteImage(imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available remote image providers for an item.
         * @param {string} itemId Item Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders(itemId: string, options?: any): AxiosPromise<Array<ImageProviderInfo>> {
            return RemoteImageApiFp(configuration).getRemoteImageProviders(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets available remote images for an item.
         * @param {string} itemId Item Id.
         * @param {ImageType} [type] The image type.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [providerName] Optional. The image provider to use.
         * @param {boolean} [includeAllLanguages] Optional. Include all languages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): AxiosPromise<RemoteImageResult> {
            return RemoteImageApiFp(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadRemoteImage operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiDownloadRemoteImageRequest
 */
export interface RemoteImageApiDownloadRemoteImageRequest {
    /**
     * Item Id.
     * @type {string}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly itemId: string

    /**
     * The image type.
     * @type {ImageType}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly type: ImageType

    /**
     * The image url.
     * @type {string}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly imageUrl?: string
}

/**
 * Request parameters for getRemoteImage operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImageRequest
 */
export interface RemoteImageApiGetRemoteImageRequest {
    /**
     * The image url.
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImage
     */
    readonly imageUrl: string
}

/**
 * Request parameters for getRemoteImageProviders operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImageProvidersRequest
 */
export interface RemoteImageApiGetRemoteImageProvidersRequest {
    /**
     * Item Id.
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImageProviders
     */
    readonly itemId: string
}

/**
 * Request parameters for getRemoteImages operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImagesRequest
 */
export interface RemoteImageApiGetRemoteImagesRequest {
    /**
     * Item Id.
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly itemId: string

    /**
     * The image type.
     * @type {ImageType}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly type?: ImageType

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly limit?: number

    /**
     * Optional. The image provider to use.
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly providerName?: string

    /**
     * Optional. Include all languages.
     * @type {boolean}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly includeAllLanguages?: boolean
}

/**
 * RemoteImageApi - object-oriented interface
 * @export
 * @class RemoteImageApi
 * @extends {BaseAPI}
 */
export class RemoteImageApi extends BaseAPI {
    /**
     * 
     * @summary Downloads a remote image for an item.
     * @param {RemoteImageApiDownloadRemoteImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public downloadRemoteImage(requestParameters: RemoteImageApiDownloadRemoteImageRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).downloadRemoteImage(requestParameters.itemId, requestParameters.type, requestParameters.imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a remote image.
     * @param {RemoteImageApiGetRemoteImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImage(requestParameters: RemoteImageApiGetRemoteImageRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImage(requestParameters.imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available remote image providers for an item.
     * @param {RemoteImageApiGetRemoteImageProvidersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImageProviders(requestParameters: RemoteImageApiGetRemoteImageProvidersRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImageProviders(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets available remote images for an item.
     * @param {RemoteImageApiGetRemoteImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImages(requestParameters: RemoteImageApiGetRemoteImagesRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImages(requestParameters.itemId, requestParameters.type, requestParameters.startIndex, requestParameters.limit, requestParameters.providerName, requestParameters.includeAllLanguages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledTasksApi - axios parameter creator
 * @export
 */
export const ScheduledTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (isHidden?: boolean, isEnabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ScheduledTasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling startTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling stopTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling updateTask.');
            }
            // verify required parameter 'taskTriggerInfo' is not null or undefined
            if (taskTriggerInfo === null || taskTriggerInfo === undefined) {
                throw new RequiredError('taskTriggerInfo','Required parameter taskTriggerInfo was null or undefined when calling updateTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}/Triggers`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof taskTriggerInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskTriggerInfo !== undefined ? taskTriggerInfo : {}) : (taskTriggerInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTasksApi - functional programming interface
 * @export
 */
export const ScheduledTasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfo>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskInfo>>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTasks(isHidden, isEnabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).startTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).stopTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).updateTask(taskId, taskTriggerInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ScheduledTasksApi - factory interface
 * @export
 */
export const ScheduledTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get task by id.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): AxiosPromise<TaskInfo> {
            return ScheduledTasksApiFp(configuration).getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tasks.
         * @param {boolean} [isHidden] Optional filter tasks that are hidden, or not.
         * @param {boolean} [isEnabled] Optional filter tasks that are enabled, or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): AxiosPromise<Array<TaskInfo>> {
            return ScheduledTasksApiFp(configuration).getTasks(isHidden, isEnabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).startTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop specified task.
         * @param {string} taskId Task Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).stopTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update specified task triggers.
         * @param {string} taskId Task Id.
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo Triggers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).updateTask(taskId, taskTriggerInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiGetTaskRequest
 */
export interface ScheduledTasksApiGetTaskRequest {
    /**
     * Task Id.
     * @type {string}
     * @memberof ScheduledTasksApiGetTask
     */
    readonly taskId: string
}

/**
 * Request parameters for getTasks operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiGetTasksRequest
 */
export interface ScheduledTasksApiGetTasksRequest {
    /**
     * Optional filter tasks that are hidden, or not.
     * @type {boolean}
     * @memberof ScheduledTasksApiGetTasks
     */
    readonly isHidden?: boolean

    /**
     * Optional filter tasks that are enabled, or not.
     * @type {boolean}
     * @memberof ScheduledTasksApiGetTasks
     */
    readonly isEnabled?: boolean
}

/**
 * Request parameters for startTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiStartTaskRequest
 */
export interface ScheduledTasksApiStartTaskRequest {
    /**
     * Task Id.
     * @type {string}
     * @memberof ScheduledTasksApiStartTask
     */
    readonly taskId: string
}

/**
 * Request parameters for stopTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiStopTaskRequest
 */
export interface ScheduledTasksApiStopTaskRequest {
    /**
     * Task Id.
     * @type {string}
     * @memberof ScheduledTasksApiStopTask
     */
    readonly taskId: string
}

/**
 * Request parameters for updateTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiUpdateTaskRequest
 */
export interface ScheduledTasksApiUpdateTaskRequest {
    /**
     * Task Id.
     * @type {string}
     * @memberof ScheduledTasksApiUpdateTask
     */
    readonly taskId: string

    /**
     * Triggers.
     * @type {Array<TaskTriggerInfo>}
     * @memberof ScheduledTasksApiUpdateTask
     */
    readonly taskTriggerInfo: Array<TaskTriggerInfo>
}

/**
 * ScheduledTasksApi - object-oriented interface
 * @export
 * @class ScheduledTasksApi
 * @extends {BaseAPI}
 */
export class ScheduledTasksApi extends BaseAPI {
    /**
     * 
     * @summary Get task by id.
     * @param {ScheduledTasksApiGetTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTask(requestParameters: ScheduledTasksApiGetTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tasks.
     * @param {ScheduledTasksApiGetTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTasks(requestParameters: ScheduledTasksApiGetTasksRequest = {}, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTasks(requestParameters.isHidden, requestParameters.isEnabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start specified task.
     * @param {ScheduledTasksApiStartTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public startTask(requestParameters: ScheduledTasksApiStartTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).startTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop specified task.
     * @param {ScheduledTasksApiStopTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public stopTask(requestParameters: ScheduledTasksApiStopTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).stopTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update specified task triggers.
     * @param {ScheduledTasksApiUpdateTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public updateTask(requestParameters: ScheduledTasksApiUpdateTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).updateTask(requestParameters.taskId, requestParameters.taskTriggerInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTerm' is not null or undefined
            if (searchTerm === null || searchTerm === undefined) {
                throw new RequiredError('searchTerm','Required parameter searchTerm was null or undefined when calling get.');
            }
            const localVarPath = `/Search/Hints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (includePeople !== undefined) {
                localVarQueryParameter['includePeople'] = includePeople;
            }

            if (includeMedia !== undefined) {
                localVarQueryParameter['includeMedia'] = includeMedia;
            }

            if (includeGenres !== undefined) {
                localVarQueryParameter['includeGenres'] = includeGenres;
            }

            if (includeStudios !== undefined) {
                localVarQueryParameter['includeStudios'] = includeStudios;
            }

            if (includeArtists !== undefined) {
                localVarQueryParameter['includeArtists'] = includeArtists;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchHintResult>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the search hint result.
         * @param {string} searchTerm The search term to filter on.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [userId] Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
         * @param {string} [includeItemTypes] If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
         * @param {string} [excludeItemTypes] If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
         * @param {string} [mediaTypes] If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
         * @param {string} [parentId] If specified, only children of the parent are returned.
         * @param {boolean} [isMovie] Optional filter for movies.
         * @param {boolean} [isSeries] Optional filter for series.
         * @param {boolean} [isNews] Optional filter for news.
         * @param {boolean} [isKids] Optional filter for kids.
         * @param {boolean} [isSports] Optional filter for sports.
         * @param {boolean} [includePeople] Optional filter whether to include people.
         * @param {boolean} [includeMedia] Optional filter whether to include media.
         * @param {boolean} [includeGenres] Optional filter whether to include genres.
         * @param {boolean} [includeStudios] Optional filter whether to include studios.
         * @param {boolean} [includeArtists] Optional filter whether to include artists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): AxiosPromise<SearchHintResult> {
            return SearchApiFp(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for get operation in SearchApi.
 * @export
 * @interface SearchApiGetRequest
 */
export interface SearchApiGetRequest {
    /**
     * The search term to filter on.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly searchTerm: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof SearchApiGet
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof SearchApiGet
     */
    readonly limit?: number

    /**
     * Optional. Supply a user id to search within a user\&#39;s library or omit to search all.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly userId?: string

    /**
     * If specified, only results with the specified item types are returned. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly includeItemTypes?: string

    /**
     * If specified, results with these item types are filtered out. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly excludeItemTypes?: string

    /**
     * If specified, only results with the specified media types are returned. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly mediaTypes?: string

    /**
     * If specified, only children of the parent are returned.
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly parentId?: string

    /**
     * Optional filter for movies.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isMovie?: boolean

    /**
     * Optional filter for series.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isSeries?: boolean

    /**
     * Optional filter for news.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isNews?: boolean

    /**
     * Optional filter for kids.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isKids?: boolean

    /**
     * Optional filter for sports.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isSports?: boolean

    /**
     * Optional filter whether to include people.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includePeople?: boolean

    /**
     * Optional filter whether to include media.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeMedia?: boolean

    /**
     * Optional filter whether to include genres.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeGenres?: boolean

    /**
     * Optional filter whether to include studios.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeStudios?: boolean

    /**
     * Optional filter whether to include artists.
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeArtists?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Gets the search hint result.
     * @param {SearchApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public get(requestParameters: SearchApiGetRequest, options?: any) {
        return SearchApiFp(this.configuration).get(requestParameters.searchTerm, requestParameters.startIndex, requestParameters.limit, requestParameters.userId, requestParameters.includeItemTypes, requestParameters.excludeItemTypes, requestParameters.mediaTypes, requestParameters.parentId, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.includePeople, requestParameters.includeMedia, requestParameters.includeGenres, requestParameters.includeStudios, requestParameters.includeArtists, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling addUserToSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addUserToSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent: async (sessionId: string, itemType: string, itemId: string, itemName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemName' is not null or undefined
            if (itemName === null || itemName === undefined) {
                throw new RequiredError('itemName','Required parameter itemName was null or undefined when calling displayContent.');
            }
            const localVarPath = `/Sessions/{sessionId}/Viewing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/PasswordResetProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (controllableByUserId !== undefined) {
                localVarQueryParameter['controllableByUserId'] = controllableByUserId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (activeWithinSeconds !== undefined) {
                localVarQueryParameter['activeWithinSeconds'] = activeWithinSeconds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play: async (sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling play.');
            }
            // verify required parameter 'playCommand' is not null or undefined
            if (playCommand === null || playCommand === undefined) {
                throw new RequiredError('playCommand','Required parameter playCommand was null or undefined when calling play.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling play.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (playCommand !== undefined) {
                localVarQueryParameter['playCommand'] = playCommand;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }

            if (startPositionTicks !== undefined) {
                localVarQueryParameter['startPositionTicks'] = startPositionTicks;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {Array<GeneralCommandType>} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities: async (id?: string, playableMediaTypes?: string, supportedCommands?: Array<GeneralCommandType>, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (playableMediaTypes !== undefined) {
                localVarQueryParameter['playableMediaTypes'] = playableMediaTypes;
            }

            if (supportedCommands) {
                localVarQueryParameter['supportedCommands'] = supportedCommands;
            }

            if (supportsMediaControl !== undefined) {
                localVarQueryParameter['supportsMediaControl'] = supportsMediaControl;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (supportsPersistentIdentifier !== undefined) {
                localVarQueryParameter['supportsPersistentIdentifier'] = supportsPersistentIdentifier;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities: async (clientCapabilities: ClientCapabilities, id?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientCapabilities' is not null or undefined
            if (clientCapabilities === null || clientCapabilities === undefined) {
                throw new RequiredError('clientCapabilities','Required parameter clientCapabilities was null or undefined when calling postFullCapabilities.');
            }
            const localVarPath = `/Sessions/Capabilities/Full`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof clientCapabilities !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(clientCapabilities !== undefined ? clientCapabilities : {}) : (clientCapabilities || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling removeUserFromSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling removeUserFromSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing: async (itemId: string, sessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling reportViewing.');
            }
            const localVarPath = `/Sessions/Viewing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand: async (sessionId: string, generalCommand: GeneralCommand, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendFullGeneralCommand.');
            }
            // verify required parameter 'generalCommand' is not null or undefined
            if (generalCommand === null || generalCommand === undefined) {
                throw new RequiredError('generalCommand','Required parameter generalCommand was null or undefined when calling sendFullGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof generalCommand !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(generalCommand !== undefined ? generalCommand : {}) : (generalCommand || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand: async (sessionId: string, command: GeneralCommandType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendGeneralCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand: async (sessionId: string, text: string, header?: string, timeoutMs?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendMessageCommand.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling sendMessageCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Message`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (header !== undefined) {
                localVarQueryParameter['header'] = header;
            }

            if (timeoutMs !== undefined) {
                localVarQueryParameter['timeoutMs'] = timeoutMs;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand: async (sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendPlaystateCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendPlaystateCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (seekPositionTicks !== undefined) {
                localVarQueryParameter['seekPositionTicks'] = seekPositionTicks;
            }

            if (controllingUserId !== undefined) {
                localVarQueryParameter['controllingUserId'] = controllingUserId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand: async (sessionId: string, command: GeneralCommandType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendSystemCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendSystemCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/System/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).addUserToSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).displayContent(sessionId, itemType, itemId, itemName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getAuthProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordResetProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getPasswordResetProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionInfo>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async play(sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).play(sessionId, playCommand, itemIds, startPositionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {Array<GeneralCommandType>} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCapabilities(id?: string, playableMediaTypes?: string, supportedCommands?: Array<GeneralCommandType>, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postFullCapabilities(clientCapabilities, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).removeUserFromSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSessionEnded(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportSessionEnded(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportViewing(itemId: string, sessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportViewing(itemId, sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendFullGeneralCommand(sessionId, generalCommand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGeneralCommand(sessionId: string, command: GeneralCommandType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendGeneralCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessageCommand(sessionId: string, text: string, header?: string, timeoutMs?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPlaystateCommand(sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendPlaystateCommand(sessionId, command, seekPositionTicks, controllingUserId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSystemCommand(sessionId: string, command: GeneralCommandType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendSystemCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adds an additional user to a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).addUserToSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instructs a session to browse to an item or view.
         * @param {string} sessionId The session Id.
         * @param {string} itemType The type of item to browse to.
         * @param {string} itemId The Id of the item.
         * @param {string} itemName The name of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).displayContent(sessionId, itemType, itemId, itemName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all auth providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all password reset providers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getPasswordResetProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of sessions.
         * @param {string} [controllableByUserId] Filter by sessions that a given user is allowed to remote control.
         * @param {string} [deviceId] Filter by device Id.
         * @param {number} [activeWithinSeconds] Optional. Filter by sessions that were active in the last n seconds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): AxiosPromise<Array<SessionInfo>> {
            return SessionApiFp(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Instructs a session to play an item.
         * @param {string} sessionId The session id.
         * @param {PlayCommand} playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         * @param {string} itemIds The ids of the items to play, comma delimited.
         * @param {number} [startPositionTicks] The starting position of the first item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play(sessionId: string, playCommand: PlayCommand, itemIds: string, startPositionTicks?: number, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).play(sessionId, playCommand, itemIds, startPositionTicks, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {string} [id] The session id.
         * @param {string} [playableMediaTypes] A list of playable media types, comma delimited. Audio, Video, Book, Photo.
         * @param {Array<GeneralCommandType>} [supportedCommands] A list of supported remote control commands, comma delimited.
         * @param {boolean} [supportsMediaControl] Determines whether media can be played remotely..
         * @param {boolean} [supportsSync] Determines whether sync is supported.
         * @param {boolean} [supportsPersistentIdentifier] Determines whether the device supports a unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities(id?: string, playableMediaTypes?: string, supportedCommands?: Array<GeneralCommandType>, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates capabilities for a device.
         * @param {ClientCapabilities} clientCapabilities The MediaBrowser.Model.Session.ClientCapabilities.
         * @param {string} [id] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postFullCapabilities(clientCapabilities, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an additional user from a session.
         * @param {string} sessionId The session id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).removeUserFromSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a session has ended.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded(options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportSessionEnded(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reports that a session is viewing an item.
         * @param {string} itemId The item id.
         * @param {string} [sessionId] The session id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing(itemId: string, sessionId?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportViewing(itemId, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a full general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommand} generalCommand The MediaBrowser.Model.Session.GeneralCommand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendFullGeneralCommand(sessionId, generalCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a general command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand(sessionId: string, command: GeneralCommandType, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendGeneralCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a command to a client to display a message to the user.
         * @param {string} sessionId The session id.
         * @param {string} text The message test.
         * @param {string} [header] The message header.
         * @param {number} [timeoutMs] The message timeout. If omitted the user will have to confirm viewing the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand(sessionId: string, text: string, header?: string, timeoutMs?: number, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a playstate command to a client.
         * @param {string} sessionId The session id.
         * @param {PlaystateCommand} command The MediaBrowser.Model.Session.PlaystateCommand.
         * @param {number} [seekPositionTicks] The optional position ticks.
         * @param {string} [controllingUserId] The optional controlling user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand(sessionId: string, command: PlaystateCommand, seekPositionTicks?: number, controllingUserId?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendPlaystateCommand(sessionId, command, seekPositionTicks, controllingUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issues a system command to a client.
         * @param {string} sessionId The session id.
         * @param {GeneralCommandType} command The command to send.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand(sessionId: string, command: GeneralCommandType, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendSystemCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addUserToSession operation in SessionApi.
 * @export
 * @interface SessionApiAddUserToSessionRequest
 */
export interface SessionApiAddUserToSessionRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiAddUserToSession
     */
    readonly sessionId: string

    /**
     * The user id.
     * @type {string}
     * @memberof SessionApiAddUserToSession
     */
    readonly userId: string
}

/**
 * Request parameters for displayContent operation in SessionApi.
 * @export
 * @interface SessionApiDisplayContentRequest
 */
export interface SessionApiDisplayContentRequest {
    /**
     * The session Id.
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly sessionId: string

    /**
     * The type of item to browse to.
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemType: string

    /**
     * The Id of the item.
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemId: string

    /**
     * The name of the item.
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemName: string
}

/**
 * Request parameters for getSessions operation in SessionApi.
 * @export
 * @interface SessionApiGetSessionsRequest
 */
export interface SessionApiGetSessionsRequest {
    /**
     * Filter by sessions that a given user is allowed to remote control.
     * @type {string}
     * @memberof SessionApiGetSessions
     */
    readonly controllableByUserId?: string

    /**
     * Filter by device Id.
     * @type {string}
     * @memberof SessionApiGetSessions
     */
    readonly deviceId?: string

    /**
     * Optional. Filter by sessions that were active in the last n seconds.
     * @type {number}
     * @memberof SessionApiGetSessions
     */
    readonly activeWithinSeconds?: number
}

/**
 * Request parameters for play operation in SessionApi.
 * @export
 * @interface SessionApiPlayRequest
 */
export interface SessionApiPlayRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiPlay
     */
    readonly sessionId: string

    /**
     * The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @type {PlayCommand}
     * @memberof SessionApiPlay
     */
    readonly playCommand: PlayCommand

    /**
     * The ids of the items to play, comma delimited.
     * @type {string}
     * @memberof SessionApiPlay
     */
    readonly itemIds: string

    /**
     * The starting position of the first item.
     * @type {number}
     * @memberof SessionApiPlay
     */
    readonly startPositionTicks?: number
}

/**
 * Request parameters for postCapabilities operation in SessionApi.
 * @export
 * @interface SessionApiPostCapabilitiesRequest
 */
export interface SessionApiPostCapabilitiesRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiPostCapabilities
     */
    readonly id?: string

    /**
     * A list of playable media types, comma delimited. Audio, Video, Book, Photo.
     * @type {string}
     * @memberof SessionApiPostCapabilities
     */
    readonly playableMediaTypes?: string

    /**
     * A list of supported remote control commands, comma delimited.
     * @type {Array<GeneralCommandType>}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportedCommands?: Array<GeneralCommandType>

    /**
     * Determines whether media can be played remotely..
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsMediaControl?: boolean

    /**
     * Determines whether sync is supported.
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsSync?: boolean

    /**
     * Determines whether the device supports a unique identifier.
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsPersistentIdentifier?: boolean
}

/**
 * Request parameters for postFullCapabilities operation in SessionApi.
 * @export
 * @interface SessionApiPostFullCapabilitiesRequest
 */
export interface SessionApiPostFullCapabilitiesRequest {
    /**
     * The MediaBrowser.Model.Session.ClientCapabilities.
     * @type {ClientCapabilities}
     * @memberof SessionApiPostFullCapabilities
     */
    readonly clientCapabilities: ClientCapabilities

    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiPostFullCapabilities
     */
    readonly id?: string
}

/**
 * Request parameters for removeUserFromSession operation in SessionApi.
 * @export
 * @interface SessionApiRemoveUserFromSessionRequest
 */
export interface SessionApiRemoveUserFromSessionRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiRemoveUserFromSession
     */
    readonly sessionId: string

    /**
     * The user id.
     * @type {string}
     * @memberof SessionApiRemoveUserFromSession
     */
    readonly userId: string
}

/**
 * Request parameters for reportViewing operation in SessionApi.
 * @export
 * @interface SessionApiReportViewingRequest
 */
export interface SessionApiReportViewingRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SessionApiReportViewing
     */
    readonly itemId: string

    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiReportViewing
     */
    readonly sessionId?: string
}

/**
 * Request parameters for sendFullGeneralCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendFullGeneralCommandRequest
 */
export interface SessionApiSendFullGeneralCommandRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiSendFullGeneralCommand
     */
    readonly sessionId: string

    /**
     * The MediaBrowser.Model.Session.GeneralCommand.
     * @type {GeneralCommand}
     * @memberof SessionApiSendFullGeneralCommand
     */
    readonly generalCommand: GeneralCommand
}

/**
 * Request parameters for sendGeneralCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendGeneralCommandRequest
 */
export interface SessionApiSendGeneralCommandRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiSendGeneralCommand
     */
    readonly sessionId: string

    /**
     * The command to send.
     * @type {GeneralCommandType}
     * @memberof SessionApiSendGeneralCommand
     */
    readonly command: GeneralCommandType
}

/**
 * Request parameters for sendMessageCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendMessageCommandRequest
 */
export interface SessionApiSendMessageCommandRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly sessionId: string

    /**
     * The message test.
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly text: string

    /**
     * The message header.
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly header?: string

    /**
     * The message timeout. If omitted the user will have to confirm viewing the message.
     * @type {number}
     * @memberof SessionApiSendMessageCommand
     */
    readonly timeoutMs?: number
}

/**
 * Request parameters for sendPlaystateCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendPlaystateCommandRequest
 */
export interface SessionApiSendPlaystateCommandRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly sessionId: string

    /**
     * The MediaBrowser.Model.Session.PlaystateCommand.
     * @type {PlaystateCommand}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly command: PlaystateCommand

    /**
     * The optional position ticks.
     * @type {number}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly seekPositionTicks?: number

    /**
     * The optional controlling user id.
     * @type {string}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly controllingUserId?: string
}

/**
 * Request parameters for sendSystemCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendSystemCommandRequest
 */
export interface SessionApiSendSystemCommandRequest {
    /**
     * The session id.
     * @type {string}
     * @memberof SessionApiSendSystemCommand
     */
    readonly sessionId: string

    /**
     * The command to send.
     * @type {GeneralCommandType}
     * @memberof SessionApiSendSystemCommand
     */
    readonly command: GeneralCommandType
}

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Adds an additional user to a session.
     * @param {SessionApiAddUserToSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public addUserToSession(requestParameters: SessionApiAddUserToSessionRequest, options?: any) {
        return SessionApiFp(this.configuration).addUserToSession(requestParameters.sessionId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instructs a session to browse to an item or view.
     * @param {SessionApiDisplayContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public displayContent(requestParameters: SessionApiDisplayContentRequest, options?: any) {
        return SessionApiFp(this.configuration).displayContent(requestParameters.sessionId, requestParameters.itemType, requestParameters.itemId, requestParameters.itemName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all auth providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAuthProviders(options?: any) {
        return SessionApiFp(this.configuration).getAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all password reset providers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getPasswordResetProviders(options?: any) {
        return SessionApiFp(this.configuration).getPasswordResetProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of sessions.
     * @param {SessionApiGetSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSessions(requestParameters: SessionApiGetSessionsRequest = {}, options?: any) {
        return SessionApiFp(this.configuration).getSessions(requestParameters.controllableByUserId, requestParameters.deviceId, requestParameters.activeWithinSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Instructs a session to play an item.
     * @param {SessionApiPlayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public play(requestParameters: SessionApiPlayRequest, options?: any) {
        return SessionApiFp(this.configuration).play(requestParameters.sessionId, requestParameters.playCommand, requestParameters.itemIds, requestParameters.startPositionTicks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates capabilities for a device.
     * @param {SessionApiPostCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postCapabilities(requestParameters: SessionApiPostCapabilitiesRequest = {}, options?: any) {
        return SessionApiFp(this.configuration).postCapabilities(requestParameters.id, requestParameters.playableMediaTypes, requestParameters.supportedCommands, requestParameters.supportsMediaControl, requestParameters.supportsSync, requestParameters.supportsPersistentIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates capabilities for a device.
     * @param {SessionApiPostFullCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postFullCapabilities(requestParameters: SessionApiPostFullCapabilitiesRequest, options?: any) {
        return SessionApiFp(this.configuration).postFullCapabilities(requestParameters.clientCapabilities, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an additional user from a session.
     * @param {SessionApiRemoveUserFromSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public removeUserFromSession(requestParameters: SessionApiRemoveUserFromSessionRequest, options?: any) {
        return SessionApiFp(this.configuration).removeUserFromSession(requestParameters.sessionId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a session has ended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportSessionEnded(options?: any) {
        return SessionApiFp(this.configuration).reportSessionEnded(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reports that a session is viewing an item.
     * @param {SessionApiReportViewingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportViewing(requestParameters: SessionApiReportViewingRequest, options?: any) {
        return SessionApiFp(this.configuration).reportViewing(requestParameters.itemId, requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a full general command to a client.
     * @param {SessionApiSendFullGeneralCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendFullGeneralCommand(requestParameters: SessionApiSendFullGeneralCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendFullGeneralCommand(requestParameters.sessionId, requestParameters.generalCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a general command to a client.
     * @param {SessionApiSendGeneralCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendGeneralCommand(requestParameters: SessionApiSendGeneralCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendGeneralCommand(requestParameters.sessionId, requestParameters.command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a command to a client to display a message to the user.
     * @param {SessionApiSendMessageCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendMessageCommand(requestParameters: SessionApiSendMessageCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendMessageCommand(requestParameters.sessionId, requestParameters.text, requestParameters.header, requestParameters.timeoutMs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a playstate command to a client.
     * @param {SessionApiSendPlaystateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendPlaystateCommand(requestParameters: SessionApiSendPlaystateCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendPlaystateCommand(requestParameters.sessionId, requestParameters.command, requestParameters.seekPositionTicks, requestParameters.controllingUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issues a system command to a client.
     * @param {SessionApiSendSystemCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendSystemCommand(requestParameters: SessionApiSendSystemCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendSystemCommand(requestParameters.sessionId, requestParameters.command, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StartupApi - axios parameter creator
 * @export
 */
export const StartupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/FirstUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess: async (startupRemoteAccessDto: StartupRemoteAccessDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupRemoteAccessDto' is not null or undefined
            if (startupRemoteAccessDto === null || startupRemoteAccessDto === undefined) {
                throw new RequiredError('startupRemoteAccessDto','Required parameter startupRemoteAccessDto was null or undefined when calling setRemoteAccess.');
            }
            const localVarPath = `/Startup/RemoteAccess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupRemoteAccessDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupRemoteAccessDto !== undefined ? startupRemoteAccessDto : {}) : (startupRemoteAccessDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration: async (startupConfigurationDto: StartupConfigurationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupConfigurationDto' is not null or undefined
            if (startupConfigurationDto === null || startupConfigurationDto === undefined) {
                throw new RequiredError('startupConfigurationDto','Required parameter startupConfigurationDto was null or undefined when calling updateInitialConfiguration.');
            }
            const localVarPath = `/Startup/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupConfigurationDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupConfigurationDto !== undefined ? startupConfigurationDto : {}) : (startupConfigurationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser: async (startupUserDto?: StartupUserDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupUserDto !== undefined ? startupUserDto : {}) : (startupUserDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StartupApi - functional programming interface
 * @export
 */
export const StartupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWizard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).completeWizard(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartupConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupConfigurationDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getStartupConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).setRemoteAccess(startupRemoteAccessDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateInitialConfiguration(startupConfigurationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStartupUser(startupUserDto?: StartupUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateStartupUser(startupUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StartupApi - factory interface
 * @export
 */
export const StartupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Completes the startup wizard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard(options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).completeWizard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the first user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the initial startup wizard configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration(options?: any): AxiosPromise<StartupConfigurationDto> {
            return StartupApiFp(configuration).getStartupConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets remote access and UPnP.
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto The startup remote access dto.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).setRemoteAccess(startupRemoteAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the initial startup wizard configuration.
         * @param {StartupConfigurationDto} startupConfigurationDto The updated startup configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateInitialConfiguration(startupConfigurationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the user name and password.
         * @param {StartupUserDto} [startupUserDto] The DTO containing username and password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser(startupUserDto?: StartupUserDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateStartupUser(startupUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for setRemoteAccess operation in StartupApi.
 * @export
 * @interface StartupApiSetRemoteAccessRequest
 */
export interface StartupApiSetRemoteAccessRequest {
    /**
     * The startup remote access dto.
     * @type {StartupRemoteAccessDto}
     * @memberof StartupApiSetRemoteAccess
     */
    readonly startupRemoteAccessDto: StartupRemoteAccessDto
}

/**
 * Request parameters for updateInitialConfiguration operation in StartupApi.
 * @export
 * @interface StartupApiUpdateInitialConfigurationRequest
 */
export interface StartupApiUpdateInitialConfigurationRequest {
    /**
     * The updated startup configuration.
     * @type {StartupConfigurationDto}
     * @memberof StartupApiUpdateInitialConfiguration
     */
    readonly startupConfigurationDto: StartupConfigurationDto
}

/**
 * Request parameters for updateStartupUser operation in StartupApi.
 * @export
 * @interface StartupApiUpdateStartupUserRequest
 */
export interface StartupApiUpdateStartupUserRequest {
    /**
     * The DTO containing username and password.
     * @type {StartupUserDto}
     * @memberof StartupApiUpdateStartupUser
     */
    readonly startupUserDto?: StartupUserDto
}

/**
 * StartupApi - object-oriented interface
 * @export
 * @class StartupApi
 * @extends {BaseAPI}
 */
export class StartupApi extends BaseAPI {
    /**
     * 
     * @summary Completes the startup wizard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public completeWizard(options?: any) {
        return StartupApiFp(this.configuration).completeWizard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the first user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the first user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser2(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the initial startup wizard configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getStartupConfiguration(options?: any) {
        return StartupApiFp(this.configuration).getStartupConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets remote access and UPnP.
     * @param {StartupApiSetRemoteAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public setRemoteAccess(requestParameters: StartupApiSetRemoteAccessRequest, options?: any) {
        return StartupApiFp(this.configuration).setRemoteAccess(requestParameters.startupRemoteAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the initial startup wizard configuration.
     * @param {StartupApiUpdateInitialConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateInitialConfiguration(requestParameters: StartupApiUpdateInitialConfigurationRequest, options?: any) {
        return StartupApiFp(this.configuration).updateInitialConfiguration(requestParameters.startupConfigurationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the user name and password.
     * @param {StartupApiUpdateStartupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateStartupUser(requestParameters: StartupApiUpdateStartupUserRequest = {}, options?: any) {
        return StartupApiFp(this.configuration).updateStartupUser(requestParameters.startupUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudiosApi - axios parameter creator
 * @export
 */
export const StudiosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudio.');
            }
            const localVarPath = `/Studios/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios: async (startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Studios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiosApi - functional programming interface
 * @export
 */
export const StudiosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudio(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudio(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudios(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudios(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, enableUserData, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StudiosApi - factory interface
 * @export
 */
export const StudiosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a studio by name.
         * @param {string} name Studio name.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return StudiosApiFp(configuration).getStudio(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all studios from a given item, folder, or the entire library.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [searchTerm] Optional. Search term.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User id.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {boolean} [enableTotalRecordCount] Total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios(startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, isFavorite?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return StudiosApiFp(configuration).getStudios(startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, isFavorite, enableUserData, imageTypeLimit, enableImageTypes, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudio operation in StudiosApi.
 * @export
 * @interface StudiosApiGetStudioRequest
 */
export interface StudiosApiGetStudioRequest {
    /**
     * Studio name.
     * @type {string}
     * @memberof StudiosApiGetStudio
     */
    readonly name: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof StudiosApiGetStudio
     */
    readonly userId?: string
}

/**
 * Request parameters for getStudios operation in StudiosApi.
 * @export
 * @interface StudiosApiGetStudiosRequest
 */
export interface StudiosApiGetStudiosRequest {
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly limit?: number

    /**
     * Optional. Search term.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly searchTerm?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof StudiosApiGetStudios
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly includeItemTypes?: string

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly isFavorite?: boolean

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof StudiosApiGetStudios
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * User id.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly userId?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameLessThan?: string

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableImages?: boolean

    /**
     * Total record count.
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * StudiosApi - object-oriented interface
 * @export
 * @class StudiosApi
 * @extends {BaseAPI}
 */
export class StudiosApi extends BaseAPI {
    /**
     * 
     * @summary Gets a studio by name.
     * @param {StudiosApiGetStudioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudio(requestParameters: StudiosApiGetStudioRequest, options?: any) {
        return StudiosApiFp(this.configuration).getStudio(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all studios from a given item, folder, or the entire library.
     * @param {StudiosApiGetStudiosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudios(requestParameters: StudiosApiGetStudiosRequest = {}, options?: any) {
        return StudiosApiFp(this.configuration).getStudios(requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.isFavorite, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubtitleApi - axios parameter creator
 * @export
 */
export const SubtitleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle: async (itemId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/Subtitles/{index}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles: async (itemId: string, subtitleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteSubtitles.');
            }
            // verify required parameter 'subtitleId' is not null or undefined
            if (subtitleId === null || subtitleId === undefined) {
                throw new RequiredError('subtitleId','Required parameter subtitleId was null or undefined when calling downloadRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"subtitleId"}}`, encodeURIComponent(String(subtitleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a fallback font file.
         * @param {string} name The name of the fallback font file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackFont: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getFallbackFont.');
            }
            const localVarPath = `/FallbackFont/Fonts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of available fallback font files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackFontList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/FallbackFont/Fonts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemoteSubtitles.');
            }
            const localVarPath = `/Providers/Subtitles/Subtitles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle2.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/{startPositionTicks}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist: async (itemId: string, index: number, mediaSourceId: string, segmentLength: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'segmentLength' is not null or undefined
            if (segmentLength === null || segmentLength === undefined) {
                throw new RequiredError('segmentLength','Required parameter segmentLength was null or undefined when calling getSubtitlePlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles: async (itemId: string, language: string, isPerfectMatch?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling searchRemoteSubtitles.');
            }
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling searchRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{language}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isPerfectMatch !== undefined) {
                localVarQueryParameter['isPerfectMatch'] = isPerfectMatch;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an external subtitle file.
         * @param {string} itemId The item the subtitle belongs to.
         * @param {UploadSubtitleDto} uploadSubtitleDto The request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSubtitle: async (itemId: string, uploadSubtitleDto: UploadSubtitleDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling uploadSubtitle.');
            }
            // verify required parameter 'uploadSubtitleDto' is not null or undefined
            if (uploadSubtitleDto === null || uploadSubtitleDto === undefined) {
                throw new RequiredError('uploadSubtitleDto','Required parameter uploadSubtitleDto was null or undefined when calling uploadSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/Subtitles`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof uploadSubtitleDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(uploadSubtitleDto !== undefined ? uploadSubtitleDto : {}) : (uploadSubtitleDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubtitleApi - functional programming interface
 * @export
 */
export const SubtitleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubtitle(itemId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).deleteSubtitle(itemId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).downloadRemoteSubtitles(itemId, subtitleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a fallback font file.
         * @param {string} name The name of the fallback font file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFallbackFont(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getFallbackFont(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of available fallback font files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFallbackFontList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FontFile>>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getFallbackFontList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSubtitles(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getRemoteSubtitles(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSubtitleInfo>>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload an external subtitle file.
         * @param {string} itemId The item the subtitle belongs to.
         * @param {UploadSubtitleDto} uploadSubtitleDto The request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSubtitle(itemId: string, uploadSubtitleDto: UploadSubtitleDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).uploadSubtitle(itemId, uploadSubtitleDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubtitleApi - factory interface
 * @export
 */
export const SubtitleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes an external subtitle file.
         * @param {string} itemId The item id.
         * @param {number} index The index of the subtitle file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle(itemId: string, index: number, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).deleteSubtitle(itemId, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a remote subtitle.
         * @param {string} itemId The item id.
         * @param {string} subtitleId The subtitle id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).downloadRemoteSubtitles(itemId, subtitleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a fallback font file.
         * @param {string} name The name of the fallback font file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackFont(name: string, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).getFallbackFont(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of available fallback font files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackFontList(options?: any): AxiosPromise<Array<FontFile>> {
            return SubtitleApiFp(configuration).getFallbackFontList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the remote subtitles.
         * @param {string} id The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles(id: string, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getRemoteSubtitles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets subtitles in a specified format.
         * @param {string} itemId The item id.
         * @param {string} mediaSourceId The media source id.
         * @param {number} index The subtitle stream index.
         * @param {string} format The format of the returned subtitle.
         * @param {number} startPositionTicks Optional. The start position of the subtitle in ticks.
         * @param {number} [endPositionTicks] Optional. The end position of the subtitle in ticks.
         * @param {boolean} [copyTimestamps] Optional. Whether to copy the timestamps.
         * @param {boolean} [addVttTimeMap] Optional. Whether to add a VTT time map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an HLS subtitle playlist.
         * @param {string} itemId The item id.
         * @param {number} index The subtitle stream index.
         * @param {string} mediaSourceId The media source id.
         * @param {number} segmentLength The subtitle segment length.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): AxiosPromise<any> {
            return SubtitleApiFp(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search remote subtitles.
         * @param {string} itemId The item id.
         * @param {string} language The language of the subtitles.
         * @param {boolean} [isPerfectMatch] Optional. Only show subtitles which are a perfect match.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): AxiosPromise<Array<RemoteSubtitleInfo>> {
            return SubtitleApiFp(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an external subtitle file.
         * @param {string} itemId The item the subtitle belongs to.
         * @param {UploadSubtitleDto} uploadSubtitleDto The request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSubtitle(itemId: string, uploadSubtitleDto: UploadSubtitleDto, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).uploadSubtitle(itemId, uploadSubtitleDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteSubtitle operation in SubtitleApi.
 * @export
 * @interface SubtitleApiDeleteSubtitleRequest
 */
export interface SubtitleApiDeleteSubtitleRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiDeleteSubtitle
     */
    readonly itemId: string

    /**
     * The index of the subtitle file.
     * @type {number}
     * @memberof SubtitleApiDeleteSubtitle
     */
    readonly index: number
}

/**
 * Request parameters for downloadRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiDownloadRemoteSubtitlesRequest
 */
export interface SubtitleApiDownloadRemoteSubtitlesRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiDownloadRemoteSubtitles
     */
    readonly itemId: string

    /**
     * The subtitle id.
     * @type {string}
     * @memberof SubtitleApiDownloadRemoteSubtitles
     */
    readonly subtitleId: string
}

/**
 * Request parameters for getFallbackFont operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetFallbackFontRequest
 */
export interface SubtitleApiGetFallbackFontRequest {
    /**
     * The name of the fallback font file to get.
     * @type {string}
     * @memberof SubtitleApiGetFallbackFont
     */
    readonly name: string
}

/**
 * Request parameters for getRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetRemoteSubtitlesRequest
 */
export interface SubtitleApiGetRemoteSubtitlesRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiGetRemoteSubtitles
     */
    readonly id: string
}

/**
 * Request parameters for getSubtitle operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitleRequest
 */
export interface SubtitleApiGetSubtitleRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly itemId: string

    /**
     * The media source id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly mediaSourceId: string

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly index: number

    /**
     * The format of the returned subtitle.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly format: string

    /**
     * Optional. The start position of the subtitle in ticks.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly startPositionTicks: number

    /**
     * Optional. The end position of the subtitle in ticks.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly endPositionTicks?: number

    /**
     * Optional. Whether to copy the timestamps.
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Whether to add a VTT time map.
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly addVttTimeMap?: boolean
}

/**
 * Request parameters for getSubtitle2 operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitle2Request
 */
export interface SubtitleApiGetSubtitle2Request {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly itemId: string

    /**
     * The media source id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly mediaSourceId: string

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly index: number

    /**
     * The format of the returned subtitle.
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly format: string

    /**
     * Optional. The start position of the subtitle in ticks.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly startPositionTicks: number

    /**
     * Optional. The end position of the subtitle in ticks.
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly endPositionTicks?: number

    /**
     * Optional. Whether to copy the timestamps.
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Whether to add a VTT time map.
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly addVttTimeMap?: boolean
}

/**
 * Request parameters for getSubtitlePlaylist operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitlePlaylistRequest
 */
export interface SubtitleApiGetSubtitlePlaylistRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly itemId: string

    /**
     * The subtitle stream index.
     * @type {number}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly index: number

    /**
     * The media source id.
     * @type {string}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly mediaSourceId: string

    /**
     * The subtitle segment length.
     * @type {number}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly segmentLength: number
}

/**
 * Request parameters for searchRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiSearchRemoteSubtitlesRequest
 */
export interface SubtitleApiSearchRemoteSubtitlesRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly itemId: string

    /**
     * The language of the subtitles.
     * @type {string}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly language: string

    /**
     * Optional. Only show subtitles which are a perfect match.
     * @type {boolean}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly isPerfectMatch?: boolean
}

/**
 * Request parameters for uploadSubtitle operation in SubtitleApi.
 * @export
 * @interface SubtitleApiUploadSubtitleRequest
 */
export interface SubtitleApiUploadSubtitleRequest {
    /**
     * The item the subtitle belongs to.
     * @type {string}
     * @memberof SubtitleApiUploadSubtitle
     */
    readonly itemId: string

    /**
     * The request body.
     * @type {UploadSubtitleDto}
     * @memberof SubtitleApiUploadSubtitle
     */
    readonly uploadSubtitleDto: UploadSubtitleDto
}

/**
 * SubtitleApi - object-oriented interface
 * @export
 * @class SubtitleApi
 * @extends {BaseAPI}
 */
export class SubtitleApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an external subtitle file.
     * @param {SubtitleApiDeleteSubtitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public deleteSubtitle(requestParameters: SubtitleApiDeleteSubtitleRequest, options?: any) {
        return SubtitleApiFp(this.configuration).deleteSubtitle(requestParameters.itemId, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a remote subtitle.
     * @param {SubtitleApiDownloadRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public downloadRemoteSubtitles(requestParameters: SubtitleApiDownloadRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).downloadRemoteSubtitles(requestParameters.itemId, requestParameters.subtitleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a fallback font file.
     * @param {SubtitleApiGetFallbackFontRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getFallbackFont(requestParameters: SubtitleApiGetFallbackFontRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getFallbackFont(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of available fallback font files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getFallbackFontList(options?: any) {
        return SubtitleApiFp(this.configuration).getFallbackFontList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the remote subtitles.
     * @param {SubtitleApiGetRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getRemoteSubtitles(requestParameters: SubtitleApiGetRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getRemoteSubtitles(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets subtitles in a specified format.
     * @param {SubtitleApiGetSubtitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle(requestParameters: SubtitleApiGetSubtitleRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.index, requestParameters.format, requestParameters.startPositionTicks, requestParameters.endPositionTicks, requestParameters.copyTimestamps, requestParameters.addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets subtitles in a specified format.
     * @param {SubtitleApiGetSubtitle2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle2(requestParameters: SubtitleApiGetSubtitle2Request, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle2(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.index, requestParameters.format, requestParameters.startPositionTicks, requestParameters.endPositionTicks, requestParameters.copyTimestamps, requestParameters.addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an HLS subtitle playlist.
     * @param {SubtitleApiGetSubtitlePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitlePlaylist(requestParameters: SubtitleApiGetSubtitlePlaylistRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitlePlaylist(requestParameters.itemId, requestParameters.index, requestParameters.mediaSourceId, requestParameters.segmentLength, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search remote subtitles.
     * @param {SubtitleApiSearchRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public searchRemoteSubtitles(requestParameters: SubtitleApiSearchRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).searchRemoteSubtitles(requestParameters.itemId, requestParameters.language, requestParameters.isPerfectMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an external subtitle file.
     * @param {SubtitleApiUploadSubtitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public uploadSubtitle(requestParameters: SubtitleApiUploadSubtitleRequest, options?: any) {
        return SubtitleApiFp(this.configuration).uploadSubtitle(requestParameters.itemId, requestParameters.uploadSubtitleDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuggestionsApi - axios parameter creator
 * @export
 */
export const SuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions: async (userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSuggestions.');
            }
            const localVarPath = `/Users/{userId}/Suggestions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaType !== undefined) {
                localVarQueryParameter['mediaType'] = mediaType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionsApi - functional programming interface
 * @export
 */
export const SuggestionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await SuggestionsApiAxiosParamCreator(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SuggestionsApi - factory interface
 * @export
 */
export const SuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets suggestions.
         * @param {string} userId The user id.
         * @param {string} [mediaType] The media types.
         * @param {string} [type] The type.
         * @param {number} [startIndex] Optional. The start index.
         * @param {number} [limit] Optional. The limit.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total record count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return SuggestionsApiFp(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSuggestions operation in SuggestionsApi.
 * @export
 * @interface SuggestionsApiGetSuggestionsRequest
 */
export interface SuggestionsApiGetSuggestionsRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly userId: string

    /**
     * The media types.
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly mediaType?: string

    /**
     * The type.
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly type?: string

    /**
     * Optional. The start index.
     * @type {number}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly startIndex?: number

    /**
     * Optional. The limit.
     * @type {number}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly limit?: number

    /**
     * Whether to enable the total record count.
     * @type {boolean}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * SuggestionsApi - object-oriented interface
 * @export
 * @class SuggestionsApi
 * @extends {BaseAPI}
 */
export class SuggestionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets suggestions.
     * @param {SuggestionsApiGetSuggestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestionsApi
     */
    public getSuggestions(requestParameters: SuggestionsApiGetSuggestionsRequest, options?: any) {
        return SuggestionsApiFp(this.configuration).getSuggestions(requestParameters.userId, requestParameters.mediaType, requestParameters.type, requestParameters.startIndex, requestParameters.limit, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncPlayApi - axios parameter creator
 * @export
 */
export const SyncPlayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering: async (when?: string, positionTicks?: number, bufferingDone?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Buffering`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (when !== undefined) {
                localVarQueryParameter['when'] = (when as any instanceof Date) ?
                    (when as any).toISOString() :
                    when;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (bufferingDone !== undefined) {
                localVarQueryParameter['bufferingDone'] = bufferingDone;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/New`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups: async (filterItemId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (filterItemId !== undefined) {
                localVarQueryParameter['filterItemId'] = filterItemId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling syncPlayJoinGroup.');
            }
            const localVarPath = `/SyncPlay/Join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Leave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Pause`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing: async (ping?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ping !== undefined) {
                localVarQueryParameter['ping'] = ping;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Play`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek: async (positionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Seek`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncPlayApi - functional programming interface
 * @export
 */
export const SyncPlayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayCreateGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayCreateGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayGetGroups(filterItemId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupInfoView>>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayGetGroups(filterItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayJoinGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayJoinGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayLeaveGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayLeaveGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPause(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPause(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPing(ping?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPing(ping, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPlay(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPlay(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlaySeek(positionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlaySeek(positionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SyncPlayApi - factory interface
 * @export
 */
export const SyncPlayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Request group wait in SyncPlay group while buffering.
         * @param {string} [when] When the request has been made by the client.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {boolean} [bufferingDone] Whether the buffering is done.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayCreateGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all SyncPlay groups.
         * @param {string} [filterItemId] Optional. Filter by item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups(filterItemId?: string, options?: any): AxiosPromise<Array<GroupInfoView>> {
            return SyncPlayApiFp(configuration).syncPlayGetGroups(filterItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join an existing SyncPlay group.
         * @param {string} groupId The sync play group id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup(groupId: string, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayJoinGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave the joined SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayLeaveGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request pause in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPause(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update session ping.
         * @param {number} [ping] The ping.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing(ping?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPing(ping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request play in SyncPlay group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPlay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request seek in SyncPlay group.
         * @param {number} [positionTicks] The playback position in ticks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek(positionTicks?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlaySeek(positionTicks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for syncPlayBuffering operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayBufferingRequest
 */
export interface SyncPlayApiSyncPlayBufferingRequest {
    /**
     * When the request has been made by the client.
     * @type {string}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly when?: string

    /**
     * The playback position in ticks.
     * @type {number}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly positionTicks?: number

    /**
     * Whether the buffering is done.
     * @type {boolean}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly bufferingDone?: boolean
}

/**
 * Request parameters for syncPlayGetGroups operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayGetGroupsRequest
 */
export interface SyncPlayApiSyncPlayGetGroupsRequest {
    /**
     * Optional. Filter by item id.
     * @type {string}
     * @memberof SyncPlayApiSyncPlayGetGroups
     */
    readonly filterItemId?: string
}

/**
 * Request parameters for syncPlayJoinGroup operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayJoinGroupRequest
 */
export interface SyncPlayApiSyncPlayJoinGroupRequest {
    /**
     * The sync play group id.
     * @type {string}
     * @memberof SyncPlayApiSyncPlayJoinGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for syncPlayPing operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayPingRequest
 */
export interface SyncPlayApiSyncPlayPingRequest {
    /**
     * The ping.
     * @type {number}
     * @memberof SyncPlayApiSyncPlayPing
     */
    readonly ping?: number
}

/**
 * Request parameters for syncPlaySeek operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlaySeekRequest
 */
export interface SyncPlayApiSyncPlaySeekRequest {
    /**
     * The playback position in ticks.
     * @type {number}
     * @memberof SyncPlayApiSyncPlaySeek
     */
    readonly positionTicks?: number
}

/**
 * SyncPlayApi - object-oriented interface
 * @export
 * @class SyncPlayApi
 * @extends {BaseAPI}
 */
export class SyncPlayApi extends BaseAPI {
    /**
     * 
     * @summary Request group wait in SyncPlay group while buffering.
     * @param {SyncPlayApiSyncPlayBufferingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayBuffering(requestParameters: SyncPlayApiSyncPlayBufferingRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayBuffering(requestParameters.when, requestParameters.positionTicks, requestParameters.bufferingDone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayCreateGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayCreateGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all SyncPlay groups.
     * @param {SyncPlayApiSyncPlayGetGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayGetGroups(requestParameters: SyncPlayApiSyncPlayGetGroupsRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayGetGroups(requestParameters.filterItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join an existing SyncPlay group.
     * @param {SyncPlayApiSyncPlayJoinGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayJoinGroup(requestParameters: SyncPlayApiSyncPlayJoinGroupRequest, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayJoinGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave the joined SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayLeaveGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayLeaveGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request pause in SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPause(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPause(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update session ping.
     * @param {SyncPlayApiSyncPlayPingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPing(requestParameters: SyncPlayApiSyncPlayPingRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPing(requestParameters.ping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request play in SyncPlay group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPlay(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPlay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request seek in SyncPlay group.
     * @param {SyncPlayApiSyncPlaySeekRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlaySeek(requestParameters: SyncPlayApiSyncPlaySeekRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlaySeek(requestParameters.positionTicks, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Endpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getLogFile.');
            }
            const localVarPath = `/System/Logs/Log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info/Public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/WakeOnLanInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEndpointInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndPointInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getEndpointInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogFile(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getLogFile(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPublicSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerLogs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogFile>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getServerLogs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWakeOnLanInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WakeOnLanInfo>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getWakeOnLanInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).postPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).restartApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).shutdownApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets information about the request endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo(options?: any): AxiosPromise<EndPointInfo> {
            return SystemApiFp(configuration).getEndpointInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a log file.
         * @param {string} name The name of the log file to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile(name: string, options?: any): AxiosPromise<any> {
            return SystemApiFp(configuration).getLogFile(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).getPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets public information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo(options?: any): AxiosPromise<PublicSystemInfo> {
            return SystemApiFp(configuration).getPublicSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of available server log files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs(options?: any): AxiosPromise<Array<LogFile>> {
            return SystemApiFp(configuration).getServerLogs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets information about the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
            return SystemApiFp(configuration).getSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets wake on lan information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo(options?: any): AxiosPromise<Array<WakeOnLanInfo>> {
            return SystemApiFp(configuration).getWakeOnLanInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pings the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).postPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restarts the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).restartApplication(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Shuts down the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).shutdownApplication(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLogFile operation in SystemApi.
 * @export
 * @interface SystemApiGetLogFileRequest
 */
export interface SystemApiGetLogFileRequest {
    /**
     * The name of the log file to get.
     * @type {string}
     * @memberof SystemApiGetLogFile
     */
    readonly name: string
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Gets information about the request endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getEndpointInfo(options?: any) {
        return SystemApiFp(this.configuration).getEndpointInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a log file.
     * @param {SystemApiGetLogFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getLogFile(requestParameters: SystemApiGetLogFileRequest, options?: any) {
        return SystemApiFp(this.configuration).getLogFile(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPingSystem(options?: any) {
        return SystemApiFp(this.configuration).getPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets public information about the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPublicSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getPublicSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of available server log files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getServerLogs(options?: any) {
        return SystemApiFp(this.configuration).getServerLogs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets information about the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets wake on lan information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getWakeOnLanInfo(options?: any) {
        return SystemApiFp(this.configuration).getWakeOnLanInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pings the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public postPingSystem(options?: any) {
        return SystemApiFp(this.configuration).postPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restarts the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public restartApplication(options?: any) {
        return SystemApiFp(this.configuration).restartApplication(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Shuts down the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public shutdownApplication(options?: any) {
        return SystemApiFp(this.configuration).shutdownApplication(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeSyncApi - axios parameter creator
 * @export
 */
export const TimeSyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUtcTime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSyncApi - functional programming interface
 * @export
 */
export const TimeSyncApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUtcTime(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtcTimeResponse>> {
            const localVarAxiosArgs = await TimeSyncApiAxiosParamCreator(configuration).getUtcTime(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimeSyncApi - factory interface
 * @export
 */
export const TimeSyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets the current utc time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime(options?: any): AxiosPromise<UtcTimeResponse> {
            return TimeSyncApiFp(configuration).getUtcTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSyncApi - object-oriented interface
 * @export
 * @class TimeSyncApi
 * @extends {BaseAPI}
 */
export class TimeSyncApi extends BaseAPI {
    /**
     * 
     * @summary Gets the current utc time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSyncApi
     */
    public getUtcTime(options?: any) {
        return TimeSyncApiFp(this.configuration).getUtcTime(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrailersApi - axios parameter creator
 * @export
 */
export const TrailersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers: async (userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trailers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrailersApi - functional programming interface
 * @export
 */
export const TrailersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TrailersApiAxiosParamCreator(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TrailersApi - factory interface
 * @export
 */
export const TrailersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Finds movies and trailers similar to a given trailer.
         * @param {string} [userId] The user id.
         * @param {string} [maxOfficialRating] Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [hasThemeSong] Optional filter by items with theme songs.
         * @param {boolean} [hasThemeVideo] Optional filter by items with theme videos.
         * @param {boolean} [hasSubtitles] Optional filter by items with subtitles.
         * @param {boolean} [hasSpecialFeature] Optional filter by items with special features.
         * @param {boolean} [hasTrailer] Optional filter by items with trailers.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {number} [parentIndexNumber] Optional filter by parent index number.
         * @param {boolean} [hasParentalRating] Optional filter by items that have or do not have a parental rating.
         * @param {boolean} [isHd] Optional filter by items that are HD or not.
         * @param {boolean} [is4K] Optional filter by items that are 4K or not.
         * @param {string} [locationTypes] Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
         * @param {Array<LocationType>} [excludeLocationTypes] Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
         * @param {boolean} [isMissing] Optional filter by items that are missing episodes or not.
         * @param {boolean} [isUnaired] Optional filter by items that are unaired episodes or not.
         * @param {number} [minCommunityRating] Optional filter by minimum community rating.
         * @param {number} [minCriticRating] Optional filter by minimum critic rating.
         * @param {string} [minPremiereDate] Optional. The minimum premiere date. Format &#x3D; ISO.
         * @param {string} [minDateLastSaved] Optional. The minimum last saved date. Format &#x3D; ISO.
         * @param {string} [minDateLastSavedForUser] Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
         * @param {string} [maxPremiereDate] Optional. The maximum premiere date. Format &#x3D; ISO.
         * @param {boolean} [hasOverview] Optional filter by items that have an overview or not.
         * @param {boolean} [hasImdbId] Optional filter by items that have an imdb id or not.
         * @param {boolean} [hasTmdbId] Optional filter by items that have a tmdb id or not.
         * @param {boolean} [hasTvdbId] Optional filter by items that have a tvdb id or not.
         * @param {string} [excludeItemIds] Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [recursive] When searching within folders, this determines whether or not the search will be recursive. true/false.
         * @param {string} [searchTerm] Optional. Filter based on a search term.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {Array<ItemFilter>} [filters] Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
         * @param {boolean} [isFavorite] Optional filter by items that are marked as favorite, or not.
         * @param {string} [mediaTypes] Optional filter by MediaType. Allows multiple, comma delimited.
         * @param {Array<ImageType>} [imageTypes] Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [isPlayed] Optional filter by items that are played, or not.
         * @param {string} [genres] Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         * @param {string} [officialRatings] Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         * @param {string} [tags] Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         * @param {string} [years] Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         * @param {boolean} [enableUserData] Optional, include user data.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [person] Optional. If specified, results will be filtered to include only those containing the specified person.
         * @param {string} [personIds] Optional. If specified, results will be filtered to include only those containing the specified person id.
         * @param {string} [personTypes] Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
         * @param {string} [studios] Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         * @param {string} [artists] Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
         * @param {string} [excludeArtistIds] Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
         * @param {string} [artistIds] Optional. If specified, results will be filtered to include only those containing the specified artist id.
         * @param {string} [albumArtistIds] Optional. If specified, results will be filtered to include only those containing the specified album artist id.
         * @param {string} [contributingArtistIds] Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
         * @param {string} [albums] Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         * @param {string} [albumIds] Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
         * @param {string} [ids] Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
         * @param {string} [videoTypes] Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         * @param {string} [minOfficialRating] Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         * @param {boolean} [isLocked] Optional filter by items that are locked.
         * @param {boolean} [isPlaceHolder] Optional filter by items that are placeholders.
         * @param {boolean} [hasOfficialRating] Optional filter by items that have official ratings.
         * @param {boolean} [collapseBoxSetItems] Whether or not to hide items behind their boxsets.
         * @param {number} [minWidth] Optional. Filter by the minimum width of the item.
         * @param {number} [minHeight] Optional. Filter by the minimum height of the item.
         * @param {number} [maxWidth] Optional. Filter by the maximum width of the item.
         * @param {number} [maxHeight] Optional. Filter by the maximum height of the item.
         * @param {boolean} [is3D] Optional filter by items that are 3D, or not.
         * @param {string} [seriesStatus] Optional filter by Series Status. Allows multiple, comma delimeted.
         * @param {string} [nameStartsWithOrGreater] Optional filter by items whose name is sorted equally or greater than a given input string.
         * @param {string} [nameStartsWith] Optional filter by items whose name is sorted equally than a given input string.
         * @param {string} [nameLessThan] Optional filter by items whose name is equally or lesser than a given input string.
         * @param {string} [studioIds] Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
         * @param {string} [genreIds] Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
         * @param {boolean} [enableTotalRecordCount] Optional. Enable the total record count.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: Array<LocationType>, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, filters?: Array<ItemFilter>, isFavorite?: boolean, mediaTypes?: string, imageTypes?: Array<ImageType>, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TrailersApiFp(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTrailers operation in TrailersApi.
 * @export
 * @interface TrailersApiGetTrailersRequest
 */
export interface TrailersApiGetTrailersRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly userId?: string

    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxOfficialRating?: string

    /**
     * Optional filter by items with theme songs.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasThemeSong?: boolean

    /**
     * Optional filter by items with theme videos.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasThemeVideo?: boolean

    /**
     * Optional filter by items with subtitles.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasSubtitles?: boolean

    /**
     * Optional filter by items with special features.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasSpecialFeature?: boolean

    /**
     * Optional filter by items with trailers.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTrailer?: boolean

    /**
     * Optional. Return items that are siblings of a supplied item.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly adjacentTo?: string

    /**
     * Optional filter by parent index number.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly parentIndexNumber?: number

    /**
     * Optional filter by items that have or do not have a parental rating.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasParentalRating?: boolean

    /**
     * Optional filter by items that are HD or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isHd?: boolean

    /**
     * Optional filter by items that are 4K or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly is4K?: boolean

    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly locationTypes?: string

    /**
     * Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimeted.
     * @type {Array<LocationType>}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeLocationTypes?: Array<LocationType>

    /**
     * Optional filter by items that are missing episodes or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isMissing?: boolean

    /**
     * Optional filter by items that are unaired episodes or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isUnaired?: boolean

    /**
     * Optional filter by minimum community rating.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minCommunityRating?: number

    /**
     * Optional filter by minimum critic rating.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minCriticRating?: number

    /**
     * Optional. The minimum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minPremiereDate?: string

    /**
     * Optional. The minimum last saved date. Format &#x3D; ISO.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minDateLastSaved?: string

    /**
     * Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minDateLastSavedForUser?: string

    /**
     * Optional. The maximum premiere date. Format &#x3D; ISO.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxPremiereDate?: string

    /**
     * Optional filter by items that have an overview or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasOverview?: boolean

    /**
     * Optional filter by items that have an imdb id or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasImdbId?: boolean

    /**
     * Optional filter by items that have a tmdb id or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTmdbId?: boolean

    /**
     * Optional filter by items that have a tvdb id or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTvdbId?: boolean

    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeItemIds?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly limit?: number

    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly recursive?: boolean

    /**
     * Optional. Filter based on a search term.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly searchTerm?: string

    /**
     * Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly sortOrder?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
     * @type {Array<ItemFields>}
     * @memberof TrailersApiGetTrailers
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
     * @type {Array<ItemFilter>}
     * @memberof TrailersApiGetTrailers
     */
    readonly filters?: Array<ItemFilter>

    /**
     * Optional filter by items that are marked as favorite, or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isFavorite?: boolean

    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly mediaTypes?: string

    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @type {Array<ImageType>}
     * @memberof TrailersApiGetTrailers
     */
    readonly imageTypes?: Array<ImageType>

    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly sortBy?: string

    /**
     * Optional filter by items that are played, or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isPlayed?: boolean

    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly genres?: string

    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly officialRatings?: string

    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly tags?: string

    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly years?: string

    /**
     * Optional, include user data.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableUserData?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly person?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person id.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly personIds?: string

    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly personTypes?: string

    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly studios?: string

    /**
     * Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly artists?: string

    /**
     * Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified artist id.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly artistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified album artist id.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albumArtistIds?: string

    /**
     * Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly contributingArtistIds?: string

    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albums?: string

    /**
     * Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albumIds?: string

    /**
     * Optional. If specific items are needed, specify a list of item id\&#39;s to retrieve. This allows multiple, comma delimited.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly ids?: string

    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly videoTypes?: string

    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minOfficialRating?: string

    /**
     * Optional filter by items that are locked.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isLocked?: boolean

    /**
     * Optional filter by items that are placeholders.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isPlaceHolder?: boolean

    /**
     * Optional filter by items that have official ratings.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasOfficialRating?: boolean

    /**
     * Whether or not to hide items behind their boxsets.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * Optional. Filter by the minimum width of the item.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minWidth?: number

    /**
     * Optional. Filter by the minimum height of the item.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minHeight?: number

    /**
     * Optional. Filter by the maximum width of the item.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxWidth?: number

    /**
     * Optional. Filter by the maximum height of the item.
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxHeight?: number

    /**
     * Optional filter by items that are 3D, or not.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly is3D?: boolean

    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly seriesStatus?: string

    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameStartsWith?: string

    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameLessThan?: string

    /**
     * Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly studioIds?: string

    /**
     * Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimeted.
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly genreIds?: string

    /**
     * Optional. Enable the total record count.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableImages?: boolean
}

/**
 * TrailersApi - object-oriented interface
 * @export
 * @class TrailersApi
 * @extends {BaseAPI}
 */
export class TrailersApi extends BaseAPI {
    /**
     * 
     * @summary Finds movies and trailers similar to a given trailer.
     * @param {TrailersApiGetTrailersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrailersApi
     */
    public getTrailers(requestParameters: TrailersApiGetTrailersRequest = {}, options?: any) {
        return TrailersApiFp(this.configuration).getTrailers(requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TvShowsApi - axios parameter creator
 * @export
 */
export const TvShowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes: async (seriesId: string, userId?: string, fields?: Array<ItemFields>, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getEpisodes.');
            }
            const localVarPath = `/Shows/{seriesId}/Episodes`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (seasonId !== undefined) {
                localVarQueryParameter['seasonId'] = seasonId;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (startItemId !== undefined) {
                localVarQueryParameter['startItemId'] = startItemId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp: async (userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Shows/NextUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (seriesId !== undefined) {
                localVarQueryParameter['seriesId'] = seriesId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons: async (seriesId: string, userId?: string, fields?: Array<ItemFields>, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getSeasons.');
            }
            const localVarPath = `/Shows/{seriesId}/Seasons`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (isSpecialSeason !== undefined) {
                localVarQueryParameter['isSpecialSeason'] = isSpecialSeason;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes: async (userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Shows/Upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TvShowsApi - functional programming interface
 * @export
 */
export const TvShowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEpisodes(seriesId: string, userId?: string, fields?: Array<ItemFields>, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextUp(userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeasons(seriesId: string, userId?: string, fields?: Array<ItemFields>, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingEpisodes(userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TvShowsApi - factory interface
 * @export
 */
export const TvShowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets episodes for a tv season.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {number} [season] Optional filter by season number.
         * @param {string} [seasonId] Optional. Filter by season id.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {string} [startItemId] Optional. Skip through the list until a given item is found.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {boolean} [enableImages] Optional, include image information in output.
         * @param {number} [imageTypeLimit] Optional, the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes(seriesId: string, userId?: string, fields?: Array<ItemFields>, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, sortBy?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of next up episodes.
         * @param {string} [userId] The user id of the user to get the next up episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [seriesId] Optional. Filter by series id.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {boolean} [enableTotalRecordCount] Whether to enable the total records count. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp(userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets seasons for a tv series.
         * @param {string} seriesId The series id.
         * @param {string} [userId] The user id.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
         * @param {boolean} [isSpecialSeason] Optional. Filter by special season.
         * @param {boolean} [isMissing] Optional. Filter by items that are missing episodes or not.
         * @param {string} [adjacentTo] Optional. Return items that are siblings of a supplied item.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons(seriesId: string, userId?: string, fields?: Array<ItemFields>, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of upcoming episodes.
         * @param {string} [userId] The user id of the user to get the upcoming episodes for.
         * @param {number} [startIndex] Optional. The record index to start at. All items with a lower index will be dropped from the results.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [parentId] Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {boolean} [enableImges] Optional. Include image information in output.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes(userId?: string, startIndex?: number, limit?: number, fields?: Array<ItemFields>, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEpisodes operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetEpisodesRequest
 */
export interface TvShowsApiGetEpisodesRequest {
    /**
     * The series id.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly seriesId: string

    /**
     * The user id.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly userId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional filter by season number.
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly season?: number

    /**
     * Optional. Filter by season id.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly seasonId?: string

    /**
     * Optional. Filter by items that are missing episodes or not.
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly isMissing?: boolean

    /**
     * Optional. Return items that are siblings of a supplied item.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly adjacentTo?: string

    /**
     * Optional. Skip through the list until a given item is found.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly startItemId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly limit?: number

    /**
     * Optional, include image information in output.
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableImages?: boolean

    /**
     * Optional, the max number of images to return, per image type.
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableUserData?: boolean

    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly sortBy?: string
}

/**
 * Request parameters for getNextUp operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetNextUpRequest
 */
export interface TvShowsApiGetNextUpRequest {
    /**
     * The user id of the user to get the next up episodes for.
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof TvShowsApiGetNextUp
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Filter by series id.
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly seriesId?: string

    /**
     * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly parentId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableImges?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableUserData?: boolean

    /**
     * Whether to enable the total records count. Defaults to true.
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getSeasons operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetSeasonsRequest
 */
export interface TvShowsApiGetSeasonsRequest {
    /**
     * The series id.
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly seriesId: string

    /**
     * The user id.
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly userId?: string

    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
     * @type {Array<ItemFields>}
     * @memberof TvShowsApiGetSeasons
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Filter by special season.
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly isSpecialSeason?: boolean

    /**
     * Optional. Filter by items that are missing episodes or not.
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly isMissing?: boolean

    /**
     * Optional. Return items that are siblings of a supplied item.
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly adjacentTo?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableImages?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof TvShowsApiGetSeasons
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableUserData?: boolean
}

/**
 * Request parameters for getUpcomingEpisodes operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetUpcomingEpisodesRequest
 */
export interface TvShowsApiGetUpcomingEpisodesRequest {
    /**
     * The user id of the user to get the upcoming episodes for.
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly userId?: string

    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly limit?: number

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly parentId?: string

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableImges?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableUserData?: boolean
}

/**
 * TvShowsApi - object-oriented interface
 * @export
 * @class TvShowsApi
 * @extends {BaseAPI}
 */
export class TvShowsApi extends BaseAPI {
    /**
     * 
     * @summary Gets episodes for a tv season.
     * @param {TvShowsApiGetEpisodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getEpisodes(requestParameters: TvShowsApiGetEpisodesRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getEpisodes(requestParameters.seriesId, requestParameters.userId, requestParameters.fields, requestParameters.season, requestParameters.seasonId, requestParameters.isMissing, requestParameters.adjacentTo, requestParameters.startItemId, requestParameters.startIndex, requestParameters.limit, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of next up episodes.
     * @param {TvShowsApiGetNextUpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getNextUp(requestParameters: TvShowsApiGetNextUpRequest = {}, options?: any) {
        return TvShowsApiFp(this.configuration).getNextUp(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.seriesId, requestParameters.parentId, requestParameters.enableImges, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets seasons for a tv series.
     * @param {TvShowsApiGetSeasonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getSeasons(requestParameters: TvShowsApiGetSeasonsRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getSeasons(requestParameters.seriesId, requestParameters.userId, requestParameters.fields, requestParameters.isSpecialSeason, requestParameters.isMissing, requestParameters.adjacentTo, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of upcoming episodes.
     * @param {TvShowsApiGetUpcomingEpisodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getUpcomingEpisodes(requestParameters: TvShowsApiGetUpcomingEpisodesRequest = {}, options?: any) {
        return TvShowsApiFp(this.configuration).getUpcomingEpisodes(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.parentId, requestParameters.enableImges, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UniversalAudioApi - axios parameter creator
 * @export
 */
export const UniversalAudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream: async (itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream: async (itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniversalAudioApi - functional programming interface
 * @export
 */
export const UniversalAudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalAudioStream(itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, audioBitRate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUniversalAudioStream(itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, audioBitRate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UniversalAudioApi - factory interface
 * @export
 */
export const UniversalAudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream(itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, audioBitRate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an audio stream.
         * @param {string} itemId The item id.
         * @param {string} [container] Optional. The audio container.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [userId] Optional. The user id.
         * @param {string} [audioCodec] Optional. The audio codec to transcode to.
         * @param {number} [maxAudioChannels] Optional. The maximum number of audio channels.
         * @param {number} [transcodingAudioChannels] Optional. The number of how many audio channels to transcode to.
         * @param {number} [maxStreamingBitrate] Optional. The maximum streaming bitrate.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {string} [transcodingContainer] Optional. The container to transcode to.
         * @param {string} [transcodingProtocol] Optional. The transcoding protocol.
         * @param {number} [maxAudioSampleRate] Optional. The maximum audio sample rate.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {boolean} [enableRemoteMedia] Optional. Whether to enable remote media.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {boolean} [enableRedirection] Whether to enable redirection. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream(itemId: string, container?: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, audioBitRate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<any> {
            return UniversalAudioApiFp(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, audioBitRate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUniversalAudioStream operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiGetUniversalAudioStreamRequest
 */
export interface UniversalAudioApiGetUniversalAudioStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly itemId: string

    /**
     * Optional. The audio container.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly container?: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly deviceId?: string

    /**
     * Optional. The user id.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly userId?: string

    /**
     * Optional. The audio codec to transcode to.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly audioCodec?: string

    /**
     * Optional. The maximum number of audio channels.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. The number of how many audio channels to transcode to.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingAudioChannels?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The container to transcode to.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingContainer?: string

    /**
     * Optional. The transcoding protocol.
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingProtocol?: string

    /**
     * Optional. The maximum audio sample rate.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Whether to enable remote media.
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly enableRemoteMedia?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Whether to enable redirection. Defaults to true.
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly enableRedirection?: boolean
}

/**
 * Request parameters for headUniversalAudioStream operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiHeadUniversalAudioStreamRequest
 */
export interface UniversalAudioApiHeadUniversalAudioStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly itemId: string

    /**
     * Optional. The audio container.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly container?: string

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly deviceId?: string

    /**
     * Optional. The user id.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly userId?: string

    /**
     * Optional. The audio codec to transcode to.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly audioCodec?: string

    /**
     * Optional. The maximum number of audio channels.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. The number of how many audio channels to transcode to.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingAudioChannels?: number

    /**
     * Optional. The maximum streaming bitrate.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The container to transcode to.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingContainer?: string

    /**
     * Optional. The transcoding protocol.
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingProtocol?: string

    /**
     * Optional. The maximum audio sample rate.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Whether to enable remote media.
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly enableRemoteMedia?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Whether to enable redirection. Defaults to true.
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly enableRedirection?: boolean
}

/**
 * UniversalAudioApi - object-oriented interface
 * @export
 * @class UniversalAudioApi
 * @extends {BaseAPI}
 */
export class UniversalAudioApi extends BaseAPI {
    /**
     * 
     * @summary Gets an audio stream.
     * @param {UniversalAudioApiGetUniversalAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public getUniversalAudioStream(requestParameters: UniversalAudioApiGetUniversalAudioStreamRequest, options?: any) {
        return UniversalAudioApiFp(this.configuration).getUniversalAudioStream(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an audio stream.
     * @param {UniversalAudioApiHeadUniversalAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public headUniversalAudioStream(requestParameters: UniversalAudioApiHeadUniversalAudioStreamRequest, options?: any) {
        return UniversalAudioApiFp(this.configuration).headUniversalAudioStream(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.audioBitRate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (userId: string, pw: string, password?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling authenticateUser.');
            }
            // verify required parameter 'pw' is not null or undefined
            if (pw === null || pw === undefined) {
                throw new RequiredError('pw','Required parameter pw was null or undefined when calling authenticateUser.');
            }
            const localVarPath = `/Users/{userId}/Authenticate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName: async (authenticateUserByName: AuthenticateUserByName, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateUserByName' is not null or undefined
            if (authenticateUserByName === null || authenticateUserByName === undefined) {
                throw new RequiredError('authenticateUserByName','Required parameter authenticateUserByName was null or undefined when calling authenticateUserByName.');
            }
            const localVarPath = `/Users/AuthenticateByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authenticateUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authenticateUserByName !== undefined ? authenticateUserByName : {}) : (authenticateUserByName || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect: async (quickConnectDto: QuickConnectDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'quickConnectDto' is not null or undefined
            if (quickConnectDto === null || quickConnectDto === undefined) {
                throw new RequiredError('quickConnectDto','Required parameter quickConnectDto was null or undefined when calling authenticateWithQuickConnect.');
            }
            const localVarPath = `/Users/AuthenticateWithQuickConnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof quickConnectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(quickConnectDto !== undefined ? quickConnectDto : {}) : (quickConnectDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName: async (createUserByName?: CreateUserByName, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/New`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserByName !== undefined ? createUserByName : {}) : (createUserByName || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            if (forgotPasswordDto === null || forgotPasswordDto === undefined) {
                throw new RequiredError('forgotPasswordDto','Required parameter forgotPasswordDto was null or undefined when calling forgotPassword.');
            }
            const localVarPath = `/Users/ForgotPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof forgotPasswordDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(forgotPasswordDto !== undefined ? forgotPasswordDto : {}) : (forgotPasswordDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/ForgotPassword/Pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user based on auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (isHidden?: boolean, isDisabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isDisabled !== undefined) {
                localVarQueryParameter['isDisabled'] = isDisabled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userDto?: UserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userDto !== undefined ? userDto : {}) : (userDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration: async (userId: string, userConfiguration?: UserConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserConfiguration.');
            }
            const localVarPath = `/Users/{userId}/Configuration`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userConfiguration !== undefined ? userConfiguration : {}) : (userConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword: async (userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserEasyPassword.');
            }
            const localVarPath = `/Users/{userId}/EasyPassword`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserEasyPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserEasyPassword !== undefined ? updateUserEasyPassword : {}) : (updateUserEasyPassword || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (userId: string, updateUserPassword?: UpdateUserPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPassword.');
            }
            const localVarPath = `/Users/{userId}/Password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPassword !== undefined ? updateUserPassword : {}) : (updateUserPassword || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy: async (userId: string, userPolicy?: UserPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPolicy.');
            }
            const localVarPath = `/Users/{userId}/Policy`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPolicy !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPolicy !== undefined ? userPolicy : {}) : (userPolicy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(userId: string, pw: string, password?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUser(userId, pw, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUserByName(authenticateUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateWithQuickConnect(quickConnectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserByName(createUserByName?: CreateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUserByName(createUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgotPasswordResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPassword(forgotPasswordDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPasswordPin(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinRedeemResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPasswordPin(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the user based on auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getCurrentUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getPublicUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserById(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(isHidden, isDisabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userDto?: UserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUser(userId, userDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserConfiguration(userId, userConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPassword(userId, updateUserPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPolicy(userId, userPolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Authenticates a user.
         * @param {string} userId The user id.
         * @param {string} pw The password as plain text.
         * @param {string} [password] The password sha1-hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(userId: string, pw: string, password?: string, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUser(userId, pw, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticates a user by name.
         * @param {AuthenticateUserByName} authenticateUserByName The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUserByName(authenticateUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticates a user with quick connect.
         * @param {QuickConnectDto} quickConnectDto The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateWithQuickConnect(quickConnectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a user.
         * @param {CreateUserByName} [createUserByName] The create user by name request body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName(createUserByName?: CreateUserByName, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).createUserByName(createUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a user.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiates the forgot password process for a local user.
         * @param {ForgotPasswordDto} forgotPasswordDto The forgot password request containing the entered username.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): AxiosPromise<ForgotPasswordResult> {
            return UserApiFp(configuration).forgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redeems a forgot password pin.
         * @param {string} [body] The pin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin(body?: string, options?: any): AxiosPromise<PinRedeemResult> {
            return UserApiFp(configuration).forgotPasswordPin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the user based on auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of publicly visible users for display on a login screen.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers(options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getPublicUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a user by Id.
         * @param {string} userId The user id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a list of users.
         * @param {boolean} [isHidden] Optional filter by IsHidden&#x3D;true or false.
         * @param {boolean} [isDisabled] Optional filter by IsDisabled&#x3D;true or false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getUsers(isHidden, isDisabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user.
         * @param {string} userId The user id.
         * @param {UserDto} [userDto] The updated user model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userDto?: UserDto, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUser(userId, userDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user configuration.
         * @param {string} userId The user id.
         * @param {UserConfiguration} [userConfiguration] The new user configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserConfiguration(userId, userConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s easy password.
         * @param {string} userId The user id.
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s password.
         * @param {string} userId The user id.
         * @param {UpdateUserPassword} [updateUserPassword] The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPassword(userId, updateUserPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user policy.
         * @param {string} userId The user id.
         * @param {UserPolicy} [userPolicy] The new user policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPolicy(userId, userPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticateUser operation in UserApi.
 * @export
 * @interface UserApiAuthenticateUserRequest
 */
export interface UserApiAuthenticateUserRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly userId: string

    /**
     * The password as plain text.
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly pw: string

    /**
     * The password sha1-hash.
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly password?: string
}

/**
 * Request parameters for authenticateUserByName operation in UserApi.
 * @export
 * @interface UserApiAuthenticateUserByNameRequest
 */
export interface UserApiAuthenticateUserByNameRequest {
    /**
     * The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request.
     * @type {AuthenticateUserByName}
     * @memberof UserApiAuthenticateUserByName
     */
    readonly authenticateUserByName: AuthenticateUserByName
}

/**
 * Request parameters for authenticateWithQuickConnect operation in UserApi.
 * @export
 * @interface UserApiAuthenticateWithQuickConnectRequest
 */
export interface UserApiAuthenticateWithQuickConnectRequest {
    /**
     * The Jellyfin.Api.Models.UserDtos.QuickConnectDto request.
     * @type {QuickConnectDto}
     * @memberof UserApiAuthenticateWithQuickConnect
     */
    readonly quickConnectDto: QuickConnectDto
}

/**
 * Request parameters for createUserByName operation in UserApi.
 * @export
 * @interface UserApiCreateUserByNameRequest
 */
export interface UserApiCreateUserByNameRequest {
    /**
     * The create user by name request body.
     * @type {CreateUserByName}
     * @memberof UserApiCreateUserByName
     */
    readonly createUserByName?: CreateUserByName
}

/**
 * Request parameters for deleteUser operation in UserApi.
 * @export
 * @interface UserApiDeleteUserRequest
 */
export interface UserApiDeleteUserRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiDeleteUser
     */
    readonly userId: string
}

/**
 * Request parameters for forgotPassword operation in UserApi.
 * @export
 * @interface UserApiForgotPasswordRequest
 */
export interface UserApiForgotPasswordRequest {
    /**
     * The forgot password request containing the entered username.
     * @type {ForgotPasswordDto}
     * @memberof UserApiForgotPassword
     */
    readonly forgotPasswordDto: ForgotPasswordDto
}

/**
 * Request parameters for forgotPasswordPin operation in UserApi.
 * @export
 * @interface UserApiForgotPasswordPinRequest
 */
export interface UserApiForgotPasswordPinRequest {
    /**
     * The pin.
     * @type {string}
     * @memberof UserApiForgotPasswordPin
     */
    readonly body?: string
}

/**
 * Request parameters for getUserById operation in UserApi.
 * @export
 * @interface UserApiGetUserByIdRequest
 */
export interface UserApiGetUserByIdRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiGetUserById
     */
    readonly userId: string
}

/**
 * Request parameters for getUsers operation in UserApi.
 * @export
 * @interface UserApiGetUsersRequest
 */
export interface UserApiGetUsersRequest {
    /**
     * Optional filter by IsHidden&#x3D;true or false.
     * @type {boolean}
     * @memberof UserApiGetUsers
     */
    readonly isHidden?: boolean

    /**
     * Optional filter by IsDisabled&#x3D;true or false.
     * @type {boolean}
     * @memberof UserApiGetUsers
     */
    readonly isDisabled?: boolean
}

/**
 * Request parameters for updateUser operation in UserApi.
 * @export
 * @interface UserApiUpdateUserRequest
 */
export interface UserApiUpdateUserRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiUpdateUser
     */
    readonly userId: string

    /**
     * The updated user model.
     * @type {UserDto}
     * @memberof UserApiUpdateUser
     */
    readonly userDto?: UserDto
}

/**
 * Request parameters for updateUserConfiguration operation in UserApi.
 * @export
 * @interface UserApiUpdateUserConfigurationRequest
 */
export interface UserApiUpdateUserConfigurationRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiUpdateUserConfiguration
     */
    readonly userId: string

    /**
     * The new user configuration.
     * @type {UserConfiguration}
     * @memberof UserApiUpdateUserConfiguration
     */
    readonly userConfiguration?: UserConfiguration
}

/**
 * Request parameters for updateUserEasyPassword operation in UserApi.
 * @export
 * @interface UserApiUpdateUserEasyPasswordRequest
 */
export interface UserApiUpdateUserEasyPasswordRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiUpdateUserEasyPassword
     */
    readonly userId: string

    /**
     * The M:Jellyfin.Api.Controllers.UserController.UpdateUserEasyPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserEasyPassword) request.
     * @type {UpdateUserEasyPassword}
     * @memberof UserApiUpdateUserEasyPassword
     */
    readonly updateUserEasyPassword?: UpdateUserEasyPassword
}

/**
 * Request parameters for updateUserPassword operation in UserApi.
 * @export
 * @interface UserApiUpdateUserPasswordRequest
 */
export interface UserApiUpdateUserPasswordRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiUpdateUserPassword
     */
    readonly userId: string

    /**
     * The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Guid,Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request.
     * @type {UpdateUserPassword}
     * @memberof UserApiUpdateUserPassword
     */
    readonly updateUserPassword?: UpdateUserPassword
}

/**
 * Request parameters for updateUserPolicy operation in UserApi.
 * @export
 * @interface UserApiUpdateUserPolicyRequest
 */
export interface UserApiUpdateUserPolicyRequest {
    /**
     * The user id.
     * @type {string}
     * @memberof UserApiUpdateUserPolicy
     */
    readonly userId: string

    /**
     * The new user policy.
     * @type {UserPolicy}
     * @memberof UserApiUpdateUserPolicy
     */
    readonly userPolicy?: UserPolicy
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Authenticates a user.
     * @param {UserApiAuthenticateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUser(requestParameters: UserApiAuthenticateUserRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateUser(requestParameters.userId, requestParameters.pw, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticates a user by name.
     * @param {UserApiAuthenticateUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUserByName(requestParameters: UserApiAuthenticateUserByNameRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateUserByName(requestParameters.authenticateUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticates a user with quick connect.
     * @param {UserApiAuthenticateWithQuickConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateWithQuickConnect(requestParameters: UserApiAuthenticateWithQuickConnectRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateWithQuickConnect(requestParameters.quickConnectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a user.
     * @param {UserApiCreateUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserByName(requestParameters: UserApiCreateUserByNameRequest = {}, options?: any) {
        return UserApiFp(this.configuration).createUserByName(requestParameters.createUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a user.
     * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(requestParameters: UserApiDeleteUserRequest, options?: any) {
        return UserApiFp(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiates the forgot password process for a local user.
     * @param {UserApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPassword(requestParameters: UserApiForgotPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).forgotPassword(requestParameters.forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redeems a forgot password pin.
     * @param {UserApiForgotPasswordPinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPasswordPin(requestParameters: UserApiForgotPasswordPinRequest = {}, options?: any) {
        return UserApiFp(this.configuration).forgotPasswordPin(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the user based on auth token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: any) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of publicly visible users for display on a login screen.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUsers(options?: any) {
        return UserApiFp(this.configuration).getPublicUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a user by Id.
     * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(requestParameters: UserApiGetUserByIdRequest, options?: any) {
        return UserApiFp(this.configuration).getUserById(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a list of users.
     * @param {UserApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(requestParameters: UserApiGetUsersRequest = {}, options?: any) {
        return UserApiFp(this.configuration).getUsers(requestParameters.isHidden, requestParameters.isDisabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user.
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(requestParameters: UserApiUpdateUserRequest, options?: any) {
        return UserApiFp(this.configuration).updateUser(requestParameters.userId, requestParameters.userDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user configuration.
     * @param {UserApiUpdateUserConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserConfiguration(requestParameters: UserApiUpdateUserConfigurationRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserConfiguration(requestParameters.userId, requestParameters.userConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s easy password.
     * @param {UserApiUpdateUserEasyPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserEasyPassword(requestParameters: UserApiUpdateUserEasyPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserEasyPassword(requestParameters.userId, requestParameters.updateUserEasyPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s password.
     * @param {UserApiUpdateUserPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(requestParameters: UserApiUpdateUserPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPassword(requestParameters.userId, requestParameters.updateUserPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user policy.
     * @param {UserApiUpdateUserPolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPolicy(requestParameters: UserApiUpdateUserPolicyRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPolicy(requestParameters.userId, requestParameters.userPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserLibraryApi - axios parameter creator
 * @export
 */
export const UserLibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getIntros.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getIntros.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Intros`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia: async (userId: string, parentId?: string, fields?: Array<ItemFields>, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, limit?: number, groupItems?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLatestMedia.');
            }
            const localVarPath = `/Users/{userId}/Items/Latest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (groupItems !== undefined) {
                localVarQueryParameter['groupItems'] = groupItems;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLocalTrailers.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLocalTrailers.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/LocalTrailers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getRootFolder.');
            }
            const localVarPath = `/Users/{userId}/Items/Root`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSpecialFeatures.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSpecialFeatures.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/SpecialFeatures`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling unmarkFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling unmarkFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating: async (userId: string, itemId: string, likes?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (likes !== undefined) {
                localVarQueryParameter['likes'] = likes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLibraryApi - functional programming interface
 * @export
 */
export const UserLibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserItemRating(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).deleteUserItemRating(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntros(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getIntros(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMedia(userId: string, parentId?: string, fields?: Array<ItemFields>, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalTrailers(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLocalTrailers(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootFolder(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getRootFolder(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecialFeatures(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getSpecialFeatures(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).markFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmarkFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).unmarkFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).updateUserItemRating(userId, itemId, likes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserLibraryApi - factory interface
 * @export
 */
export const UserLibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Deletes a user\'s saved personal rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).deleteUserItemRating(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets intros to play before the main media item plays.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserLibraryApiFp(configuration).getIntros(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an item from a user\'s library.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets latest media.
         * @param {string} userId User id.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [includeItemTypes] Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         * @param {boolean} [isPlayed] Filter by items that are played, or not.
         * @param {boolean} [enableImages] Optional. include image information in output.
         * @param {number} [imageTypeLimit] Optional. the max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {boolean} [enableUserData] Optional. include user data.
         * @param {number} [limit] Return item limit.
         * @param {boolean} [groupItems] Whether or not to group items into a parent container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia(userId: string, parentId?: string, fields?: Array<ItemFields>, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets local trailers for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLocalTrailers(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the root folder from a user\'s library.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder(userId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getRootFolder(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets special features for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getSpecialFeatures(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks an item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).markFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unmarks item as a favorite.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).unmarkFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user\'s rating for an item.
         * @param {string} userId User id.
         * @param {string} itemId Item id.
         * @param {boolean} [likes] Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).updateUserItemRating(userId, itemId, likes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteUserItemRating operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiDeleteUserItemRatingRequest
 */
export interface UserLibraryApiDeleteUserItemRatingRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiDeleteUserItemRating
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiDeleteUserItemRating
     */
    readonly itemId: string
}

/**
 * Request parameters for getIntros operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetIntrosRequest
 */
export interface UserLibraryApiGetIntrosRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetIntros
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiGetIntros
     */
    readonly itemId: string
}

/**
 * Request parameters for getItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetItemRequest
 */
export interface UserLibraryApiGetItemRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetItem
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiGetItem
     */
    readonly itemId: string
}

/**
 * Request parameters for getLatestMedia operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetLatestMediaRequest
 */
export interface UserLibraryApiGetLatestMediaRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly userId: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly includeItemTypes?: string

    /**
     * Filter by items that are played, or not.
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly isPlayed?: boolean

    /**
     * Optional. include image information in output.
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableImages?: boolean

    /**
     * Optional. the max number of images to return, per image type.
     * @type {number}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * Optional. include user data.
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableUserData?: boolean

    /**
     * Return item limit.
     * @type {number}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly limit?: number

    /**
     * Whether or not to group items into a parent container.
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly groupItems?: boolean
}

/**
 * Request parameters for getLocalTrailers operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetLocalTrailersRequest
 */
export interface UserLibraryApiGetLocalTrailersRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetLocalTrailers
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiGetLocalTrailers
     */
    readonly itemId: string
}

/**
 * Request parameters for getRootFolder operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetRootFolderRequest
 */
export interface UserLibraryApiGetRootFolderRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetRootFolder
     */
    readonly userId: string
}

/**
 * Request parameters for getSpecialFeatures operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetSpecialFeaturesRequest
 */
export interface UserLibraryApiGetSpecialFeaturesRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiGetSpecialFeatures
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiGetSpecialFeatures
     */
    readonly itemId: string
}

/**
 * Request parameters for markFavoriteItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiMarkFavoriteItemRequest
 */
export interface UserLibraryApiMarkFavoriteItemRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiMarkFavoriteItem
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiMarkFavoriteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for unmarkFavoriteItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiUnmarkFavoriteItemRequest
 */
export interface UserLibraryApiUnmarkFavoriteItemRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiUnmarkFavoriteItem
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiUnmarkFavoriteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for updateUserItemRating operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiUpdateUserItemRatingRequest
 */
export interface UserLibraryApiUpdateUserItemRatingRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly userId: string

    /**
     * Item id.
     * @type {string}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly itemId: string

    /**
     * Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Guid,System.Guid,System.Nullable{System.Boolean}) is likes.
     * @type {boolean}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly likes?: boolean
}

/**
 * UserLibraryApi - object-oriented interface
 * @export
 * @class UserLibraryApi
 * @extends {BaseAPI}
 */
export class UserLibraryApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a user\'s saved personal rating for an item.
     * @param {UserLibraryApiDeleteUserItemRatingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public deleteUserItemRating(requestParameters: UserLibraryApiDeleteUserItemRatingRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).deleteUserItemRating(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets intros to play before the main media item plays.
     * @param {UserLibraryApiGetIntrosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getIntros(requestParameters: UserLibraryApiGetIntrosRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getIntros(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an item from a user\'s library.
     * @param {UserLibraryApiGetItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getItem(requestParameters: UserLibraryApiGetItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets latest media.
     * @param {UserLibraryApiGetLatestMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLatestMedia(requestParameters: UserLibraryApiGetLatestMediaRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getLatestMedia(requestParameters.userId, requestParameters.parentId, requestParameters.fields, requestParameters.includeItemTypes, requestParameters.isPlayed, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.limit, requestParameters.groupItems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets local trailers for an item.
     * @param {UserLibraryApiGetLocalTrailersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLocalTrailers(requestParameters: UserLibraryApiGetLocalTrailersRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getLocalTrailers(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the root folder from a user\'s library.
     * @param {UserLibraryApiGetRootFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getRootFolder(requestParameters: UserLibraryApiGetRootFolderRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getRootFolder(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets special features for an item.
     * @param {UserLibraryApiGetSpecialFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getSpecialFeatures(requestParameters: UserLibraryApiGetSpecialFeaturesRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getSpecialFeatures(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks an item as a favorite.
     * @param {UserLibraryApiMarkFavoriteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public markFavoriteItem(requestParameters: UserLibraryApiMarkFavoriteItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).markFavoriteItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unmarks item as a favorite.
     * @param {UserLibraryApiUnmarkFavoriteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public unmarkFavoriteItem(requestParameters: UserLibraryApiUnmarkFavoriteItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).unmarkFavoriteItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user\'s rating for an item.
     * @param {UserLibraryApiUpdateUserItemRatingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public updateUserItemRating(requestParameters: UserLibraryApiUpdateUserItemRatingRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).updateUserItemRating(requestParameters.userId, requestParameters.itemId, requestParameters.likes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserViewsApi - axios parameter creator
 * @export
 */
export const UserViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getGroupingOptions.');
            }
            const localVarPath = `/Users/{userId}/GroupingOptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews: async (userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserViews.');
            }
            const localVarPath = `/Users/{userId}/Views`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (includeExternalContent !== undefined) {
                localVarQueryParameter['includeExternalContent'] = includeExternalContent;
            }

            if (presetViews !== undefined) {
                localVarQueryParameter['presetViews'] = presetViews;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['includeHidden'] = includeHidden;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserViewsApi - functional programming interface
 * @export
 */
export const UserViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupingOptions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecialViewOptionDto>>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getGroupingOptions(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserViewsApi - factory interface
 * @export
 */
export const UserViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get user view grouping options.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions(userId: string, options?: any): AxiosPromise<Array<SpecialViewOptionDto>> {
            return UserViewsApiFp(configuration).getGroupingOptions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user views.
         * @param {string} userId User id.
         * @param {boolean} [includeExternalContent] Whether or not to include external views such as channels or live tv.
         * @param {string} [presetViews] Preset views.
         * @param {boolean} [includeHidden] Whether or not to include hidden content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserViewsApiFp(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGroupingOptions operation in UserViewsApi.
 * @export
 * @interface UserViewsApiGetGroupingOptionsRequest
 */
export interface UserViewsApiGetGroupingOptionsRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserViewsApiGetGroupingOptions
     */
    readonly userId: string
}

/**
 * Request parameters for getUserViews operation in UserViewsApi.
 * @export
 * @interface UserViewsApiGetUserViewsRequest
 */
export interface UserViewsApiGetUserViewsRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserViewsApiGetUserViews
     */
    readonly userId: string

    /**
     * Whether or not to include external views such as channels or live tv.
     * @type {boolean}
     * @memberof UserViewsApiGetUserViews
     */
    readonly includeExternalContent?: boolean

    /**
     * Preset views.
     * @type {string}
     * @memberof UserViewsApiGetUserViews
     */
    readonly presetViews?: string

    /**
     * Whether or not to include hidden content.
     * @type {boolean}
     * @memberof UserViewsApiGetUserViews
     */
    readonly includeHidden?: boolean
}

/**
 * UserViewsApi - object-oriented interface
 * @export
 * @class UserViewsApi
 * @extends {BaseAPI}
 */
export class UserViewsApi extends BaseAPI {
    /**
     * 
     * @summary Get user view grouping options.
     * @param {UserViewsApiGetGroupingOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getGroupingOptions(requestParameters: UserViewsApiGetGroupingOptionsRequest, options?: any) {
        return UserViewsApiFp(this.configuration).getGroupingOptions(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user views.
     * @param {UserViewsApiGetUserViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getUserViews(requestParameters: UserViewsApiGetUserViewsRequest, options?: any) {
        return UserViewsApiFp(this.configuration).getUserViews(requestParameters.userId, requestParameters.includeExternalContent, requestParameters.presetViews, requestParameters.includeHidden, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoAttachmentsApi - axios parameter creator
 * @export
 */
export const VideoAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (videoId: string, mediaSourceId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/Videos/{videoId}/{mediaSourceId}/Attachments/{index}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoAttachmentsApi - functional programming interface
 * @export
 */
export const VideoAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideoAttachmentsApiAxiosParamCreator(configuration).getAttachment(videoId, mediaSourceId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoAttachmentsApi - factory interface
 * @export
 */
export const VideoAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get video attachment.
         * @param {string} videoId Video ID.
         * @param {string} mediaSourceId Media Source ID.
         * @param {number} index Attachment Index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): AxiosPromise<any> {
            return VideoAttachmentsApiFp(configuration).getAttachment(videoId, mediaSourceId, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAttachment operation in VideoAttachmentsApi.
 * @export
 * @interface VideoAttachmentsApiGetAttachmentRequest
 */
export interface VideoAttachmentsApiGetAttachmentRequest {
    /**
     * Video ID.
     * @type {string}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly videoId: string

    /**
     * Media Source ID.
     * @type {string}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly mediaSourceId: string

    /**
     * Attachment Index.
     * @type {number}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly index: number
}

/**
 * VideoAttachmentsApi - object-oriented interface
 * @export
 * @class VideoAttachmentsApi
 * @extends {BaseAPI}
 */
export class VideoAttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Get video attachment.
     * @param {VideoAttachmentsApiGetAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoAttachmentsApi
     */
    public getAttachment(requestParameters: VideoAttachmentsApiGetAttachmentRequest, options?: any) {
        return VideoAttachmentsApiFp(this.configuration).getAttachment(requestParameters.videoId, requestParameters.mediaSourceId, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoHlsApi - axios parameter creator
 * @export
 */
export const VideoHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream: async (itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLiveHlsStream.');
            }
            const localVarPath = `/Videos/{itemId}/live.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (enableSubtitlesInManifest !== undefined) {
                localVarQueryParameter['enableSubtitlesInManifest'] = enableSubtitlesInManifest;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoHlsApi - functional programming interface
 * @export
 */
export const VideoHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideoHlsApiAxiosParamCreator(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoHlsApi - factory interface
 * @export
 */
export const VideoHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a hls live stream.
         * @param {string} itemId The item id.
         * @param {string} [container] The audio container.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {number} [maxWidth] Optional. The max width.
         * @param {number} [maxHeight] Optional. The max height.
         * @param {boolean} [enableSubtitlesInManifest] Optional. Whether to enable subtitles in the manifest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): AxiosPromise<any> {
            return VideoHlsApiFp(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLiveHlsStream operation in VideoHlsApi.
 * @export
 * @interface VideoHlsApiGetLiveHlsStreamRequest
 */
export interface VideoHlsApiGetLiveHlsStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly itemId: string

    /**
     * The audio container.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly container?: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * Optional. The max width.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxWidth?: number

    /**
     * Optional. The max height.
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxHeight?: number

    /**
     * Optional. Whether to enable subtitles in the manifest.
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableSubtitlesInManifest?: boolean
}

/**
 * VideoHlsApi - object-oriented interface
 * @export
 * @class VideoHlsApi
 * @extends {BaseAPI}
 */
export class VideoHlsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a hls live stream.
     * @param {VideoHlsApiGetLiveHlsStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoHlsApi
     */
    public getLiveHlsStream(requestParameters: VideoHlsApiGetLiveHlsStreamRequest, options?: any) {
        return VideoHlsApiFp(this.configuration).getLiveHlsStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.enableSubtitlesInManifest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteAlternateSources.');
            }
            const localVarPath = `/Videos/{itemId}/AlternateSources`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAdditionalPart.');
            }
            const localVarPath = `/Videos/{itemId}/AdditionalParts`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStreamWithExt: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStreamWithExt.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStreamWithExt.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling getVideoStreamWithExt.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStreamWithExt: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStreamWithExt.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStreamWithExt.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling headVideoStreamWithExt.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions: async (itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling mergeVersions.');
            }
            const localVarPath = `/Videos/MergeVersions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlternateSources(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).deleteAlternateSources(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdditionalPart(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getAdditionalPart(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeVersions(itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).mergeVersions(itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Removes alternate video sources.
         * @param {string} itemId The item id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources(itemId: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).deleteAlternateSources(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets additional parts for a video.
         * @param {string} itemId The item id.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart(itemId: string, userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return VideosApiFp(configuration).getAdditionalPart(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).getVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a video stream.
         * @param {string} itemId The item id.
         * @param {string} container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
         * @param {string} stream 
         * @param {boolean} [_static] Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
         * @param {string} [params] The streaming parameters.
         * @param {string} [tag] The tag.
         * @param {string} [deviceProfileId] Optional. The dlna device profile id to utilize.
         * @param {string} [playSessionId] The play session id.
         * @param {string} [segmentContainer] The segment container.
         * @param {number} [segmentLength] The segment lenght.
         * @param {number} [minSegments] The minimum number of segments.
         * @param {string} [mediaSourceId] The media version id, if playing an alternate version.
         * @param {string} [deviceId] The device id of the client requesting. Used to stop encoding processes when needed.
         * @param {string} [audioCodec] Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
         * @param {boolean} [enableAutoStreamCopy] Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         * @param {boolean} [allowVideoStreamCopy] Whether or not to allow copying of the video stream url.
         * @param {boolean} [allowAudioStreamCopy] Whether or not to allow copying of the audio stream url.
         * @param {boolean} [breakOnNonKeyFrames] Optional. Whether to break on non key frames.
         * @param {number} [audioSampleRate] Optional. Specify a specific audio sample rate, e.g. 44100.
         * @param {number} [maxAudioBitDepth] Optional. The maximum audio bit depth.
         * @param {number} [audioBitRate] Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         * @param {number} [audioChannels] Optional. Specify a specific number of audio channels to encode to, e.g. 2.
         * @param {number} [maxAudioChannels] Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
         * @param {string} [profile] Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
         * @param {string} [level] Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
         * @param {number} [framerate] Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {number} [maxFramerate] Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
         * @param {boolean} [copyTimestamps] Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         * @param {number} [startTimeTicks] Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
         * @param {number} [width] Optional. The fixed horizontal resolution of the encoded video.
         * @param {number} [height] Optional. The fixed vertical resolution of the encoded video.
         * @param {number} [videoBitRate] Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         * @param {number} [subtitleStreamIndex] Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         * @param {SubtitleDeliveryMethod} [subtitleMethod] Optional. Specify the subtitle delivery method.
         * @param {number} [maxRefFrames] Optional.
         * @param {number} [maxVideoBitDepth] Optional. The maximum video bit depth.
         * @param {boolean} [requireAvc] Optional. Whether to require avc.
         * @param {boolean} [deInterlace] Optional. Whether to deinterlace the video.
         * @param {boolean} [requireNonAnamorphic] Optional. Whether to require a non anamporphic stream.
         * @param {number} [transcodingMaxAudioChannels] Optional. The maximum number of audio channels to transcode.
         * @param {number} [cpuCoreLimit] Optional. The limit of how many cpu cores to use.
         * @param {string} [liveStreamId] The live stream id.
         * @param {boolean} [enableMpegtsM2TsMode] Optional. Whether to enable the MpegtsM2Ts mode.
         * @param {string} [videoCodec] Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
         * @param {string} [subtitleCodec] Optional. Specify a subtitle codec to encode to.
         * @param {string} [transcodingReasons] Optional. The transcoding reason.
         * @param {number} [audioStreamIndex] Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         * @param {number} [videoStreamIndex] Optional. The index of the video stream to use. If omitted the first video stream will be used.
         * @param {EncodingContext} [context] Optional. The MediaBrowser.Model.Dlna.EncodingContext.
         * @param {{ [key: string]: string; }} [streamOptions] Optional. The streaming options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStreamWithExt(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<any> {
            return VideosApiFp(configuration).headVideoStreamWithExt(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merges videos into a single record.
         * @param {string} itemIds Item id list. This allows multiple, comma delimited.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions(itemIds: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).mergeVersions(itemIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAlternateSources operation in VideosApi.
 * @export
 * @interface VideosApiDeleteAlternateSourcesRequest
 */
export interface VideosApiDeleteAlternateSourcesRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiDeleteAlternateSources
     */
    readonly itemId: string
}

/**
 * Request parameters for getAdditionalPart operation in VideosApi.
 * @export
 * @interface VideosApiGetAdditionalPartRequest
 */
export interface VideosApiGetAdditionalPartRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiGetAdditionalPart
     */
    readonly itemId: string

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof VideosApiGetAdditionalPart
     */
    readonly userId?: string
}

/**
 * Request parameters for getVideoStream operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoStreamRequest
 */
export interface VideosApiGetVideoStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly itemId: string

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof VideosApiGetVideoStream
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiGetVideoStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getVideoStreamWithExt operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoStreamWithExtRequest
 */
export interface VideosApiGetVideoStreamWithExtRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly itemId: string

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly stream: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiGetVideoStreamWithExt
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headVideoStream operation in VideosApi.
 * @export
 * @interface VideosApiHeadVideoStreamRequest
 */
export interface VideosApiHeadVideoStreamRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly itemId: string

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly container: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof VideosApiHeadVideoStream
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiHeadVideoStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headVideoStreamWithExt operation in VideosApi.
 * @export
 * @interface VideosApiHeadVideoStreamWithExtRequest
 */
export interface VideosApiHeadVideoStreamWithExtRequest {
    /**
     * The item id.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly itemId: string

    /**
     * The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly stream: string

    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly _static?: boolean

    /**
     * The streaming parameters.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly params?: string

    /**
     * The tag.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly tag?: string

    /**
     * Optional. The dlna device profile id to utilize.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly deviceProfileId?: string

    /**
     * The play session id.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly playSessionId?: string

    /**
     * The segment container.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly segmentContainer?: string

    /**
     * The segment lenght.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly segmentLength?: number

    /**
     * The minimum number of segments.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly minSegments?: number

    /**
     * The media version id, if playing an alternate version.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly mediaSourceId?: string

    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly deviceId?: string

    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url\&#39;s extension. Options: aac, mp3, vorbis, wma.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly audioCodec?: string

    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the video stream url.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * Whether or not to allow copying of the audio stream url.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * Optional. Whether to break on non key frames.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly audioSampleRate?: number

    /**
     * Optional. The maximum audio bit depth.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly maxAudioBitDepth?: number

    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly audioBitRate?: number

    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly audioChannels?: number

    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly maxAudioChannels?: number

    /**
     * Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly profile?: string

    /**
     * Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly level?: string

    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly framerate?: number

    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly maxFramerate?: number

    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly copyTimestamps?: boolean

    /**
     * Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly startTimeTicks?: number

    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly width?: number

    /**
     * Optional. The fixed vertical resolution of the encoded video.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly height?: number

    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly videoBitRate?: number

    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly subtitleStreamIndex?: number

    /**
     * Optional. Specify the subtitle delivery method.
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * Optional.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly maxRefFrames?: number

    /**
     * Optional. The maximum video bit depth.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly maxVideoBitDepth?: number

    /**
     * Optional. Whether to require avc.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly requireAvc?: boolean

    /**
     * Optional. Whether to deinterlace the video.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly deInterlace?: boolean

    /**
     * Optional. Whether to require a non anamporphic stream.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * Optional. The maximum number of audio channels to transcode.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * Optional. The limit of how many cpu cores to use.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly cpuCoreLimit?: number

    /**
     * The live stream id.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly liveStreamId?: string

    /**
     * Optional. Whether to enable the MpegtsM2Ts mode.
     * @type {boolean}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url\&#39;s extension. Options: h265, h264, mpeg4, theora, vpx, wmv.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly videoCodec?: string

    /**
     * Optional. Specify a subtitle codec to encode to.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly subtitleCodec?: string

    /**
     * Optional. The transcoding reason.
     * @type {string}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly transcodingReasons?: string

    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly audioStreamIndex?: number

    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @type {number}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly videoStreamIndex?: number

    /**
     * Optional. The MediaBrowser.Model.Dlna.EncodingContext.
     * @type {EncodingContext}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly context?: EncodingContext

    /**
     * Optional. The streaming options.
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiHeadVideoStreamWithExt
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for mergeVersions operation in VideosApi.
 * @export
 * @interface VideosApiMergeVersionsRequest
 */
export interface VideosApiMergeVersionsRequest {
    /**
     * Item id list. This allows multiple, comma delimited.
     * @type {string}
     * @memberof VideosApiMergeVersions
     */
    readonly itemIds: string
}

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * 
     * @summary Removes alternate video sources.
     * @param {VideosApiDeleteAlternateSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public deleteAlternateSources(requestParameters: VideosApiDeleteAlternateSourcesRequest, options?: any) {
        return VideosApiFp(this.configuration).deleteAlternateSources(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets additional parts for a video.
     * @param {VideosApiGetAdditionalPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getAdditionalPart(requestParameters: VideosApiGetAdditionalPartRequest, options?: any) {
        return VideosApiFp(this.configuration).getAdditionalPart(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {VideosApiGetVideoStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStream(requestParameters: VideosApiGetVideoStreamRequest, options?: any) {
        return VideosApiFp(this.configuration).getVideoStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {VideosApiGetVideoStreamWithExtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStreamWithExt(requestParameters: VideosApiGetVideoStreamWithExtRequest, options?: any) {
        return VideosApiFp(this.configuration).getVideoStreamWithExt(requestParameters.itemId, requestParameters.container, requestParameters.stream, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {VideosApiHeadVideoStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStream(requestParameters: VideosApiHeadVideoStreamRequest, options?: any) {
        return VideosApiFp(this.configuration).headVideoStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a video stream.
     * @param {VideosApiHeadVideoStreamWithExtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStreamWithExt(requestParameters: VideosApiHeadVideoStreamWithExtRequest, options?: any) {
        return VideosApiFp(this.configuration).headVideoStreamWithExt(requestParameters.itemId, requestParameters.container, requestParameters.stream, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merges videos into a single record.
     * @param {VideosApiMergeVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public mergeVersions(requestParameters: VideosApiMergeVersionsRequest, options?: any) {
        return VideosApiFp(this.configuration).mergeVersions(requestParameters.itemIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * YearsApi - axios parameter creator
 * @export
 */
export const YearsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear: async (year: number, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getYear.');
            }
            const localVarPath = `/Years/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears: async (startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, recursive?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Years`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YearsApi - functional programming interface
 * @export
 */
export const YearsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYear(year: number, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYear(year, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * YearsApi - factory interface
 * @export
 */
export const YearsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Gets a year.
         * @param {number} year The year.
         * @param {string} [userId] Optional. Filter by user id, and attach user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear(year: number, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return YearsApiFp(configuration).getYear(year, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get years.
         * @param {number} [startIndex] Skips over a given number of items within the results. Use for paging.
         * @param {number} [limit] Optional. The maximum number of records to return.
         * @param {string} [sortOrder] Sort Order - Ascending,Descending.
         * @param {string} [parentId] Specify this to localize the search to a specific item or folder. Omit to use the root.
         * @param {Array<ItemFields>} [fields] Optional. Specify additional fields of information to return in the output.
         * @param {string} [excludeItemTypes] Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
         * @param {string} [includeItemTypes] Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
         * @param {string} [mediaTypes] Optional. Filter by MediaType. Allows multiple, comma delimited.
         * @param {string} [sortBy] Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
         * @param {boolean} [enableUserData] Optional. Include user data.
         * @param {number} [imageTypeLimit] Optional. The max number of images to return, per image type.
         * @param {Array<ImageType>} [enableImageTypes] Optional. The image types to include in the output.
         * @param {string} [userId] User Id.
         * @param {boolean} [recursive] Search recursively.
         * @param {boolean} [enableImages] Optional. Include image information in output.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: Array<ItemFields>, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: Array<ImageType>, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return YearsApiFp(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getYear operation in YearsApi.
 * @export
 * @interface YearsApiGetYearRequest
 */
export interface YearsApiGetYearRequest {
    /**
     * The year.
     * @type {number}
     * @memberof YearsApiGetYear
     */
    readonly year: number

    /**
     * Optional. Filter by user id, and attach user data.
     * @type {string}
     * @memberof YearsApiGetYear
     */
    readonly userId?: string
}

/**
 * Request parameters for getYears operation in YearsApi.
 * @export
 * @interface YearsApiGetYearsRequest
 */
export interface YearsApiGetYearsRequest {
    /**
     * Skips over a given number of items within the results. Use for paging.
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly startIndex?: number

    /**
     * Optional. The maximum number of records to return.
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly limit?: number

    /**
     * Sort Order - Ascending,Descending.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly sortOrder?: string

    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly parentId?: string

    /**
     * Optional. Specify additional fields of information to return in the output.
     * @type {Array<ItemFields>}
     * @memberof YearsApiGetYears
     */
    readonly fields?: Array<ItemFields>

    /**
     * Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly excludeItemTypes?: string

    /**
     * Optional. If specified, results will be included based on item type. This allows multiple, comma delimited.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly includeItemTypes?: string

    /**
     * Optional. Filter by MediaType. Allows multiple, comma delimited.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly mediaTypes?: string

    /**
     * Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly sortBy?: string

    /**
     * Optional. Include user data.
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly enableUserData?: boolean

    /**
     * Optional. The max number of images to return, per image type.
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly imageTypeLimit?: number

    /**
     * Optional. The image types to include in the output.
     * @type {Array<ImageType>}
     * @memberof YearsApiGetYears
     */
    readonly enableImageTypes?: Array<ImageType>

    /**
     * User Id.
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly userId?: string

    /**
     * Search recursively.
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly recursive?: boolean

    /**
     * Optional. Include image information in output.
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly enableImages?: boolean
}

/**
 * YearsApi - object-oriented interface
 * @export
 * @class YearsApi
 * @extends {BaseAPI}
 */
export class YearsApi extends BaseAPI {
    /**
     * 
     * @summary Gets a year.
     * @param {YearsApiGetYearRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYear(requestParameters: YearsApiGetYearRequest, options?: any) {
        return YearsApiFp(this.configuration).getYear(requestParameters.year, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get years.
     * @param {YearsApiGetYearsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYears(requestParameters: YearsApiGetYearsRequest = {}, options?: any) {
        return YearsApiFp(this.configuration).getYears(requestParameters.startIndex, requestParameters.limit, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.mediaTypes, requestParameters.sortBy, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.userId, requestParameters.recursive, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


